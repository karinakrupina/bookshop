const hanaClient = require('./hanaClient')
const registerReconnect = require('./registerReconnect')

const CustomBuilder = require('../customBuilder/')
const HdbStatement = require('../statement/HdbStatement')

const cdsSql = require('@sap/cds-sql')
const { BaseClient } = cdsSql
const {
  convertToBoolean,
  convertInt64ToString,
  convertToISO,
  convertToISONoMillis,
  convertErrorCodeToString,
  convertToString
} = require('../util')

class Client extends BaseClient {
  /**
   * Create a Client object.
   *
   * @param {Object} credentials
   * @param {string} credentials.host - database host
   * @param {number} credentials.port - database port
   * @param {string} credentials.user - username for authentication
   * @param {string} credentials.password - password for authentication
   * @param {string} [credentials.schema] - default schema to be used
   * @param {string} [credentials.ca] - database certificate as needed by hdb driver
   *
   */
  constructor (credentials) {
    super([
      ['cds.Boolean', convertToBoolean],
      ['cds.Integer64', convertInt64ToString],
      ['cds.DateTime', convertToISONoMillis],
      ['cds.Timestamp', convertToISO],
      ['cds.LargeString', convertToString]
    ])

    this._credentials = credentials

    this._dbc = hanaClient.createClient(this._credentials)
    this._user = 'ANONYMOUS' // Use anonymous HANA user as default
    // auto-commit is true by default
    this._dbc.setAutoCommit(true)
    this._transCount = 0

    registerReconnect(this)
  }

  /**
   * Open database connection.
   *
   * @returns {Promise} Promise that resolves with Client if successful and rejects if not.
   */
  connect () {
    return new Promise((resolve, reject) => {
      this._dbc.connect(err => {
        if (err) {
          return reject(convertErrorCodeToString(err))
        }

        if (this._credentials.schema) {
          this.execute(`SET SCHEMA ${this._credentials.schema}`)
            .then(() => {
              this._isInUse = true
              resolve(this)
            })
            .catch(err => {
              this._dbc.end()
              reject(convertErrorCodeToString(err))
            })
        } else {
          this._isInUse = true
          return resolve(this)
        }
      })
    })
  }

  /**
   * Close database connection.
   *
   * @returns {Promise} Promise that resolves if successful and rejects if not.
   */
  end () {
    this._isInUse = false
    return Promise.resolve(this._dbc.end())
  }

  /**
   * Execute SQL statement.
   *
   * If execution of SQL statement requires additional values,
   * then the values to be provided as an array.
   * In order to provide multiple value sets with a single execute (example: batch insert)
   * values have to be provided as arrays of values composed in an outer array.
   *
   * Method returns a result object.
   * For example, in case of SELECT the result object contains a result-set.
   * In case of INSERT/DELETE the result object contains a number of affected rows.
   *
   *  The query can be provided as SQL string or as CQN object.
   *
   * @example <caption>Simple Select as SQL string<caption>
   * .execute("SELECT * FROM T")
   * @example <caption>Select with filter as SQL string<caption>
   * .execute("SELECT * FROM T WHERE X = ?", [1])
   * @example <caption>Single Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [1, 'a'])
   * @example <caption>Multiple Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [[1, 'a'], [2, 'b']])
   * @example <caption>Simple Select as CQN object<caption>
   * .execute(SELECT.from('T'))
   * @example <caption>Select with filter as CQN object<caption>
   * .execute(SELECT.from('T').where(['x', '=', 1])
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
   * Result object can be undefined.
   */
  execute (query, values = []) {
    if (this._toBeDestroyed) {
      return Promise.reject(new cdsSql.errors.InconsistentClientError())
    }

    if (!Array.isArray(values)) {
      return Promise.reject(new cdsSql.errors.IllegalFunctionArgumentError('values'))
    }

    if (typeof query === 'string') {
      return this._executeSQL(query, values, new Map())
    }

    if (typeof query === 'function') {
      return this._runBlock(query)
    }

    try {
      if (cdsSql.expand.hasExpand(query)) {
        return this._processExpand(query)
      }

      if (cdsSql.composition.hasCompositionDelete(this._csn && this._csn.definitions, query)) {
        return this._processCascadeDelete(query)
      }

      if (cdsSql.composition.hasDeepInsert(this._csn && this._csn.definitions, query)) {
        return this._processDeepInsert(query)
      }

      if (cdsSql.composition.hasDeepUpdate(this._csn && this._csn.definitions, query)) {
        return this._processDeepUpdate(query)
      }

      return this._execute(query, values)
    } catch (err) {
      // in case an object is passed and sql builder throws an error
      return Promise.reject(convertErrorCodeToString(err))
    }
  }

  _execute (query, inValues = []) {
    const query_ = this._addDefaultValues(query, false, true)

    const { sql, values = [] } = cdsSql.builder.sqlFactory(
      query_,
      {
        typeConversion: this._typeConversionMap,
        customBuilder: CustomBuilder,
        user: this._user
      },
      this._csn
    )

    const { postProcessing: { getPostProcessMapper, getPropertyMapper, getStructMapper } } = cdsSql

    const propertyMapper = getPropertyMapper(this._csn, query, true)

    const outValues = inValues.length > 0 ? inValues : values
    return this._executeSQL(
      sql,
      outValues,
      getPostProcessMapper(this._toService, this._csn, query),
      propertyMapper,
      getStructMapper(this._csn, query, propertyMapper)
    )
  }

  _processExpand (cqn) {
    const queries = []
    const expandQueries = cdsSql.expand.createJoinCQNFromExpanded(cqn, this._csn, true)

    for (const cqn of expandQueries.queries) {
      cqn._conversionMapper = cdsSql.postProcessing.getPostProcessMapper(this._toService, this._csn, cqn)

      const { sql, values } = cdsSql.builder.sqlFactory(cqn, undefined, this._csn)
      queries.push(this._executeExpand(sql, values))
    }

    return cdsSql.expand.rawToExpanded(expandQueries, queries)
  }

  _executeExpand (sql, values) {
    if (Array.isArray(values) && values.length !== 0) {
      return this.prepareStatement(sql).then(statement => {
        return statement.execute(values)
      })
    }

    return new Promise((resolve, reject) => {
      this._dbc.exec(sql, (err, result) => {
        if (err) {
          convertErrorCodeToString(err)
          err.failedQuery = sql
          return reject(err)
        }

        resolve(result)
      })
    })
  }

  _processCascadeDelete (cqn) {
    return this.processNestedCQNs(
      cdsSql.composition.createCascadeDeleteCQNs(this._csn && this._csn.definitions, cqn),
      this._execute.bind(this)
    )
  }

  _processDeepInsert (cqn) {
    return this.processNestedCQNs(
      [cdsSql.composition.createDeepInsertCQNs(this._csn && this._csn.definitions, cqn)],
      this._execute.bind(this)
    )
  }

  _processDeepUpdate (cqn) {
    /* istanbul ignore next */
    return cdsSql.composition
      .selectDeepUpdateData(this._csn && this._csn.definitions, cqn, this._execute.bind(this))
      .then(selectData => {
        return this.processNestedCQNs(
          cdsSql.composition.createDeepUpdateCQNs(this._csn && this._csn.definitions, cqn, selectData),
          this._execute.bind(this)
        )
      })
  }

  _executeSQL (sql, values, postMapper, propertyMapper, objStructMapper) {
    if (values.length !== 0) {
      return this.prepareStatement(sql)
        .then(statement => {
          return statement.execute(values)
        })
        .then(result => {
          return Promise.resolve(cdsSql.postProcessing.postProcess(result, postMapper, propertyMapper, objStructMapper))
        })
        .catch(err => {
          return Promise.reject(err)
        })
    }

    return new Promise((resolve, reject) => {
      this._dbc.exec(sql, (err, result) => {
        if (err) {
          convertErrorCodeToString(err)
          err.failedQuery = sql
          return reject(err)
        }

        resolve(cdsSql.postProcessing.postProcess(result, postMapper, propertyMapper, objStructMapper))
      })
    })
  }

  /**
   * Prepare SQL statement.
   *
   * @param {string} sql - SQL string to be prepared.
   * @returns {Promise} Promise, that resolves with HdbStatement if successful and rejects if not.
   */
  prepareStatement (sql) {
    return new Promise((resolve, reject) => {
      this._dbc.prepare(sql, (err, statement) => {
        if (err) {
          convertErrorCodeToString(err)
          err.failedQuery = sql
          return reject(err)
        }

        resolve(new HdbStatement(statement, sql))
      })
    })
  }

  /**
   * Returns connection state.
   *
   * @returns {boolean} Returns if client is connected to the database or not.
   */
  isConnected () {
    return this._dbc.readyState === 'connected' || (this._dbc.state && this._dbc.state() === 'connected')
  }

  /**
   * Set database locale.
   *
   * @param {string} locale - String representation of locale.
   * @example
   * "en_US" "de_DE"
   */
  setLocale (locale) {
    this._locale = locale || 'en_US'

    if (this._dbc._connection) {
      // Works, but bad practise to access an internal scope
      this._dbc._connection.getClientInfo().setProperty('LOCALE', this._locale)
    } else {
      this._dbc.setClientInfo('LOCALE', this._locale)
    }
  }

  /**
   * Set database user.
   *
   * @param {string} user - User name.
   *
   * Default is an ANONYMOUS user.
   */
  setUser (user) {
    this._user = user || 'ANONYMOUS' // Use anonymous HANA user as fallback

    if (this._dbc._connection) {
      // Works, but bad practise to access an internal scope
      this._dbc._connection.getClientInfo().setProperty('XS_APPLICATIONUSER', this._user)
    } else {
      this._dbc.setClientInfo('XS_APPLICATIONUSER', this._user)
    }
  }

  /**
   * Execute begin transaction.
   *
   * @returns {Promise} - Resolves if begin is successful, rejects if not.
   *
   * Note: In the current implementation the auto-commit is always set to false.
   * The begin method is needed for compliance with the Sqlite client.
   * The current implementation always resolves.
   */
  begin () {
    this._transCount++
    if (this._transCount === 1) {
      this._dbc.setAutoCommit(false)
    }

    return Promise.resolve()
  }

  /**
   * Execute commit transaction.
   *
   * @returns {Promise} - Resolves if commit is successful, rejects if not.
   */
  commit () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }
    this._transCount--
    if (this._transCount === 0) {
      this._dbc.setAutoCommit(true)
      return new Promise((resolve, reject) => {
        this._dbc.commit(err => {
          if (err) {
            return reject(convertErrorCodeToString(err))
          }
          resolve()
        })
      })
    }

    return Promise.resolve()
  }

  /**
   * Execute rollback transaction.
   *
   * @returns {Promise} - Resolves if rollback is successful, rejects if not.
   */
  rollback () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }
    this._transCount--
    if (this._transCount === 0) {
      this._dbc.setAutoCommit(true)
      return new Promise((resolve, reject) => {
        this._dbc.rollback(err => {
          if (err) {
            return reject(convertErrorCodeToString(err))
          }
          resolve()
        })
      })
    }

    return Promise.resolve()
  }

  /**
   * Forwards deploy to the base class providing client information.
   * @param {Object|Promise} csn - the unreflected CSN or promise that will resolve into csn.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    return super.deploy(csn, 'hana')
  }

  /**
   * As hana does not support 'drop if exists' we need to handle this separately here.
   * Drop should not throw an error in case it was not successful because a table did not exist.
   * So we need to catch all errors related to not existing tables.
   * @private
   */
  _addDropsToChain (chain, drop) {
    return chain.then(() =>
      this.run(drop).catch(err => {
        if (!this._ignoreError(err)) {
          throw err
        }
      })
    )
  }

  _ignoreError (err) {
    // hana error code for table/view does not exist
    return err.code === '259' || err.code === '321'
  }
}

module.exports = Client
