const fs = require('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')

const HDI_NAMESPACE_CONTENT = {
    "name": "",
    "subfolder": "ignore"
}

const GENERATED_SOURCES_FOLDER = path.join("src", "gen")

class HanaModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Hana DB Module Builder", task, buildOptions)
    }

    build() {
        const {
            src,
            dest,
            options
        } = this.task

        if (!options) {
            this.logger.error(`[cds] - invalid build task definition '${src}' - options required`)
            return Promise.reject(`Invalid build task definition '${src}' - options required`)
        }

        const modelPaths = this._resolve()

        this.logger.log(`\n[cds] - building module [${src}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no models found")
            return Promise.resolve()
        }

        this.logger.log(`  cds models: ${modelPaths.join(", ")}`)

        return Promise.all([
            this._compilePersistenceModel(modelPaths, dest),
            this._copyNativeContent(src, dest),
            this._writePackageJson(src, dest),
            this._writeHdiConfig(src, dest),
            this._writeHdiNamespace(dest)
        ])
    }

    clean() {
        const srcGenDir = path.join(this.task.src, GENERATED_SOURCES_FOLDER)
        const promises = []

        // make sure a gen folder created by an inplace build will be deleted
        if (fs.existsSync(srcGenDir)) {
            promises.push(fs.remove(srcGenDir))
        }

        if (this.task.src !== this.task.dest) {
            promises.push(super.clean())
        }
        return Promise.all(promises)
    }

    _resolve() {
        return this.cds.resolve(this.task.options.model, this.buildOptions)
    }

    _copyNativeContent(src, dest) {
        const dbSrcDir = path.join(src, "src")

        // 1. copy '.csv' files located in 'db/src/**' to '<target>/db/src/**'
        // 2. copy '.csv' files located in 'db' to 'db/src
        return super._copyNativeContent(src, dest, (entry) => {
            const extname = path.extname(entry)
            return (fs.statSync(entry).isDirectory() && path.dirname(entry) !== dest) ||
                (extname !== ".csv" && extname !== ".cds" && entry !== this.cds.env.build.outputfile) ||
                (extname === ".csv" && entry.startsWith(dbSrcDir))
        }).then(() => {
            const csvFiles = this._find(src, (entry) => {
                return ((fs.statSync(entry).isDirectory() || path.extname(entry) === ".csv") && !entry.startsWith(dbSrcDir))
            })
            return Promise.all(csvFiles.map((csvFile) => {
                return this.write(csvFile).to(path.join(dest, GENERATED_SOURCES_FOLDER, path.relative(src, csvFile)))
            }))
        })
    }

    _compilePersistenceModel(modelPaths, dest) {
        return this.cds.load(modelPaths).then(model => {
            const promises = []
            // .hdbcds files
            for (let [each, {
                    name
                }] of this.cds.compile.to.hana(model)) {
                promises.push(this.write(each).to(path.join(dest, GENERATED_SOURCES_FOLDER, name + ".hdbcds")))
            }

            return Promise.all(promises)
        })
    }

    _writePackageJson(src, dest) {
        return fs.exists(path.join(src, "package.json"))
            .then((exists) => {
                if (src === dest || exists) {
                    return Promise.resolve()
                }

                return this._readTemplateAsJson(path.join("db", "hana", "package.json")).then((content) => {
                    return this.write(content).to(path.join(dest, "package.json"))
                })
            })
    }

    _writeHdiConfig(src, dest) {
        return fs.exists(path.join(src, "src", ".hdiconfig"))
            .then((exists) => {
                if (src === dest || exists) {
                    return Promise.resolve()
                }

                return this._readTemplateAsJson(path.join("db", "hana", "src", ".hdiconfig")).then((content) => {
                    return this.write(content).to(path.join(dest, "src", ".hdiconfig"))
                })
            })
    }

    _writeHdiNamespace(dest) {
        // see issue #64 - add .hdinamespace file to prevent HDI from adding gen/ folder to the namespace.
        return this.write(HDI_NAMESPACE_CONTENT).to(path.join(dest, GENERATED_SOURCES_FOLDER, ".hdinamespace"))
    }

    _readTemplateAsJson(relTemplatePath) {
        const cdsGen = require("@sap/generator-cds")
        const templatePath = path.join(cdsGen.templatePath, relTemplatePath)

        return fs.readJSON(templatePath).catch((error) => {
            this.logger.error(`Failed to read cds generator template [${templatePath}]`)
            return Promise.reject(error)
        })
    }
}
module.exports = HanaModuleBuilder