const fs = require('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')
const URL = require('url')

class FioriAppModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Fiori UI Module Builder", task, buildOptions)
    }

    /**
     * This version only creates a odata representation for the 'mainService' data source
     * as defined by the fiori wizard - everything else is currently not supported.
     * Therefore errors are only logged, the build does not fail in case a the service
     * cannot be resolved based on the defined service URI
     */
    build() {
        const {
            src,
            dest
        } = this.task

        const modelPaths = this._resolve()

        this.logger.log(`\n[cds] - building module [${src}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log(`[cds] - no models found`)
            return Promise.resolve()
        }

        this.logger.log(`  cds models: ${modelPaths.join(", ")}`)

        return this.cds.load(modelPaths).then(model => {
            return Promise.all([
                this._compileEdmx(model, src, dest),
                this._copyNativeContent(src, dest)
            ])
        })
    }

    _resolve() {
        return this.cds.resolve((this.task.options && this.task.options.model) || this.task.src, this.buildOptions)
    }

    _copyNativeContent(src, dest) {
        return super._copyNativeContent(src, dest, (entry) => {
            const extname = path.extname(entry)
            return ((fs.statSync(entry).isDirectory() && path.dirname !== dest) || extname !== '.cds')
        })
    }

    _compileEdmx(model, src, dest) {
        const manifestPath = path.join(src, 'webapp', 'manifest.json')
        let manifest

        try {
            manifest = require(manifestPath)
        } catch (error) {
            this.logger.log(`UI module does not contain a manifest.json [${manifestPath}] - skip build`)
            return Promise.resolve()
        }

        const mainService = this._property(manifest, 'sap.app', 'dataSources', 'mainService')
        if (!mainService) {
            // no mainService defined - not supported
            this.logger.log(`UI module does not contain a mainService [${manifestPath}] - skip build`)
            return Promise.resolve()
        }

        const localUri = this._property(mainService, 'settings', 'localUri')
        const uri = mainService.uri

        if (localUri && uri) {
            try {
                const edmx = this._compileEdmxForUri(model, uri)
                const edmxPath = path.resolve(path.join(dest, 'webapp'), this._strippedUrlPath(localUri))

                return this.write(edmx).to(edmxPath)
            } catch (error) {
                this.logger.error(`Failed to compile edmx representation for service uri ${uri}, data source [mainService]`)
                this.logger.error(error.stack)
            }
        } else {
            this.logger.error(`Failed to compile odata representation for data source [mainService], [${manifestPath}]`)
        }

        // ignoring errors
        return Promise.resolve(`Failed to build odata representation for [mainService] for UI module [${path.relative(this.buildOptions.root, src)}]`)
    }

    _compileEdmxForUri(model, uri) {
        const uriSegments = this._strippedUrlPath(uri).split('/')
        // one segment of the URI has to match a service name
        let service = this.cds.reflect(model).find(service => uriSegments.find(segment => service.name === segment))

        if (service) {
            return this.cds.compile.to.edmx(model, {
                service: service.name
            })
        }
        throw new Error(`Failed to resolve service name from URI ${uri} as defined in manfifest.json`)
    }

    _strippedUrlPath(urlString) {
        const url = URL.parse(urlString)
        return url.pathname.replace(/^(\/|\\)/, '').replace(/(\/|\\)$/, '') // strip leading and trailing slash or backslash)
    }

    _property(src, ...segments) {
        return segments.reduce((p, n) => p && p[n], src)
    }
}

module.exports = FioriAppModuleBuilder