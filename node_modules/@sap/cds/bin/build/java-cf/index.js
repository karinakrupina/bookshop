const fs = require('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')
const GENERATED_SOURCES_FOLDER = path.join("src", "main", "resources", "edmx")

class JavaCfModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Java CF Module Builder", task, buildOptions)
    }

    build() {
        const {
            src,
            dest,
            options
        } = this.task

        const modelPaths = this._resolve()

        this.logger.log(`\n[cds] - building module [${src}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log(`[cds] - no models found`)
            return Promise.resolve()
        }

        this.logger.log(`  cds models: ${modelPaths.join(", ")}`)

        return this.cds.load(modelPaths).then(model => {
            return Promise.all([
                this._compileCsn(model, dest),
                this._compileEdmx(model, dest, options),
                this._copyNativeContent(src, dest)
            ])
        })
    }

    clean() {
        const srcGenDir = path.join(this.task.src, GENERATED_SOURCES_FOLDER)
        const promises = []

        // make sure a gen folder created by an inplace build will be deleted
        if (fs.existsSync(srcGenDir)) {
            promises.push(fs.remove(srcGenDir))
        }

        if (this.task.src !== this.task.dest) {
            promises.push(super.clean())
        }
        return Promise.all(promises)
    }

    _resolve() {
        const {
            src,
            options
        } = this.task

        //check whether it's a node.js service definition
        if (!fs.existsSync(path.join(src, 'pom.xml'))) {
            this.logger.log(`[cds] - module [${src}] is not of type java - skip`)
            return []
        }
        return this.cds.resolve((options && options.model) || src, this.buildOptions)
    }

    _compileCsn(model, dest) {
        // csn for service providers
        const csn = this.cds.compile.for.odata(model)

        return this.write(csn).to(path.join(dest, GENERATED_SOURCES_FOLDER, 'csn.json'))
    }

    _compileEdmx(model, dest, options) {
        const promises = []
        const locales = this.cds.localize(model, options.lang || ['all'])
        if (locales) {
            for (let [localizedModel, {lang}] of locales) {
                let edmxModels = this.cds.compile.to.edmx(localizedModel, {service: 'all'})
                if (edmxModels) {
                    for (let [edmx, {name}] of edmxModels) {
                        promises.push(this.write(edmx).to(path.join(dest, GENERATED_SOURCES_FOLDER, name + (lang ? '_' + lang + '.xml' : '.xml'))))
                    }
                }
            }
        }
        return Promise.all(promises)
    }

    _copyNativeContent(src, dest) {
        return super._copyNativeContent(src, dest, (entry) => {
            const extname = path.extname(entry)
            return ((fs.statSync(entry).isDirectory() && path.dirname !== dest) || extname !== '.cds')
        })
    }
}

module.exports = JavaCfModuleBuilder