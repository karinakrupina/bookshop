const fs = require('fs-extra')
const path = require('path')
const BuildTaskHandler = require('../buildTaskHandler')

class NodeCfModuleBuilder extends BuildTaskHandler {
    constructor(task, buildOptions) {
        super("Node CF Module Builder", task, buildOptions)
    }

    build() {
        const {
            src,
            dest
        } = this.task

        // resolve specified models, using all models by default, e.g.
        // { use:'...', src:'srv', options:{model:['app','srv']} }
        // { use:'...', src:'srv' }
        const modelPaths = this._resolve()

        this.logger.log(`\n[cds] - building module [${src}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no models found")
            return Promise.resolve()
        }

        this.logger.log(`  cds models: ${modelPaths.join(", ")}`)

        // collect all sources...
        return this._collectSources(modelPaths, src)
            .then(sources => {
                const bundles = this._collectBundles(Object.keys(sources.sources))
                const {
                    folders = ['i18n'], file = 'i18n'
                } = this.cds.env.i18n

                const promises = []
                promises.push(this.write(sources).to(path.join(dest, 'gen', 'csn.json')))
                promises.push(this._copyNativeContent(src, dest))

                if (Object.keys(bundles).length > 0) {
                    promises.push(this.write(bundles).to(path.join(dest, 'gen', folders[0], file + '.json')))
                }

                return Promise.all(promises)
            })
    }

    clean() {
        const genDir = path.join(this.task.src, "gen")
        const promises = []

        // make sure a gen folder created by an inplace build will be deleted
        if (fs.existsSync(genDir)) {
            promises.push(fs.remove(genDir))
        }

        if (this.task.src !== this.task.dest) {
            promises.push(super.clean())
        }
        return Promise.all(promises)
    }

    _resolve() {
        const {
            src,
            options
        } = this.task

        //check whether it's a node.js service definition
        if (fs.existsSync(path.join(src, 'pom.xml'))) {
            this.logger.log(`[cds] - module [${src}] is of type java`)
            return []
        }
        return this.cds.resolve((options && options.model) || src, this.buildOptions)
    }

    _collectSources(modelPaths, src) {
        const cdsv = require('../../../lib/models/cdsv')

        return cdsv.collectSources(modelPaths, path.relative(process.cwd(), src))
            .then(sources => {
                // remember the src --> used in cds.load()
                sources.srv = src
                return Promise.resolve(sources)
            })
    }

    _collectBundles(sources) {
        // collect effective i18n properties...
        let bundles = {}
        const bundleGenerator = this.cds.localize.bundles4({
            _sources: sources
        })

        if (typeof bundleGenerator === "object" && bundleGenerator.next) {
            for (let [locale, bundle] of bundleGenerator) {
                // fallback bundle has the name ""
                if (typeof locale === 'string') {
                    bundles[locale] = bundle
                }
            }
        }

        // omit bundles in case the fallback bundle is the only existing entry
        const keys = Object.keys(bundles)
        if (keys.length === 1 && keys[0] === "" && Object.keys(bundles[keys[0]]).length === 0) {
            bundles = {}
        }

        return bundles
    }

    _copyNativeContent(src, dest) {
        return super._copyNativeContent(src, dest, (entry) => {
            const extname = path.extname(entry)
            return ((fs.statSync(entry).isDirectory() && path.dirname !== dest) || extname !== '.cds')
        })
    }
}

module.exports = NodeCfModuleBuilder