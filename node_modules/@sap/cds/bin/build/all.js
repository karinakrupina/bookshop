const path = require('path')
const fs = require('fs')
const _cds = require('../../lib')
const BuildTaskEngine = require('./buildTaskEngine')

module.exports = Object.assign(build, {
    options: ['--project', '--for', '--use', '--src', '--dest', '--options-model'],
    flags: ['--clean'],
    shortcuts: ['-in', '4', '', '', '-o'],
    help: `
# SYNOPSIS

    *cds build* [<options>]

    Builds the modules by compiling contained cds sources.
    The modules are folders in the project root.
    Cleaning the build target is always performed before actual build.


# OPTIONS

    *-in* | *--project* <folder>

        use the specified folder as the project root.
        default = current working directory ./

    *-4* | *--for* <target>

        alias used to build the source, e.g. hana -> @sap/cds/build/hana.

    *--use* <module>

       fully qualified name of the npm module used to build the source.
       In the current version external build plugins are not supported.

    *--src*

        source folder used as build input

    *-o*  | *--dest* <folder>

        writes output to the given folder of the project root directory.
        default = ${_cds.env.build.target}

    *--options-<name>

        any build plugin specific options that need to be passed,
        e.g. options-model db, srv.


# EXAMPLES

   *cds* build/all --clean
   *cds* build/all -o _out
   *cds* build/all --for hana --src db --model srv --dest db
   *cds* build/all --use @sap/cds/build/hana --src db --dest db --options-model db, srv
`
})

function build([project], cmdOptions = {}, /* for unit tests only: */ _env = null) {
    if (!project) {
        project = cmdOptions.project
    }

    const logger = cmdOptions.logger || global.console
    const projectRoot = path.resolve(project || '.')
    const projectName = path.basename(projectRoot)

    if (!fs.lstatSync(projectRoot).isDirectory()) {
        return Promise.reject(`Project [${projectRoot}] does not exist`)
    }

    const cds = _cds.in(projectRoot)
    if (_env) {
        cds.env = cds.env.merge(cds.env, _env)
    }

    const info = require('../version').get()
    logger.log(`\n[cds] - cds [${info['@sap/cds']}], compiler [${info['@sap/cds-compiler']}], home [${info.home}]\n`)

    const buildOptions = {
        root: projectRoot
    }

    let buildTasks = _getBuildTasks(cds, cmdOptions)
    if (buildTasks.length === 0) {
        buildTasks = _createBuildTasksFromCdsConfig(cds.env, projectRoot)
        if (buildTasks.length > 0) {
            let buildTasksOutput = "{\n  \"build\": {\n    \"target\": \".\",\n    \"tasks\": ["
            for (let i = 0; i < buildTasks.length; i++) {
                buildTasksOutput += "\n      " + JSON.stringify(buildTasks[i]) + (i + 1 < buildTasks.length ? "," : "")
            }
            buildTasksOutput += "\n    ]\n  }\n}\n"

            cds.env.build.mode = "inplace"

            logger.warn(`No CDS build tasks found for project [${projectName}].`)
            logger.warn(`These build tasks will be required with the next release of @sap/cds. Please add the following contents to ./.cdsrc.json in your project.`)
            logger.log(buildTasksOutput)
        }
    }

    if (cds.env.build.mode === "inplace") {
        cds.env.build.target = "."
    }

    return new BuildTaskEngine(logger, cds).processTasks(buildTasks, buildOptions, cmdOptions.clean)
}

function _getBuildTasks(cds, cmdOptions) {
    let buildTasks = _getBuildTaskFromCommandLine(cmdOptions)
    if (buildTasks.length === 0) {
        // full build
        if (Array.isArray(cds.env.build.tasks)) {
            buildTasks = cds.env.build.tasks
        }
    }
    return buildTasks
}

function _getBuildTaskFromCommandLine(cmdOptions) {
    const buildTasks = []
    // check for dedicated module build
    if (cmdOptions.for || cmdOptions.use) {
        // TODO generic command-line options -> JSON mapping
        let model = {}
        if (Array.isArray(cmdOptions["options-model"])) {
            model = cmdOptions["options-model"]
        } else if (typeof cmdOptions["options-model"] === "string") {
            model = cmdOptions["options-model"].split(",").map((entry) => entry.trim())
        }

        buildTasks.push({
            "use": cmdOptions["for"] ? "@sap/cds/bin/build/" + cmdOptions.for : cmdOptions.use,
            "src": cmdOptions["src"],
            "dest": cmdOptions["dest"],
            "options": {
                model
            }
        })
    }
    return buildTasks
}

function _createBuildTasksFromCdsConfig(env, projectRoot) {
    // stripping '/' if this is the last character
    let data = env.data && typeof env.data.model === "string" ? env.data.model.replace(/\/$/, '') : "db"
    let srv = env.service && typeof env.service.model === "string" ? env.service.model.replace(/\/$/, '') : "srv"

    if (!fs.existsSync(path.resolve(projectRoot, data))) {
        data = null
    }
    const srvPath = path.resolve(projectRoot, srv)
    if (!fs.existsSync(srvPath)) {
        srv = null
    }
    const options = {
        model: env.data && Array.isArray(env.data.model) ? env.data.model : []
    }
    if (options.model.length === 0) {
        if (data) {
            options.model.push(data)
        }
        if (srv) {
            options.model.push(srv)
        }
    }

    let buildTasks = []

    if (data && env.data && (!env.data.kind || env.data.kind === "hana" || env.data.driver === "hana")) {
        buildTasks.push({
            src: data,
            for: "hana",
            options: options
        })
    }
    if (srv) {
        if (fs.existsSync(path.join(srvPath, 'pom.xml'))) {
            buildTasks.push({
                src: srv,
                for: "java-cf",
                options: options
            })
        } else {
            // node service build is odata v4 only
            // as fiori is currently v2 only we omit any fiori build tasks
            buildTasks.push({
                src: srv,
                for: "node-cf",
                options: options
            })
        }
    }

    const fioriBuildTasks = _createFioriBuildTasks(env, projectRoot, options)
    buildTasks = buildTasks.concat(fioriBuildTasks)

    return buildTasks
}

function _createFioriBuildTasks(env, projectRoot, options) {
    const DEFAULT_UI_MANIFEST_PATTERNS = [
        '*/webapp/manifest.json', // top-level UI apps  (typical Web IDE layout)
        'app/*/webapp/manifest.json' // UI apps below app/ (good for grouping many UI apps)
    ]
    let buildTasks = []

    // fiori-app build-tasks
    let appPaths = env.ui && env.ui.apps ? env.ui.apps : undefined
    if (!appPaths) {
        const manifestPaths = findFiles(projectRoot, DEFAULT_UI_MANIFEST_PATTERNS)
        appPaths = manifestPaths.map(manifestPath => path.relative(projectRoot, manifestPath).split("webapp")[0])
    }

    appPaths.forEach(appPath => {
        //replace trailing '/'
        appPath = appPath.replace(/\/$/, '')
        const newBuildTask = {
            src: appPath,
            for: "fiori",
            options: {
                model: options.model.concat([appPath])
            }
        }
        if (!buildTasks.find((buildTask) => {
                return buildTask.src === newBuildTask.src && buildTask.for === newBuildTask.for
            })) {
            buildTasks.push(newBuildTask)
        }
    })

    return buildTasks
}

function flatten(o, arr = []) {
    if (o) {
        Array.isArray(o) ? o.forEach(e => flatten(e, arr)) : arr.push(o)
    }
    return arr
}

function strippedPath(p) {
    return p.replace(/^(\/|\\)/, '').replace(/(\/|\\)$/, '') // strip leading and trailing slash or backslash
}

function readDirs(dir) {
    if (!fs.existsSync(dir) || !fs.lstatSync(dir).isDirectory()) return []
    return fs.readdirSync(dir)
        .map(f => path.resolve(dir, f))
        .filter(f => fs.lstatSync(f).isDirectory())
}

function findFiles(projectRoot, patterns) {
    const files = []
    patterns.forEach(pattern => {
        const starIndex = pattern.indexOf('*')
        if (starIndex >= 0) {
            const dir = path.resolve(projectRoot, pattern.substring(0, starIndex))
            const subPattern = strippedPath(pattern.substring(starIndex + 1, pattern.length)) // '*/foo/bar/' -> 'foo/bar'
            files.push(...readDirs(dir).map(subDir => findFiles(subDir, [subPattern])))
        } else {
            const file = path.resolve(projectRoot, pattern)
            if (fs.existsSync(file)) files.push(file)
        }
    })
    return flatten(files)
}
