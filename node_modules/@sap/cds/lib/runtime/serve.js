/*USAGE:*/()=>{
  const app = require('express')()
  cds.serve('all').in(app)  //> no subsequent .at() or .with() possible
  cds.serve('CatalogService').from('all').in(app).at('/mount-point').with(function(){
    const { Books } = this.entities
    this.on('READ', Books, (req) => req.reply([]))
  })
}

module.exports = cds_serve
const cds = require('../index'), {service} = cds
const EventEmitter = require('events')
const isIdentifier = (x) => typeof x === 'string' && /^[A-Za-z_$][\w$]*$/.test (x)
const cache = cds_serve.cache = {}

const ProtocolAdapter = {for:(to,p) => (
  to === 'odata' ? service.adapter.for.odata_v4(p) :
  to === 'fiori' ? service.adapter.for.odata_v4(p) :
  to === 'rest' ? service.adapter.for.rest(p) :
  !to ? service.adapter.for.odata_v4(p) :
  (()=>{ throw new Error (`service protocol ${to} is not supported`) })()
)}

/**
 * Load given model(s) and construct providers for all defined services.
 */
function cds_serve (service_or_model, options={}) { // NOSONAR

  if (!isIdentifier(service_or_model)) {
    return cds_serve('all',options).from(service_or_model)
  }

  const cds = this.serve === cds_serve ? this : global.cds
  const providers=[] //> filled in _constructProviders
  const ready = Promise.resolve().then (_loadModel) .then (_constructProviders)
  const fluent = _fluent (options)
  return fluent

  /**
   * Fluent API used to fill in options subsequently
   */
  function _fluent (o=options) {
    return {__proto__: EventEmitter.prototype,
      from (model) { o.service = service_or_model; o.model = model; return this },
      to (protocol) { o.to = protocol; return this },
      at (path) { o.at = path; return this },
      in (app) { ready.then (()=>_addProviders2(app)); return this },
      with (impl) { o.with = impl; return this },
      then (resolve,err) { return ready.then (()=> resolve (_returnProviders()), err) },
      catch (e) { return ready.catch(e) },
    }
  }

  /**
   * Load the given model if it's not already a parsed csn passed in
   */
  function _loadModel(){
    let model = options.model
    if (typeof model === 'object' && !Array.isArray(model)) return model //> already a csn
    if (!model) {
      if (options.service)  model = service_or_model //> compat to cds.serve('all',{service})
      else { options.service = service_or_model;  model = 'all' }
    }
    if (model === 'all' || model[0] === 'all') {
      model = [ cds.env.folders.app, cds.env.folders.srv, 'services', '.' ].find (m => cds.resolve(m))
      if (!model)  throw new Error (`[cds] - \n
        No service models found in current working directory.
        Make sure you call cds.serve in the root of your project.
      `)
    }
    const key = Array.isArray(model) ? model.join(';') : model
    const cached = cache[key]
    if (cached) return cached
    else  return cache[key] = cds.load (model)
  }

  /**
   * Construct providers for all services defined in the loaded model.
   */
  function _constructProviders (csn, n=0) {

    const o=options, external = cds.env.requires
    const chosen = o.service && o.service !== 'all' ? def => def.name.endsWith (o.service) : ()=>true
    fluent.emit ('loaded', csn)

    // prepare and register all services
    cds.reflect(csn) .foreach (service, def => {
      const name = def.name
      if (def['@cds.ignore']  ||  !chosen(def)  ||  external[name])  return
      if ((o.at || o.with) && ++n > 1) throw new Error('You cannot specify `path` or `impl` for multiple services')
      const serviceOptions = {...o, at: service.path4 (def, o.at) }
      const provider = service.for (csn, {service: name, __proto__: serviceOptions})
      provider.path = serviceOptions.at
      provider.impl = service.impl4 (def, o.with)
      fluent.emit ('add', provider)
      providers.push (FIX_Service (provider))
      // .services [name] = provider
      //> only possible when ServiceProvider == ServiceClient
      Object.defineProperty (cds.services, name, { configurable:1,
        set:(s)=> Object.defineProperty (cds.services, name, {value:s, writable:1}),
        get:()=> cds.services[name] = service.client.for (name),
      })
    })

    // invoke all service impl functions --> in a pass 2 to allow them connect to local services
    _addImpls()

    fluent.emit ('done', csn)
    return providers
  }

  /**
   * Add constructed providers to express app
   */
  function _addProviders2 (app) {
    for (let each of providers) {
      app.use (each.path, ProtocolAdapter.for (options.to, each))
    }
  }

  /**
   * Invoke all provided service implementation functions or classes
   */
   function _addImpls () {

    for (let each of providers) {
      const impl = each.impl
      if (typeof impl === 'function') {
        if (/^class\s/.test(Function.prototype.toString.call(impl))) {
          const inst = new impl (each)
          for (let p of Reflect.ownKeys (impl.prototype)) {
            if (p in {constructor:1, prototype:1})  continue
            each.on (p, (...args) => inst[p](...args))
          }
        }
        else each.impl (each)
      }
    }
  }

  /**
   * Returns a single picked provider or a map of all constructed providers
   */
  function _returnProviders(){
    if (options.service && options.service !== 'all')  return providers[0]
    const all={}; for (let each of providers)  all [each.name] = each
    return all
  }

  function FIX_Service (service) {
    const model = service.model
    return Object.defineProperties (service, {
      options: {get:()=> service._options},
      entities: {get:()=> model.entries ('entities', d => d.kind === 'entity', /*in:*/ service)},
      types: {get:()=> model.entries ('types', d => d.kind !== 'entity', /*in:*/ service)},
    })
  }

}
