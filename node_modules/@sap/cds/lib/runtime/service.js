const fs = require('../utils/fs')
const lib = require('@sap/cds-services')
const cds = require ('../index.js')
lib.inject(cds)

/**
 * Decorate cds.service
 */
module.exports = Object.assign (cds.builtin.classes.service, {
    provider: {
        for: lib.service   //> to get a service provider
    },
    client: {
        for: lib.for          //> to get a service client
    },
    adapter: {
        for: lib.to            //> to get a service adaptor
    },
    for: lib.service,       //> shortcut for cds.service.provider.for
    impl: fn=>fn,          //> dummy to assist vscode IntelliSense
    impl4,
    path4,
    providers: [],
})


if (cds.env.features.localized) {
    const exports = module.exports, _for = exports.for
    const {serve} = require('../alpha/_localized')
    exports.for = (...args) => serve (_for (...args))
}


const path = require('path')

/**
 * Resolve a service implementation function as follows...
 * 1. if _impl is a function --> got it
 * 2. if _impl is a string --> `require (it)` (using model source if available)
 * 3. if def is annotated with @impl --> `require (def[@impl])`
 * 4. if we got the model's source --> `require (<basename>.js)`
 */
function impl4 (def, _impl = def['@impl']) {
    const _source = def['@source'] || def._location && def._location.filename
    const dir = _source && fs.isdir(path.dirname(_source)) ? path.dirname(_source) : process.cwd()

    if (typeof _impl === 'function')  return found (_impl)
    if (_impl)  return load (_impl)
    if (_source) {
        const impl = path.parse(_source).name + '.js'
        return load(impl) || load('js/'+impl) || load('handlers/'+impl)
    }

    function found (impl, _source = impl.name || '<inline>') {
        return Object.defineProperty (impl, '_source', {value:_source})
    }
    function load (file) {
        try {
            return found (require (path.resolve(dir,file)), file)
        } catch (e) {
            if (_impl || e.code !== 'MODULE_NOT_FOUND') throw e
        }
    }
}

/**
 * Resolve a service endpoint path to mount it to as follows...
 * Use _path or def[@path] if given with leading '/' prepended if necessary.
 * Otherwise, use the service definition name with stripped 'Service'
 */
function path4 (def, _path = def['@path']) {
  if (_path)  return _path.replace(/^[^/]/, c => '/'+c)
  else  return '/' + ( // generate one from the service's name
    /[^.]+$/.exec(def.name)[0]  //> my.very.CatalogService --> CatalogService
    .replace(/Service$/, '')        //> CatalogService --> Catalog
    .replace(/^[A-Z]/, c => c.toLowerCase())  //> Catalog --> catalog
    .replace(/[A-Z]/g, c => '-'+c.toLowerCase())  //> FooBar --> foo-bar
  )
}
