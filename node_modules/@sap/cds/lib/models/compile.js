const cdsv = require('./cdsv')
const cds = require('../index')
const $ = Object.assign
const YAML = { stringify: (...args) => (YAML.stringify = require('./2yaml'))(...args) }

const compile = (csn) => ({
  for:(x,o) => _fluent (compile_for,x, csn,o),
  to:(x,o) => _fluent (compile_to,x, csn,o),
})

// Fluent API, i.e. compile(csn).to('yml') --> see also: https://bit.ly/capire/APIs#cds-compile)
function _fluent (compile_, to_or_for, csn, o) {
    let fn = compile_[to_or_for];  if (!fn)  throw new TypeError (`cds.compile.for.${to_or_for} is not defined`)
    if (typeof csn === 'string')  csn = cds.parse (csn)
    return fn (csn,o)
}

// Dedicated API, i.e. compile.for.odata(csn)
const compile_for = {
  odata: (csn,o) => { // we cache because cds-services calls us for every single service in a model
    const cached = csn._4odata; if (cached) return cached
    const csn4 = cdsv.forOData (csn,o);  /* cache it: */ Object.defineProperty (csn, '_4odata', {value: csn4})
    return $(csn4, { '@sql_mapping': o && o.sql_mapping || cds.env.sql_mapping })
  },
  sql: (csn,o) => cdsv.forSql (csn,o),
}

// Dedicated API, i.e. compile.to.yml('csn')
const compile_to = {
  yaml: YAML.stringify, yml: YAML.stringify,
  json: x => JSON.stringify(x,null,2),
  edmx: (csn,o) => _2edm (csn,o, {off: 'metadata', only: 'annotations'}[o && o.annos]),
  edm: (csn,o) => _2edm (csn,o, 'metadata_json'),
  annos: (csn,o) => _2edm (csn,o, 'annotations'),
  swgr: (csn,o) => _2many  (cdsv.toSwagger(csn,o).services, '.swgr.json'),
  cdl: (csn,o) => _2many (cdsv.toCdl(csn,o),'.cds'),
  sql: (csn,o) => _2sql (_unfold_localized (_sql (cdsv.toSql (_skipUnused(csn),o)), csn), o),
  hana: (csn,o) => _2many (cdsv.toHana(_skipUnused(csn),o).hdbcds, '.hdbcds'),
  xsuaa: (csn,o) => require('./xsuaa').xsuaaConfig (csn,o)
}

// alpha fixes for gaps in localized data
const _unfold_localized = cds.env.features.localized
  ? require ('../alpha/_localized').unfold
  : x=>x

/** Skip unused entities marked with @cds.persistence.skip:'if-unused' */
function _skipUnused (csn) {

  const m = cds.linked (csn)
  // for each entity e1 marked with @cds.persistence.skip:'if-unused'...
  m.foreach (e => !e.abstract && e['@cds.persistence.skip']=='if-unused' && !localized_(e.name), e1 => {
    // fetch other entities e2 that contain Associations refering to e1 ...
    let refs=0;  m.foreach (cds.entity, e2 => {
      (e2 !== e1) && m.forall (cds.Association, a => a._target === e1 && ++refs, e2.elements)
    })
    if (!refs) skip (e1.name)
  })

  function localized_(entry) {
    return /(^|\.)localized_/.test(entry)
  }
  function skip (entry) {
    if (csn.definitions [entry]) {
      delete csn.definitions [entry]
      if (csn._xsn)  delete csn._xsn.definitions [entry]
      if (!/_txts$/.test(entry))  skip (entry+'_txts')
      if (!localized_(entry))  skip (entry.replace(/(\w*)$/,'localized_$1'))
    }
  }

  return csn
}

/** Return output of 2hana as an iterable */
function* _2many (result, suffix='.hdbcds') {
  for (let each in result) yield [result[each], // content
    { name: each.replace(/[.:/\\]/g, '_'), suffix }
  ]
}

// TODO: remove that from cdsc
function _sql ({sql}) {
  const all=[]
  for (let e in sql)  all.push (sql[e].replace(/-- generated by.*\n/,'').replace(/;$/, ''))
  return all
}

/** Return output of 2sql as array of ddl statements or a concatenated string of which */
function _2sql (all, _o) {
  if (_o && _o.as === 'str') return '\n'+ all.join(';\n\n') +';\n'
  else return all
}

/** Return output of 2edm/x as a single json object or edmx string or as an iterable for all of which */
function _2edm (csn, o={}, what='combined') { // NOSONAR

  if (what === 'combined')  o.combined = true;  else o.separate = true
  if (what === 'metadata_json')  o.json = true;  else o.xml = true
  if (!o.version)  o.version = o.json ? 'v4' : cds.env.odata.version

  const {services} = cdsv.toOdata(csn,o) || {}
  const chosen = o.service

  if (!services)  {
    throw new Error('No service definitions found')
  } else if (chosen === 'all') { //> all services
    const all = function*(){ for (let s in services)  yield [ _result(s), {name:s} ] }
    return all()
  } else if (chosen) { //> a specific service
    const one = Object.keys(services).find (n => n.indexOf(chosen) >= 0)
    return one ? _result(one) : _not_found (chosen)
  } else { //> a single service
    const [one,many] = Object.keys(services)
    return many ? _choose_one_of(services) : _result(one)
  }

  function _result (name) {
    const x = services[name][what]
    return o.as === 'str' && typeof x !== 'string' ? JSON.stringify(x) : x
  }
  function _choose_one_of (all) {
    throw new Error (`[cds] - multiple service definitions found in model; add one of...\n
    -s all ${Object.keys(all).map (each => `\n    -s ${each}`).join('')} \n`)
  }
  function _not_found (name) {
    throw new Error (`[cds] - no service definition matching '${name}' found among...
    ${Object.keys(services).map (each => `\n   ${each}`).join('')} \n`)
  }

}


module.exports = Object.assign (compile, { to: compile_to, for: compile_for })
