const cds = require('../index')
const {default_language} = cds.env.i18n || 'en'
const _4sqlite = ['de','fr']


///////////////////////////////////////////////////////////
//   cds-compiler part
//

// Rewrites DDL output of 2sql
const unfold = function _unfold_localized_entities_in (ddl, csn) { // NOSONAR
    csn = cds.compile.for.sql (csn)
    const m = cds.linked (csn)
    const services = RegExp (Object.keys (m.services).map(n => '^'+n+'\\.').join('|'))
    for (let each of m.each('entity')) {
        if (_has_localized_elements (each)) {
            if (each.own('abstract'))  continue
            if (each.query || each.source) {
                const sql_name = `${each.name.replace(/\./g,'_')}`
                const cv = `CREATE VIEW ${sql_name}`
                const k = ddl.findIndex (x => x.startsWith(cv))
                if (k<0)  continue
                const sql = ddl[k]
                if (each.name.includes('localized_')) {
                    // localized_Books > Books_localized
                    const entity = sql_name.replace('localized_','')
                    ddl[k] = sql
                        .replace (sql_name, `${entity}_localized`)
                        .replace (/\.locale = 'EN'/, `.locale = '${default_language}'`)
                    for (let each of _4sqlite) ddl.push (sql
                        .replace (sql_name, `${entity}_localized_${each}`)
                        .replace (/\.locale = 'EN'/, `.locale = '${each}'`)
                    )
                }
                else {
                    const inService = services.test (each.name)
                    // Service.Books > + localized_Service.Books
                    ddl.push (sql
                        .replace (sql_name, inService ? `localized_${sql_name}` : `${sql_name}_localized`)
                        .replace (/FROM (\w+) AS/, 'FROM $1_localized AS')
                    )
                    for (let each of _4sqlite) ddl.push (sql
                        .replace (sql_name, inService ? `localized_${each}_${sql_name}` : `${sql_name}_localized_${each}`)
                        .replace (/FROM (\w+) AS/, `FROM $1_localized_${each} AS`)
                    )
                }
            }
        }
    }
    return ddl
}




///////////////////////////////////////////////////////////
//   cds.services part
//

const serve = function _serve_localized_entities_in (srv) {
    const entities = srv.entities
    for (let each in entities) {
        if (_has_localized_elements (entities [each]))  _serve_localized (srv,each)
    }
    return srv
}


// Decorator for cds.service.for(...)
function _serve_localized (srv, entity) {
    _add_placebos4 (srv,entity)
    srv.on ('READ', entity, req => {
        const locale = req.user.locale
        const localized_ = `localized_${_4sqlite.includes(locale) ? `${locale}_` : ''}`
        const {SELECT} = req.query, {ref} = SELECT.from
        if (!ref[0].startsWith(localized_))  ref[0] = localized_+ref[0]
        //> we check that to avoid interfering with other/prior redirects
    })
}

function _add_placebos4 (srv,entity) {
    // kÃ¶nnen wir abschalten wenn cdsc das macht
    const d = srv.entities [entity]
    srv.model.definitions [`localized_${d.name}`] = d
    for (let each of _4sqlite)
        srv.model.definitions [`localized_${each}_${d.name}`] = d
}



///////////////////////////////////////////////////////////
//   shared
//

function _has_localized_elements (d) {
    return d.elements && d.elements.localized
    // for (let any in d.elements) {
    //     if (d.elements[any].localized)  return true
    // }
}


if (cds.env.features.localized) {
    module.exports = { unfold, serve }
} else {
    module.exports = { unfold: x=>x, serve: x=>x }
}
