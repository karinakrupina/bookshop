import { ParsedModel, Definitions, Definition } from "./specs/CSN"
import { ParsedQuery } from "./specs/CQN"
import { ReflectedModel, reflected } from './reflect'
import { SELECT, INSERT, UPDATE, DELETE } from './ql'
import cds from './cds'

export const connect : {

	/**
	 * Connects to the specified datasource.
```
const db = await cds.connect.to('db')
```
	 */
	to (datasource?: string, options?: _options) : Service & Promise<Service>

	/**
	 * Connects the primary datasource.
	 * The following are equivalent with the only difference of cds.connect()
	 * always returning cds itself, which acts as a proxy to the primary datasource:
```
const cds = await cds.connect()
const db = await cds.connect.to('db')
```
	 */
	(options?: string | _options) : typeof cds  //> cds.connect(<options>)
}

type _options = {
	kind?:string,
	model?:string,
	uri?:string,
	credentials: {
		database?:string,
	},
}

export type Service = Database | LocalService | RemoteService

export interface ServiceClient extends Transaction {
	model: ReflectedModel
	entities: typeof reflected.entities
	transaction (context) : Transaction
}

export interface Transaction {
	read (entity : Definition | string) : SELECT
	insert (entity : Definition | string) : INSERT
	update (entity : Definition | string) : UPDATE
	delete (entity : Definition | string) : DELETE
	run (uow : (tx:Transaction) => void) : Promise<ResultSet[]>
	run (query : ParsedQuery) : Promise<ResultSet>
	foreach (query : ParsedQuery, callback) : this
}

export interface Database extends ServiceClient {
	deploy (model?: ParsedModel | string) : Promise<ParsedModel>
	begin() : Promise<void>
	commit() : Promise<void>
	rollback() : Promise<void>
	disconnect() : Promise<void>
}

export interface LocalService extends ServiceClient  {}
export interface RemoteService extends ServiceClient  {}

export type ResultSet = {}[]