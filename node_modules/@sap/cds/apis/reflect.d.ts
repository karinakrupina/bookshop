import { ParsedModel, Definitions, Definition, Association, entity, kind } from "./specs/CSN"

export function linked (model : ParsedModel) : ReflectedModel
export function reflect (model : ParsedModel) : ReflectedModel
export function reflect (def : ParsedDefinition) : ReflectedDefinition | ReflectedEntity | ReflectedAssociation
export function clone (m) : ParsedModel

type ParsedDefinition = Definition
type ReflectedDefinitions = { [name:string]: ReflectedDefinition }
type Visitor = (d:ReflectedDefinition, parents?:ReflectedDefinition[]) => Definition | void | 'skip'
type Filter = string | ((def) => boolean)


/**
 * Applying cds.reflect in a model ensures that all contained definitions have their `name` and `kind` filled in.
 */
interface ReflectedDefinition {
	is (kind: kind | 'Association' | 'Composition') : boolean
    name : string
}

interface ReflectedAssociation extends ReflectedDefinition, Association {
	is2one : boolean
    is2many : boolean
}

interface ReflectedEntity extends ReflectedDefinition, entity {
	keys : Definitions
}


export interface ReflectedModel extends ParsedModel {

	/**
     * Fetches definitions matching the given filter, returning an iterator on them.
	 * @example
	 * 		let m = cds.reflect (aParsedModel)
	 *      for (let d of m.each('entity'))  console.log (d.kind, d.name)
	 *      let entities = [...m.each('entity')]  //> capture all
	 *      let entities = m.all('entity')          //> equivalent shortct
	 */
	each (x:Filter, defs: Definitions) : IterableIterator<Definition>

	/**
     * Fetches definitions matching the given filter, returning them in an array.
	 * Convenience shortcut for `[...reflect.each('entity')]`
     */
	all (x:Filter, defs: Definitions) : Definitions[]

	/**
     * Fetches definitions matching the given filter, returning the first match, if any.
	 * @example
	 *      let service = model.find('service')
	 * @param {Filter} [x]  the filter
	 * @param {Definitions} [defs]  the definitions to fetch in, default: `this.definitions`
	 */
	find (x:Filter, defs: Definitions) : Definition

	/**
     * Calls the visitor for each definition matching the given filter.
	 * @see find for details on the filter argument
	 */
	foreach (x:Filter, visitor:Visitor, defs: Definitions) : this

	/**
     * Same as foreach but recusively visits each element definition
	 * @see find for details on the filter argument
	 */
	forall (x:Filter, visitor:Visitor, defs: Definitions) : this

    /**
     * Fetches definitions declared as children of a given parent context or service.
	 * It fetches all definitions whose fully-qualified names start with the parent's name.
	 * Returns the found definitions as an object with the local names as keys.
	 * @example
	 *      let service = model.find ('service')
	 *      let entities = m.childrenOf (service)
	 * @param parent  either the parent itself or its fully-qualified name
	 * @param filter  an optional filter to apply before picking a child
	 */
	childrenOf (parent:Definition|string, filter?) : Definitions

	/**
     * Provides convenient access to the model's top-level definitions.
	 * For example, you can use it in an es6-import-like fashion to avoid
	 * working with fully-qualified names as follows:
	 *
	 * @example
	 * let model = cds.reflect (cds.parse(`
	 *     namespace our.lovely.bookshop;
	 *     entity Books {...}
	 *     entity Authors {...}
	 * `))
	 * const {Books,Authors} = model.exports
	 * SELECT.from (Books) .where ({ID:11})
	 */
	exports : ReflectedDefinitions
	entities : typeof reflected.entities
	services : typeof reflected.services

}

export const reflected : {
	entities : ReflectedDefinitions & ((namespace: string) => ReflectedDefinitions)
	services : ReflectedDefinitions & ((namespace: string) => ReflectedDefinitions)
}
