'use strict';

const JsonContentTypeInfo = require('../format/JsonContentTypeInfo');
const validateThat = require('../validator/ParameterValidator').validateThat;
const ValueConverter = require('../utils/ValueConverter');
const ValueValidator = require('../validator/ValueValidator');
const EdmTypeKind = require('../edm/EdmType').TypeKind;
const IllegalArgumentError = require('../errors/IllegalArgumentError');

/**
 * Serializer for geo data to Well-Known Text format.
 */
class ValueTextSerializer {
    constructor() {
        // The result is a string, so the parameter to format according to IEEE754 can be set unconditionally.
        // This is needed, e.g., for large Int64 values.
        this._valueConverter = new ValueConverter(new ValueValidator(),
            new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
    }

    /**
     * Serializes property or return type to a string in plain text format.
     * @param {EdmProperty|EdmReturnType|EdmTerm} propertyOrReturnType EDM property or EDM return type
     * @param {?Object} data the value
     * @returns {string} serialized representation in plain text format
     */
    serialize(propertyOrReturnType, data) {
        validateThat('propertyOrReturnType', propertyOrReturnType).truthy().instanceOf(Object);
        validateThat('data', data).truthy();

        let type = propertyOrReturnType.getType();
        if (type.getKind() === EdmTypeKind.DEFINITION) type = type.getUnderlyingType();

        if (type.getName().startsWith('Geo')) {
            validateThat('data.value', data.value).truthy().typeOf('object');
            try {
                this._valueConverter.convert(propertyOrReturnType, data.value);  // to check input
            } catch (error) {
                throw new IllegalArgumentError('Invalid geo data', error);
            }

            return 'SRID=' + this._determineSrid(propertyOrReturnType) + ';'
                + (data.value.type === 'GeometryCollection' ? 'Collection' : data.value.type)
                + '(' + this._serializeData(data.value.type, data.value) + ')';
        }

        return String(this._valueConverter.convert(propertyOrReturnType, data.value));
    }

    /**
     * Returns value of the SRID facet or the default value (4326 for geography, 0 for geometry).
     * If the specified type is a TypeDefinition, then take also the type definition's facet into account.
     *
     * @param {(EdmProperty|EdmTerm|EdmReturnType)} propertyOrReturnType object containing SRID facet
     * @returns {?(number|string)} value of SRID facet
     * @private
     */
    _determineSrid(propertyOrReturnType) {
        let srid = propertyOrReturnType.getSrid();
        let type = propertyOrReturnType.getType();
        if (srid === null && type.getKind() === EdmTypeKind.DEFINITION) {
            srid = type.getSrid();
            type = type.getUnderlyingType();
        }
        if (srid === 'variable') throw new IllegalArgumentError('Variable coordinate systems are not supported.');
        if (srid === null) srid = type.getName().startsWith('Geography') ? 4326 : 0;
        return srid;
    }

    /**
     * Serializes data for a geo type in "Well-Known Text" (WKT) format.
     * @param {string} typeName GeoJSON name of the geo type
     * @param {Array} data the data
     * @returns {string} serialized representation in WKT format
     * @private
     */
    _serializeData(typeName, data) {
        switch (typeName) {
            case 'Point':
                return data.coordinates.join(' ');

            case 'LineString':
                return data.coordinates.map(point => point.join(' ')).join(',');

            case 'Polygon':
                return data.coordinates.map(ring => '(' + ring.map(point => point.join(' ')) + ')').join(',');

            case 'MultiPoint':
                return data.coordinates.map(point => '(' + point.join(' ') + ')').join(',');

            case 'MultiLineString':
                return data.coordinates.map(linestring => '(' + linestring.map(point => point.join(' ')) + ')')
                    .join(',');

            case 'MultiPolygon':
                return data.coordinates.map(polygon => '('
                    + polygon.map(ring => '(' + ring.map(point => point.join(' ')) + ')').join(',') + ')').join(',');

            case 'GeometryCollection':
                return data.geometries.map(geoObject =>
                    geoObject.type + '(' + this._serializeData(geoObject.type, geoObject) + ')')
                    .join(',');

            default:
                throw new IllegalArgumentError('Unknown geo type ' + typeName);
        }
    }
}

module.exports = ValueTextSerializer;
