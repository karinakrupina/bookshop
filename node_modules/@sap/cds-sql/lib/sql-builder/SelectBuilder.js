const BaseBuilder = require('./BaseBuilder')

/**
 * SelectBuilder is used to take a CQN object as an input and to build a SQL Select string from it.
 *
 * Currently not supported are:
 * - "cast" in "column_expr"
 * - "mixin"
 * - "excluding"
 *
 *  @example <caption>Definition of CQN </caption>
 * {
 *  SELECT = {SELECT:{
 *  distinct: true,
 *  from: source | join,
 *  columns: projection,
 *  where: _xpr,   groupBy: [ ...expr ],
 *  having: _xpr,  orderBy: [ ...ordering_term ],
 *  limit: { rows:expr, offset:expr }
 *  }}
 * }
 *
 * source         =  ( ref | SELECT ) + { as:string }
 * join           =  { join:string, sources:[...source], on:_xpr }
 * projection     =  [ ...column_expr ]
 * column_expr    =  expr + { as:string }
 * ordering_term  =  expr + { sort: 'asc'|'desc' }
 */
class SelectBuilder extends BaseBuilder {
  get ExpressionBuilder () {
    const ExpressionBuilder = require('./ExpressionBuilder')
    Object.defineProperty(this, 'ExpressionBuilder', { value: ExpressionBuilder })
    return ExpressionBuilder
  }

  get ReferenceBuilder () {
    const ReferenceBuilder = require('./ReferenceBuilder')
    Object.defineProperty(this, 'ReferenceBuilder', { value: ReferenceBuilder })
    return ReferenceBuilder
  }

  /**
   * Builds an Object based on the properties of the CQN object.
   * @example <caption>Example output</caption>
   * {
   *   sql: 'SELECT "a", "b", "c" FROM "T" HAVING "x" < ? ',
   *   values: [9]
   * }
   *
   * @returns {{sql: string, values: Array}} Object with two properties.
   * SQL string for prepared statement and array of values to replace the placeholders.
   */
  build () {
    this._outputObj = {
      sql: ['SELECT'],
      values: []
    }

    if (this._obj.SELECT.distinct) {
      this._distinct()
    }

    this._columns()
    this._from()

    if (this._obj.SELECT.hasOwnProperty('where')) {
      this._where()
    }
    if (this._obj.SELECT.hasOwnProperty('groupBy')) {
      this._groupBy()
    }
    if (this._obj.SELECT.hasOwnProperty('having')) {
      this._having()
    }
    if (this._obj.SELECT.hasOwnProperty('orderBy')) {
      this._orderBy()
    }
    if (this._obj.SELECT.hasOwnProperty('limit')) {
      this._limit()
    }

    this._outputObj.sql = this._outputObj.sql.join(' ')

    return this._outputObj
  }

  _distinct () {
    this._outputObj.sql.push('DISTINCT')
  }

  _from () {
    this._outputObj.sql.push('FROM')

    if (this._obj.SELECT.from.hasOwnProperty('join')) {
      return this._fromJoin(this._obj.SELECT.from)
    }

    if (this._obj.SELECT.from.hasOwnProperty('SET')) {
      return this._fromUnion(this._obj.SELECT)
    }

    this._fromElement(this._obj.SELECT.from)
  }

  _fromJoin (from) {
    for (let i = 0, len = from.args.length; i < len; i++) {
      if (from.args[i].args) {
        // nested joins
        this._fromJoin(from.args[i])
        // Sub select with Union
      } else if (from.args[i].SELECT && from.args[i].SELECT.from.SET) {
        this._fromUnion(from.args[i].SELECT)
      } else {
        this._fromElement(from.args[i], from, i)
      }
    }
  }

  _fromUnion ({ from: { SET: set, as: fromAs }, as }) {
    const selects = []
    const concat = set.all ? ' UNION ALL ' : ' UNION '

    for (const select of set.args) {
      const { sql, values } = new SelectBuilder(select, this._options, this._csn).build()

      selects.push(sql)
      this._outputObj.values.push(...values)
    }

    this._outputObj.sql.push('(', selects.join(concat), ')')

    if (fromAs || as) {
      this._outputObj.sql.push('AS', this._quoteElement(fromAs || as))
    }
  }

  _fromElement (element, parent, i = 0) {
    let res

    if (element.ref) {
      // ref
      res = new this.ReferenceBuilder(element, this._options, this._csn).build()
    } else {
      // select
      res = new SelectBuilder(element, this._options, this._csn).build()
      res.sql = `(${res.sql})`
    }

    if (element.as) {
      // identifier
      res.sql += ` ${this._quoteElement(element.as)}`
    }

    this._outputObj.values.push(...res.values)

    if (i === 0) {
      // first element
      this._outputObj.sql.push(res.sql)
    } else {
      // join
      this._outputObj.sql.push(parent.join.toUpperCase(), 'JOIN', res.sql)

      if (parent.on) {
        const { sql, values } = new this.ExpressionBuilder(parent.on, this._options, this._csn).build()

        this._outputObj.sql.push('ON', sql)
        this._outputObj.values.push(...values)
      }
    }
  }

  _buildElement (col) {
    let res = {}

    if (col.ref) {
      // ref
      res = new this.ReferenceBuilder(col, this._options, this._csn).build()
    } else if (col.xpr) {
      // xpr
      res = new this.ExpressionBuilder(col, Object.assign({ objectKey: 'xpr' }, this._options), this._csn).build()
    } else if (col.hasOwnProperty('SELECT')) {
      // SELECT
      res = new SelectBuilder(col, this._options, this._csn).build()
      res.sql = `( ${res.sql} )`
    } else {
      // val
      res.sql = this._val(col)
      res.values = []
    }

    if (col.as) {
      // as
      res.sql += ` AS ${this._quoteElement(col.as)}`
    }

    this._outputObj.values.push(...res.values)
    return res.sql
  }

  _columns () {
    const columns = this._obj.SELECT.columns
    if (Array.isArray(columns) && columns.length !== 0 && columns[0] !== '*') {
      this._outputObj.sql.push(columns.map(col => this._buildElement(col)).join(', '))
    } else {
      this._outputObj.sql.push('*')
    }
  }

  _where () {
    const where = new this.ExpressionBuilder(this._obj.SELECT.where, this._options, this._csn).build()
    this._outputObj.sql.push('WHERE', where.sql)
    this._outputObj.values.push(...where.values)
  }

  _groupBy () {
    const sqls = []
    this._outputObj.sql.push('GROUP BY')
    for (const element of this._obj.SELECT.groupBy) {
      const res = new this.ReferenceBuilder(element, this._options, this._csn).build()
      sqls.push(res.sql)
      this._outputObj.values.push(...res.values)
    }
    this._outputObj.sql.push(sqls.join(', '))
  }

  _having () {
    const having = new this.ExpressionBuilder(this._obj.SELECT.having, this._options, this._csn).build()
    this._outputObj.sql.push('HAVING', having.sql)
    this._outputObj.values.push(...having.values)
  }

  _orderBy () {
    const sqls = []
    this._outputObj.sql.push('ORDER BY')
    for (const element of this._obj.SELECT.orderBy) {
      const { sql, values } = new this.ReferenceBuilder(element, this._options, this._csn).build()
      sqls.push(sql)
      this._outputObj.values.push(...values)
    }
    this._outputObj.sql.push(sqls.join(', '))
  }

  _limit () {
    this._outputObj.sql.push('LIMIT', this._obj.SELECT.limit.rows.val)
    if (this._obj.SELECT.limit.offset) {
      this._outputObj.sql.push('OFFSET', this._obj.SELECT.limit.offset.val)
    }
  }

  _val (obj) {
    return obj.val
  }
}

module.exports = SelectBuilder
