// OLD CSN
const _getElementName = (entity, string) => {
  const parts = string.split('.').reverse()
  const elementName = []

  for (const part of parts) {
    elementName.unshift(part)

    const name = elementName.join('.')

    if (entity.elements[name]) {
      return name
    }
  }
}

const _toRef = (associationName, alias, columnName) => {
  if (columnName.startsWith(`${associationName}.`)) {
    columnName = columnName.replace(new RegExp(`^${associationName}\\.`), '')
  }

  return { ref: alias ? [alias, columnName] : [columnName] }
}

const _selfToOn = (csn, csnElement, op, target, selectAlias, joinAlias) => {
  const targetName =
    csnElement.type === 'cds.Composition'
      ? _getElementName(csn.definitions[csnElement.target], target)
      : target.replace(`${csnElement.name}.`, '')

  return getOnCondOldCsn(
    csn.definitions[csnElement.target].elements[targetName],
    targetName,
    csn,
    selectAlias,
    joinAlias
  )
}

const _toOn = (one, two, op, csn, csnElement, associationName, selectAlias, joinAlias) => {
  if (one === '$self' || two === '$self') {
    return _selfToOn(csn, csnElement, op, one === '$self' ? two : one, joinAlias, selectAlias)
  }

  return [
    _toRef(associationName, two.startsWith(`${associationName}.`) ? joinAlias : selectAlias, one),
    op,
    _toRef(associationName, two.startsWith(`${associationName}.`) ? selectAlias : joinAlias, two)
  ]
}

const _args = (csn, csnElement, associationName, { args, op }, selectAlias, joinAlias) => {
  const on = []
  const length = args.length

  let i = 0

  while (i < length) {
    if (on.length !== 0) {
      on.push(op)
    }

    if (args[i].op) {
      on.push(..._args(csn, csnElement, associationName, args[i], selectAlias, joinAlias))
      i++
    } else {
      on.push(..._toOn(args[i]['='], args[i + 1]['='], op, csn, csnElement, associationName, selectAlias, joinAlias))
      i = i + 2
    }
  }

  return on
}

const _foreignToOn = (csnElement, associationName, selectAlias, joinAlias) => {
  const on = []

  for (const key of Object.keys(csnElement.foreignKeys)) {
    if (on.length !== 0) {
      on.push('and')
    }

    on.push(
      _toRef(associationName, selectAlias, csnElement.foreignKeys[key].path),
      '=',
      _toRef(associationName, joinAlias, `${associationName}_${csnElement.foreignKeys[key].path}`)
    )
  }

  return on
}

/**
 * Get the ON conditions in CQN format based on the CSN.
 * @param {Object} csnElement
 * @param {String} associationName
 * @param {Object} csn
 * @param {string} selectAlias
 * @param {string} joinAlias
 * @returns {Array}
 * @private
 */
const getOnCondOldCsn = (csnElement, associationName, csn, selectAlias, joinAlias) => {
  if (csnElement.foreignKeys) {
    return _foreignToOn(csnElement, associationName, selectAlias, joinAlias)
  }

  return _args(csn, csnElement, associationName, csnElement.onCond, selectAlias, joinAlias)
}

module.exports = {
  getOnCondOldCsn
}
