const DRAFT_SUFFIX = '_drafts'

const isRootEntity = (model, entityName) => {
  const entity = model[entityName]
  if (!entity) return false

  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(({ type }) => type === 'cds.Association')

  for (const { target } of associationElements) {
    const parentEntity = model[target]
    for (const parentElementName of Object.keys(parentEntity.elements)) {
      const parentElement = parentEntity.elements[parentElementName]
      if (parentElement.type === 'cds.Composition' && parentElement.target === entityName) {
        return false
      }
    }
  }

  return true
}

const getCompositionRoot = (model, entity) => {
  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(({ type }) => type === 'cds.Association')

  for (const { target } of associationElements) {
    const parentEntity = model[target]
    for (const parentElementName of Object.keys(parentEntity.elements)) {
      const parentElement = parentEntity.elements[parentElementName]
      if (parentElement.type === 'cds.Composition' && parentElement.target === entity.name) {
        return getCompositionRoot(model, parentEntity)
      }
    }
  }
  return entity
}

const _addAssociation = (element, compositionTree) => {
  if (element.foreignKeys) {
    // OLD CSN
    for (const foreignKey of Object.keys(element.foreignKeys)) {
      compositionTree.backLinks.push({
        name: `${element.name}_${foreignKey}`,
        target_element: element.foreignKeys[foreignKey].path || element.foreignKeys[foreignKey]
      })
    }
  } else if (element.keys) {
    for (const foreignKey of element.keys) {
      compositionTree.backLinks.push({
        name: `${element.name}_${foreignKey.ref[0]}`,
        target_element: foreignKey.ref[0]
      })
    }
  }
}

const _getCompositionTree = ({
  rootEntityName,
  model,
  compositionSet,
  compositionTree,
  entityName,
  parentEntityName
}) => {
  compositionSet.add(parentEntityName)
  compositionTree.source = parentEntityName
  if (parentEntityName !== rootEntityName) {
    compositionTree.target = entityName
  }
  compositionTree.compositionElements = []
  compositionTree.backLinks = []

  const parentEntity = model[parentEntityName]
  const elements = Object.keys(parentEntity.elements).map(key => parentEntity.elements[key])
  for (const element of elements) {
    if (element.type === 'cds.Composition' && rootEntityName !== element.target) {
      const subObject = { name: element.name }
      compositionTree.compositionElements.push(subObject)
      _getCompositionTree({
        rootEntityName,
        model,
        compositionSet,
        compositionTree: subObject,
        entityName: parentEntityName,
        parentEntityName: element.target
      })
    }
    if (
      element.type === 'cds.Association' &&
      element.target === compositionTree.target &&
      compositionSet.has(element.target)
    ) {
      _addAssociation(element, compositionTree)
    }
  }
}

/**
 * Provides tree of all compositions.
 * @param {Object} model Definitions of the reflected model
 * @param {String} rootEntityName Name of the root entity
 * @param {boolean} checkRoot Check is provided entity is a root
 */
const getCompositionTree = (model, rootEntityName, checkRoot = true) => {
  if (checkRoot && !isRootEntity(model, rootEntityName)) {
    throw new Error('Entity is not root entity')
  }
  const compositionTree = {}
  const compositionSet = new Set()
  _getCompositionTree({
    rootEntityName,
    model,
    compositionSet,
    compositionTree,
    entityName: rootEntityName,
    parentEntityName: rootEntityName
  })

  return compositionTree
}

const _stripDraftSuffix = (model, name) => {
  if (name.endsWith(DRAFT_SUFFIX)) {
    const strippedName = name.substr(0, name.length - DRAFT_SUFFIX.length)
    if (model && model[strippedName]) {
      return strippedName
    }
  }
  return name
}

const _addDraftSuffix = (draft, name) => {
  return draft ? `${name}${DRAFT_SUFFIX}` : name
}

const _dataElements = entity => {
  return Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(({ type }) => type !== 'cds.Association' && type !== 'cds.Composition')
}

const _cleanDeepData = (entity, data) => {
  if (!Array.isArray(data)) {
    return _cleanDeepData(entity, [data])[0]
  }
  return data.map(entry => {
    return Object.keys(entry || {}).reduce((result, k) => {
      if (!(entity && entity.elements && entity.elements[k] && entity.elements[k].type === 'cds.Composition')) {
        result[k] = entry[k]
      }
      return result
    }, {})
  })
}

const _key = (entity, data) => {
  return _dataElements(entity).reduce((result, element) => {
    if (element.key) {
      result[element.name] = data[element.name]
    }
    return result
  }, {})
}

const _keys = (entity, data) => {
  return data.map(entry => {
    return _key(entity, entry)
  })
}

const _parentKey = (element, key) => {
  return element.backLinks.reduce((parentKey, backlink) => {
    parentKey[backlink.name] = key[backlink.target_element]
    return parentKey
  }, {})
}

const _parentKeys = (element, keys) => {
  return keys.map(key => {
    return _parentKey(element, key)
  })
}

const _whereKey = key => {
  const where = []
  Object.keys(key).forEach(keyPart => {
    if (where.length > 0) {
      where.push('and')
    }
    where.push({ ref: [keyPart] }, '=', { val: key[keyPart] })
  })
  return where
}

const _whereKeys = keys => {
  const where = []
  keys.forEach(key => {
    if (where.length > 0) {
      where.push('or')
    }
    where.push('(', ..._whereKey(key), ')')
  })
  return where
}

const _isKeyEqual = (entity, key1, key2) => {
  return _dataElements(entity)
    .filter(({ key }) => key)
    .every(({ name }) => {
      return key1[name] === key2[name]
    })
}

const _isDataPartOf = (data, otherData) => {
  if (!Array.isArray(data)) {
    return _isDataPartOf([data], [otherData])
  }
  return data.every((entry, index) => {
    const otherEntry = otherData[index]
    return Object.keys(entry).every(key => {
      return entry[key] === (otherEntry && otherEntry[key])
    })
  })
}

const _findByKey = (entity, data, key) => {
  return (
    data.find(entry => {
      return _isKeyEqual(entity, _key(entity, entry), key)
    }) || null
  )
}

const _findWhere = (data, where) => {
  return data.filter(entry => {
    return Object.keys(where).every(key => {
      return where[key] === entry[key]
    })
  })
}

const _diffData = (entity, data, otherData) => {
  return Object.keys(data).reduce((result, key) => {
    const dataVal = (data[key] && data[key].val) || data[key]
    const otherDataVal = (otherData[key] && otherData[key].val) || otherData[key]
    if (dataVal !== undefined && dataVal !== otherDataVal) {
      result[key] = data[key]
    }
    return result
  }, {})
}

const _propagateKeys = (element, data, subData) => {
  return subData.map(subEntry => {
    return Object.assign(
      {},
      subEntry,
      element.backLinks.reduce((result, backlink) => {
        result[backlink.name] = data[backlink.target_element]
        return result
      }, {})
    )
  })
}

const hasCompositionDelete = (model, cqn) => {
  if (cqn && cqn.DELETE && cqn.DELETE.from) {
    const entityName = _stripDraftSuffix(model, cqn.DELETE.from.name || cqn.DELETE.from)
    const entity = model && model[entityName]
    return entity && !!Object.keys(entity.elements || {}).find(k => entity.elements[k].type === 'cds.Composition')
  }
  return false
}

const _addSubCascadeDeleteCQN = (compositionTree, level, cqns, draft) => {
  compositionTree.compositionElements.forEach(element => {
    const subWhere = element.backLinks.reduce((result, backLink) => {
      if (result.length > 0) {
        result.push('and')
      }
      result.push({ ref: [_addDraftSuffix(draft, element.source), backLink.name] }, '=', {
        ref: [_addDraftSuffix(draft, element.target), backLink.target_element]
      })
      return result
    }, [])
    const whereKey = element.backLinks.reduce((result, backLink) => {
      if (result.length > 0) {
        result.push('or')
      }
      result.push({ ref: [_addDraftSuffix(draft, element.source), backLink.name] }, 'is not null')
      return result
    }, [])
    const where = [
      '(',
      ...whereKey,
      ')',
      'and',
      'not exists',
      {
        SELECT: {
          columns: [{ val: 1, as: '_exists' }],
          from: { ref: [_addDraftSuffix(draft, element.target)] },
          where: subWhere
        }
      }
    ]
    const subCQN = { DELETE: { from: _addDraftSuffix(draft, element.source), where: where } }
    cqns[level] = cqns[level] || []
    cqns[level].push(subCQN)
    _addSubCascadeDeleteCQN(element, level + 1, cqns, draft)
  })
  return cqns
}

const createCascadeDeleteCQNs = (model, cqn) => {
  const from = cqn.DELETE.from.name || cqn.DELETE.from
  const entityName = _stripDraftSuffix(model, from)
  const draft = entityName !== from
  const compositionTree = getCompositionTree(model, entityName, false)
  return [[cqn], ..._addSubCascadeDeleteCQN(compositionTree, 0, [], draft)]
}

const _addSubReverseCascadeDeleteCQN = (compositionTree, level, cqn, cqns, draft) => {
  compositionTree.compositionElements.forEach(element => {
    const subWhere = [
      ...element.backLinks.reduce((result, backLink) => {
        if (result.length > 0) {
          result.push('and')
        }
        result.push({ ref: [_addDraftSuffix(draft, element.source), backLink.name] }, '=', {
          ref: [_addDraftSuffix(draft, element.target), backLink.target_element]
        })
        return result
      }, [])
    ]
    if (cqn.DELETE && cqn.DELETE.where && cqn.DELETE.where.length > 0) {
      subWhere.push('and', '(', ...(cqn.DELETE.where || []), ')')
    }
    const whereKey = element.backLinks.reduce((result, backLink) => {
      if (result.length > 0) {
        result.push('or')
      }
      result.push({ ref: [_addDraftSuffix(draft, element.source), backLink.name] }, 'is not null')
      return result
    }, [])
    const where = [
      '(',
      ...whereKey,
      ')',
      'and',
      'exists',
      {
        SELECT: {
          columns: [{ val: 1, as: '_exists' }],
          from: { ref: [_addDraftSuffix(draft, element.target)] },
          where: subWhere
        }
      }
    ]
    const subCQN = { DELETE: { from: _addDraftSuffix(draft, element.source), where: where } }
    cqns[level] = cqns[level] || []
    cqns[level].push(subCQN)
    _addSubReverseCascadeDeleteCQN(element, level + 1, subCQN, cqns, draft)
  })
  return cqns
}

const createReverseCascadeDeleteCQNs = (model, cqn) => {
  const from = cqn.DELETE.from.name || cqn.DELETE.from
  const entityName = _stripDraftSuffix(model, from)
  const draft = entityName !== from
  const compositionTree = getCompositionTree(model, entityName, false)
  return [[cqn], ..._addSubReverseCascadeDeleteCQN(compositionTree, 0, cqn, [], draft)].reverse()
}

const hasDeepInsert = (model, cqn) => {
  if (cqn && cqn.INSERT && cqn.INSERT.into && cqn.INSERT.entries) {
    const entityName = _stripDraftSuffix(model, cqn.INSERT.into.name || cqn.INSERT.into)
    const entity = model && model[entityName]
    if (entity) {
      return !!cqn.INSERT.entries.find(entry => {
        return !!Object.keys(entry || {}).find(k => {
          return entity.elements && entity.elements[k] && entity.elements[k].type === 'cds.Composition'
        })
      })
    }
  }
  return false
}

const _addSubDeepInsertCQN = (model, compositionTree, data, cqns, draft) => {
  compositionTree.compositionElements.forEach(element => {
    const subEntity = model[element.source]
    const into = _addDraftSuffix(draft, element.source)
    const insertCQN = {
      INSERT: {
        into: into,
        entries: []
      }
    }
    const subData = data.reduce((result, entry) => {
      if (element.name in entry) {
        const elementValue = entry[element.name].val || entry[element.name]
        const subData = Array.isArray(elementValue) ? elementValue : [elementValue]
        if (subData.length > 0) {
          insertCQN.INSERT.entries.push(..._cleanDeepData(subEntity, _propagateKeys(element, entry, subData)))
          result.push(...subData)
        }
      }
      return result
    }, [])
    if (insertCQN.INSERT.entries.length > 0) {
      cqns.push(insertCQN)
    }
    if (subData.length > 0) {
      _addSubDeepInsertCQN(model, element, subData, cqns, draft)
    }
  })
  return cqns
}

const createDeepInsertCQNs = (model, cqn) => {
  const into = cqn.INSERT.into.name || cqn.INSERT.into
  const entityName = _stripDraftSuffix(model, into)
  const draft = entityName !== into
  const data = cqn.INSERT.entries || []
  const entity = model && model[entityName]
  cqn.INSERT.entries = _cleanDeepData(entity, data)
  const compositionTree = getCompositionTree(model, entityName, false)
  return [cqn, ..._addSubDeepInsertCQN(model, compositionTree, data, [], draft)]
}

const hasDeepUpdate = (model, cqn) => {
  if (cqn && cqn.UPDATE && cqn.UPDATE.entity && cqn.UPDATE.data) {
    const entityName = _stripDraftSuffix(model, cqn.UPDATE.entity.name || cqn.UPDATE.entity)
    const entity = model && model[entityName]
    if (entity) {
      return !!Object.keys(cqn.UPDATE.data).find(k => {
        return entity.elements && entity.elements[k] && entity.elements[k].type === 'cds.Composition'
      })
    }
  }
  return false
}

function _selectDeepUpdateDataRecursion ({ model, compositionTree, entityName, data, result, draft, execute }) {
  const entity = model && model[entityName]
  const keys = _keys(entity, result)
  return Promise.all(
    compositionTree.compositionElements.map(element => {
      if (
        data !== undefined &&
        !data.find(entry => {
          return element.name in entry
        })
      ) {
        return Promise.resolve()
      }
      const subData =
        data &&
        data.reduce((result, entry) => {
          if (element.name in entry) {
            const elementValue = entry[element.name].val || entry[element.name]
            result.push(...(Array.isArray(elementValue) ? elementValue : [elementValue]))
          }
          return result
        }, [])
      return _selectDeepUpdateData({
        model,
        compositionTree: element,
        entityName: element.source,
        data: subData,
        selectData: result,
        parentKeys: _parentKeys(element, keys),
        draft,
        execute
      })
    })
  )
}

const _selectDeepUpdateDataResult = ({
  model,
  compositionTree,
  entityName,
  data,
  selectData,
  where,
  parentKeys,
  root,
  draft,
  result,
  execute
}) => {
  if (root) {
    selectData.push(...result)
  } else {
    selectData.forEach(selectEntry => {
      selectEntry[compositionTree.name] = selectEntry[compositionTree.name] || []
      selectEntry[compositionTree.name].push(..._findWhere(result, _parentKey(compositionTree, selectEntry)))
    })
  }
  if (result.length === 0) {
    return Promise.resolve()
  }
  return _selectDeepUpdateDataRecursion({ model, compositionTree, entityName, data, result, draft, execute })
}

const _selectDeepUpdateData = ({
  model,
  compositionTree,
  entityName,
  data,
  selectData,
  where,
  parentKeys,
  draft,
  execute
}) => {
  const root = !selectData
  const entity = model && model[entityName]
  const from = _addDraftSuffix(draft, entity.name)
  const selectCQN = {
    SELECT: {
      from: { ref: [from] }
    }
  }
  if (data !== undefined) {
    selectCQN.SELECT.columns = []
    const backLinkKeys = compositionTree.backLinks.map(backLink => backLink.name)
    _dataElements(entity).forEach(element => {
      if (element.key || backLinkKeys.includes(element.name)) {
        selectCQN.SELECT.columns.push({ ref: [element.name] })
      } else if (
        data.find(entry => {
          return element.name in entry
        })
      ) {
        selectCQN.SELECT.columns.push({ ref: [element.name] })
      }
    })
  }
  if (where) {
    selectCQN.SELECT.where = where
  } else if (parentKeys) {
    selectCQN.SELECT.where = _whereKeys(parentKeys)
  }
  selectData = selectData || []
  return Promise.resolve(execute(selectCQN))
    .then(result => {
      return _selectDeepUpdateDataResult({
        model,
        compositionTree,
        entityName,
        data,
        selectData,
        where,
        parentKeys,
        root,
        result,
        draft,
        execute
      })
    })
    .then(() => {
      return selectData
    })
}

const selectDeepData = (model, entity, data, execute) => {
  if (!Array.isArray(data)) {
    return selectDeepData(model, entity, [data], execute)
  }
  const from = entity.name || entity
  const entityName = _stripDraftSuffix(model, from)
  const modelEntity = model && model[entityName]
  const draft = entityName !== from
  const keys = _keys(modelEntity, data)
  const compositionTree = getCompositionTree(model, entityName, false)
  return _selectDeepUpdateData({
    model,
    compositionTree,
    entityName,
    data: !_isDataPartOf(data, keys) ? data : undefined,
    where: _whereKeys(keys),
    draft,
    execute
  })
}

const selectDeepUpdateData = (model, cqn, execute) => {
  const from = cqn.UPDATE.entity.name || cqn.UPDATE.entity
  const entityName = _stripDraftSuffix(model, from)
  const draft = entityName !== from
  const data = cqn.UPDATE.data || {}
  const where = cqn.UPDATE.where || []
  const compositionTree = getCompositionTree(model, entityName, false)
  return _selectDeepUpdateData({
    model,
    compositionTree,
    entityName,
    data: [data],
    where: where,
    draft,
    execute
  })
}

const _addDeepSelectColumns = (model, compositionTree, data, columns) => {
  const entity = model && model[compositionTree.source]
  _dataElements(entity).forEach(element => {
    if (element.key) {
      columns.push({ ref: [element.name] })
    }
  })
  data.forEach(entry => {
    Object.keys(entry).forEach(key => {
      if (!columns.find(column => column.ref[0] === key)) {
        columns.push({ ref: [key] })
      }
    })
  })
  compositionTree.compositionElements.forEach(element => {
    if (
      !data.find(entry => {
        return element.name in entry
      })
    ) {
      return
    }
    const subColumns = []
    const subData = data.reduce((result, entry) => {
      if (element.name in entry) {
        const elementValue = entry[element.name].val || entry[element.name]
        result.push(...(Array.isArray(elementValue) ? elementValue : [elementValue]))
      }
      return result
    }, [])
    const column = columns.find(column => column.ref[0] === element.name)
    column.expand = subColumns
    _addDeepSelectColumns(model, element, subData, subColumns)
  })
}

const createDeepUpdateSelectCQN = (model, cqn) => {
  const from = cqn.UPDATE.entity.name || cqn.UPDATE.entity
  const entityName = _stripDraftSuffix(model, from)
  const data = cqn.UPDATE.data || {}
  const columns = []
  const selectCQN = {
    SELECT: {
      columns,
      from: { ref: [from] }
    }
  }
  if (cqn.UPDATE.where) {
    selectCQN.SELECT.where = cqn.UPDATE.where
  }
  const compositionTree = getCompositionTree(model, entityName, false)
  _addDeepSelectColumns(model, compositionTree, [data], columns)
  return selectCQN
}

function _addSubDeepUpdateCQNForDelete ({ compositionTree, entity, entityName, data, selectData, deleteCQN }) {
  selectData.forEach(selectEntry => {
    const selectKey = _key(entity, selectEntry)
    const entry = _findByKey(entity, data, selectKey)
    if (!entry) {
      if (deleteCQN.DELETE.where.length > 0) {
        deleteCQN.DELETE.where.push('or')
      }
      deleteCQN.DELETE.where.push('(', ..._whereKey(selectKey), ')')
    }
  })
}

function _addSubDeepUpdateCQNForUpdateInsert ({
  compositionTree,
  entity,
  entityName,
  data,
  selectData,
  updateCQNs,
  insertCQN
}) {
  ;[...data].forEach(entry => {
    const key = _key(entity, entry)
    const selectEntry = _findByKey(entity, selectData, key)
    if (selectEntry) {
      const diff = _diffData(entity, _cleanDeepData(entity, entry), _cleanDeepData(entity, selectEntry))
      if (Object.keys(diff).length > 0) {
        updateCQNs.push({
          UPDATE: {
            entity: entityName,
            data: diff,
            where: _whereKey(key)
          }
        })
      }
    } else {
      insertCQN.INSERT.entries.push(entry)
      data.splice(data.indexOf(entry), 1)
    }
  })
}

function _addSubDeepUpdateCQNCollectDelete (deleteCQNs, cqns, index) {
  deleteCQNs.forEach(deleteCQN => {
    if (
      !cqns.find((subCQNs, subIndex) => {
        if (subIndex > 0) {
          const deleteIndex = subCQNs.findIndex(cqn => {
            return cqn.DELETE && cqn.DELETE.from === deleteCQN.DELETE.from
          })
          if (deleteIndex > -1) {
            if (subIndex < index) {
              subCQNs.splice(deleteIndex, 1)
            } else {
              return true
            }
          }
        }
        return false
      })
    ) {
      cqns[index] = cqns[index] || []
      cqns[index].push(deleteCQN)
    }
  })
}

function _addSubDeepUpdateCQNCollect (model, cqns, updateCQNs, insertCQN, deleteCQN) {
  if (updateCQNs.length > 0) {
    cqns[0] = cqns[0] || []
    cqns[0].push(...updateCQNs)
  }
  if (insertCQN.INSERT.entries.length > 0) {
    cqns[0] = cqns[0] || []
    createDeepInsertCQNs(model, insertCQN).forEach(insertCQN => {
      const intoCQN = cqns[0].find(cqn => {
        return cqn.INSERT && cqn.INSERT.into === insertCQN.INSERT.into
      })
      if (!intoCQN) {
        cqns[0].push(insertCQN)
      } else {
        intoCQN.INSERT.entries.push(...insertCQN.INSERT.entries)
      }
    })
  }
  if (deleteCQN.DELETE.where.length > 0) {
    cqns[0] = cqns[0] || []
    cqns[0].push(deleteCQN)
    createCascadeDeleteCQNs(model, deleteCQN).forEach((deleteCQNs, index) => {
      if (index > 0) {
        _addSubDeepUpdateCQNCollectDelete(deleteCQNs, cqns, index)
      }
    })
  }
}

function _addSubDeepUpdateCQNRecursion ({ model, compositionTree, entity, data, selectData, cqns, draft }) {
  compositionTree.compositionElements.forEach(element => {
    const subData = []
    const selectSubData = []
    data.forEach(entry => {
      if (element.name in entry) {
        const elementValue = entry[element.name].val || entry[element.name]
        subData.push(..._propagateKeys(element, entry, Array.isArray(elementValue) ? elementValue : [elementValue]))
        const selectEntry = _findByKey(entity, selectData, _key(entity, entry))
        if (selectEntry && element.name in selectEntry) {
          const selectElementValue = selectEntry[element.name].val || selectEntry[element.name]
          selectSubData.push(
            ..._propagateKeys(
              element,
              selectEntry,
              Array.isArray(selectElementValue) ? selectElementValue : [selectElementValue]
            )
          )
        }
      }
    })
    _addSubDeepUpdateCQN({
      model,
      compositionTree: element,
      data: subData,
      selectData: selectSubData,
      cqns,
      draft
    })
  })
  return cqns
}

const _addSubDeepUpdateCQN = ({ model, compositionTree, data, selectData, cqns, draft }) => {
  const entity = model && model[compositionTree.source]
  const entityName = _addDraftSuffix(draft, entity.name)
  const updateCQNs = []
  const insertCQN = {
    INSERT: {
      into: entityName,
      entries: []
    }
  }
  const deleteCQN = {
    DELETE: {
      from: entityName,
      where: []
    }
  }
  _addSubDeepUpdateCQNForDelete({ compositionTree, entity, entityName, data, selectData, deleteCQN })
  _addSubDeepUpdateCQNForUpdateInsert({
    compositionTree,
    entity,
    entityName,
    data,
    selectData,
    updateCQNs,
    insertCQN
  })
  _addSubDeepUpdateCQNCollect(model, cqns, updateCQNs, insertCQN, deleteCQN)
  if (data.length === 0) {
    return Promise.resolve()
  }
  return _addSubDeepUpdateCQNRecursion({
    model,
    compositionTree,
    entity,
    data,
    selectData,
    cqns,
    draft
  })
}

const createDeepUpdateCQNs = (model, cqn, selectData) => {
  if (!Array.isArray(selectData)) {
    return createDeepUpdateCQNs(model, cqn, [selectData])
  }
  if (selectData.length === 0) {
    return []
  }
  if (selectData.length > 1) {
    throw new Error('Deep update can only be performed on a single instance')
  }
  const cqns = []
  const from = cqn.UPDATE.entity.name || cqn.UPDATE.entity
  const entityName = _stripDraftSuffix(model, from)
  const draft = entityName !== from
  const data = cqn.UPDATE.data || {}
  const entity = model && model[entityName]
  const entry = Object.assign({}, data, _key(entity, selectData[0]))
  const compositionTree = getCompositionTree(model, entityName, false)
  const subCQNs = _addSubDeepUpdateCQN({
    model,
    compositionTree,
    data: [entry],
    selectData,
    cqns: [],
    draft
  })
  subCQNs.forEach((subCQNs, index) => {
    cqns[index] = cqns[index] || []
    cqns[index].push(...subCQNs)
  })
  return cqns
}

module.exports = {
  isRootEntity,
  getCompositionTree,
  getCompositionRoot,
  hasCompositionDelete,
  createCascadeDeleteCQNs,
  createReverseCascadeDeleteCQNs,
  hasDeepInsert,
  createDeepInsertCQNs,
  hasDeepUpdate,
  selectDeepData,
  selectDeepUpdateData,
  createDeepUpdateSelectCQN,
  createDeepUpdateCQNs
}
