const _isContains = ref => {
  return ref && /^(:?not )?contains$/.test(ref[0].toLowerCase())
}

const _getCQN = cqn => {
  if (cqn.SELECT) {
    return cqn.SELECT
  }
  if (cqn.UPDATE) {
    return cqn.UPDATE
  }

  return cqn.DELETE
}
/**
 * Check if the given CQN is of type select, update or delete and contains "contains" in where clause.
 * @param {Object} cqn
 * @returns {boolean}
 */
const hasContains = cqn => {
  const _partialCqn = _getCQN(cqn)

  return _partialCqn && _partialCqn.where ? _partialCqn.where.some(({ ref }) => _isContains(ref)) : false
}

const _createLikeComparison = (notContains, columns, searchText) => {
  const res = []
  for (let i = 0, length = columns.length; i < length; i++) {
    if (columns[i].ref) {
      res.push({ ref: ['lower', { args: [columns[i]] }] }, notContains ? 'not like' : 'like', {
        val: `%${searchText.replace(/(_|%)/g, '\\$1')}%`
      })
      if (columns[i + 1] && columns[i + 1].ref) {
        res.push(notContains ? 'and' : 'or')
      }
    }
  }

  return res
}

const _transformCQN = (notContains, args) => {
  const columns = args[0].xpr ? args[0].xpr : args[0].list
  const res = []

  for (let i = 1, length = args.length; i < length; i++) {
    if (args[i].val) {
      const previousElementIsNot = typeof args[i - 1] === 'string' && args[i - 1].toLowerCase() === 'not'
      res.push(
        '(',
        ..._createLikeComparison(previousElementIsNot ? !notContains : notContains, columns, args[i].val.toLowerCase()),
        ')'
      )
    } else if (args[i] === 'and' || args[i] === 'or') {
      res.push(args[i])
    }
  }

  return res
}

/**
 * Creates CQN(s) changing all contains into like statements
 * @param {Object} cqn - CQN with contains
 * @returns {Object} - CQN with like
 */
const replaceContainsWithLike = cqn => {
  const resCQN = {}
  const _partialCqn = _getCQN(cqn)

  // Link anything but where
  for (const key of Object.keys(_partialCqn)) {
    if (key !== 'where') {
      resCQN[key] = _partialCqn[key]
    }
  }

  // Create a different where array
  resCQN.where = _partialCqn.where.reduce(
    (res, curr) =>
      _isContains(curr.ref)
        ? [...res, '(', ..._transformCQN(curr.ref[0].toLowerCase().includes('not'), curr.ref[1].args), ')']
        : [...res, curr],
    []
  )

  return {
    [Object.keys(cqn)[0]]: resCQN
  }
}

module.exports = {
  replaceContainsWithLike,
  hasContains
}
