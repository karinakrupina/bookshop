const cds = require('../cds')
const { typeConversionMap } = require('../utils/dataTypes')
const { InconsistentClientError } = require('../errors')

/**
 * BaseClient is to be extended by any SQL client. It allows to convert db results according to the CSN.
 */
class BaseClient {
  /**
   * Creates a basic SQL Client
   * @param {Array|Map} toService - Definition of how to convert a value according to cds.DataType
   */
  constructor (toService = []) {
    this._toService = toService instanceof Map ? toService : new Map(toService)
    this._initializeDefaultDataTypeMap()
  }

  /**
   * Set the entities in reflected CSN format, relevant for the service the queries are run for.
   * @param csn
   */
  setCSN (csn) {
    this._csn = csn
  }

  /**
   * Default sql type conversion. Database specific data types need to be overwritten in db client impl.
   * @private
   */
  _initializeDefaultDataTypeMap () {
    this._typeConversionMap = typeConversionMap
  }

  /**
   * Returns validity of the client.
   *
   * @returns {boolean} true if client is still valid, false if not
   */
  isValid () {
    return !this._toBeDestroyed && this.isConnected()
  }

  /**
   * Runs simple SQL statements.
   * In contrast to .execute, it also takes care of executing the statement in a transactional block.
   *
   * @param {String|Object} query - SQL query as string or CQN object.
   * @param {Array} [values] - values for prepared stmt in case of SQL query string.
   * @returns {Promise} - resolves with result or rejects with error.
   */
  run (query, values) {
    // Client broke in a not reparable way before
    if (this._toBeDestroyed) {
      return Promise.reject(new InconsistentClientError())
    }

    // In case of run block the transaction mode is provided by the block pragmas.
    if (typeof query === 'function' && this._runBlock) {
      return this._addThenableToRun(this._runBlock(query))
    }

    // Execute in case of statements
    return this._addThenableToRun(this.execute(query, values))
  }

  /**
   * Processes a nested (two-level deep) array of CQN statements.
   * First array level is processed sequentially, second array level is processed in parallel
   * @param {Array.<Array>} cqns - Nested array of CQNs processed in the above described order
   * @param {Function} processFn - Process callback function for each CQN statement
   */
  processNestedCQNs (cqns, processFn) {
    return cqns.reduce((promise, cqns) => {
      return promise.then(changes => {
        return Promise.all(
          cqns.map(cqn => {
            return Promise.resolve(processFn(cqn)).then(result => {
              changes += isNaN(parseInt(result, 10)) ? 0 : result
            })
          })
        ).then(() => {
          return changes
        })
      })
    }, Promise.resolve(0))
  }

  _addThenableToRun (promise) {
    const then = (resolve, reject) => {
      return promise.then(resolve).catch(reject)
    }

    then.run = (...args) => {
      return promise.then(() => {
        return this.run(...args)
      })
    }

    return {
      then: then,
      catch: fn => {
        return promise.catch(fn)
      }
    }
  }

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion instead of
   * materializing the full set in memory before.
   *
   * @param {String|Object} query - SQL query as string or CQN object or entity name as specified in csn
   * (entity name is treated as: SELECT * FROM <entity name>).
   * @param {Array} [values] - values for prepared stmt in case of SQL query string.
   * @param {Function} callback - synchronous function to process each row of the result set.
   * @returns {Promise} - resolves to undefined if successful, rejects with error if not
   */
  foreach (query, values, callback) {
    const cb = callback || values

    return this.run(this._queryForForeach(query), this._valuesForForeach(values)).then(res => {
      if (Array.isArray(res)) {
        res.forEach(row => {
          cb(row)
        })
      }
    })
  }

  /**
   * Drops all tables/views and creates them again
   * @param {Object|Promise} csn - the unreflected CSN or promise that will resolve into csn.
   * @param {String} [dialect] - dialect, defaults to 'sqlite'
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn, dialect = 'sqlite') {
    if (csn.then) {
      return csn.then(csn => {
        return this._deploy(csn, dialect)
      })
    }

    return this._deploy(csn, dialect)
  }

  _deploy (csn, dialect) {
    const creates = cds.compile.to.sql(csn, { toSql: { dialect: dialect, names: cds.config.data.sql_mapping } })
    const sqls = this._prepareSqls(creates)

    let execChain = Promise.resolve()

    for (const drop of sqls.drops) {
      execChain = this._addDropsToChain(execChain, drop)
    }

    for (const create of sqls.creates) {
      execChain = this._addCreateToChain(execChain, create)
    }

    return execChain
  }

  _prepareSqls (creates) {
    const res = {}
    res.creates = []
    res.drops = []
    for (const create of creates) {
      const [, type, name] = create.match(/^\s*\w+\s+(table|view)\s+"?([^\s(]+?)"?[\s(]/im) || []

      if (type.toLowerCase() === 'view') {
        res.drops.unshift({ DROP: { view: name } })
        res.creates.push(create)
      } else if (type.toLowerCase() === 'table') {
        res.drops.push({ DROP: { entity: name } })
        res.creates.unshift(create)
      }
    }

    return res
  }

  /**
   * Hana does not support drop if exists so we need to handle this differently in hana.
   * The hana client needs to overwrite this to handle error in case the table does not exist.
   * @private
   */
  _addDropsToChain (chain, drop) {
    return chain.then(() => {
      return this.run(drop)
    })
  }

  _addCreateToChain (chain, drop) {
    return chain.then(() => {
      return this.run(drop)
    })
  }

  _valuesForForeach (values) {
    if (typeof values === 'function') {
      return
    }

    return values
  }

  _queryForForeach (query) {
    if (this._csn && this._csn.definitions[query]) {
      const entityName =
        (this._csn.definitions[query].query &&
          this._csn.definitions[query].query.target &&
          this._csn.definitions[query].query.target.name) ||
        this._csn.definitions[query].source || // OLD CSN
        this._csn.definitions[query].name

      return {
        SELECT: {
          from: { ref: [entityName] }
        }
      }
    }

    return query
  }

  _copyCqnInsert (cqn) {
    const cqnCopy = {
      INSERT: {
        into: cqn.INSERT.into
      }
    }

    if (cqn.INSERT.columns) {
      cqnCopy.INSERT.columns = [...cqn.INSERT.columns]
    }

    if (cqn.INSERT.values) {
      cqnCopy.INSERT.rows = [[...cqn.INSERT.values]]
    }

    if (cqn.INSERT.rows) {
      cqnCopy.INSERT.rows = []
      for (const row of cqn.INSERT.rows) {
        cqnCopy.INSERT.rows.push([...row])
      }
    }

    if (cqn.INSERT.entries) {
      cqnCopy.INSERT.entries = []
      for (const entry of cqn.INSERT.entries) {
        cqnCopy.INSERT.entries.push({ ...entry })
      }
    }

    return cqnCopy
  }

  _addDefaultValues (cqn, isNullable, isNotNullable) {
    if (!this._csn) {
      return cqn
    }

    if (cqn.INSERT) {
      return this._addDefaultValuesInsert(cqn, isNullable, isNotNullable)
    }

    return cqn
  }

  _addDefaultValuesInsert (cqn, isNullable, isNotNullable) {
    const entity = this._csn.definitions[(cqn.INSERT.into.name || cqn.INSERT.into).replace(/_drafts$/i, '')]
    if (!entity) {
      return cqn
    }
    if (cqn.INSERT.entries) {
      return this._addDefaultValuesEntries(cqn, entity, isNullable, isNotNullable)
    }
    if (cqn.INSERT.columns && (cqn.INSERT.values || cqn.INSERT.rows)) {
      return this._addDefaultValuesRows(cqn, entity, isNullable, isNotNullable)
    }

    return cqn
  }

  _hasDefaultValuesEntries (cqn, entity, isNullable, isNotNullable) {
    for (const entry of cqn.INSERT.entries) {
      for (const elementKey in entity.elements) {
        const element = entity.elements[elementKey]
        if (element.default === undefined) {
          continue
        }
        if (element.notNull && isNotNullable && entry[element.name] === undefined) {
          return true
        }
        if (!element.notNull && isNullable && entry[element.name] === undefined) {
          return true
        }
      }
    }

    return false
  }

  _addDefaultValuesEntries (cqn, entity, isNullable, isNotNullable) {
    const hasDefaultEntries = this._hasDefaultValuesEntries(cqn, entity, isNullable, isNotNullable)

    if (hasDefaultEntries) {
      const cqnCopy = this._copyCqnInsert(cqn)

      for (const entry of cqnCopy.INSERT.entries) {
        this._addDefaultValuesEntry(entity, entry, isNotNullable, isNullable)
      }

      return cqnCopy
    }

    return cqn
  }

  _addDefaultValuesEntry (entity, entry, isNotNullable, isNullable) {
    for (const elementKey in entity.elements) {
      const element = entity.elements[elementKey]
      if (element.default === undefined) {
        continue
      }
      if (element.notNull && isNotNullable && entry[element.name] === undefined) {
        entry[element.name] = element.default.val || element.default // OLD CSN
      }
      if (!element.notNull && isNullable && entry[element.name] === undefined) {
        entry[element.name] = element.default.val || element.default // OLD CSN
      }
    }
  }

  _hasDefaultValuesRows (cqn, entity, isNullable, isNotNullable) {
    for (const elementKey in entity.elements) {
      const element = entity.elements[elementKey]
      if (cqn.INSERT.columns.includes(element.name) || element.default === undefined) {
        continue
      }

      if ((element.notNull && isNotNullable) || (!element.notNull && isNullable)) {
        return true
      }
    }

    return false
  }

  _addDefaultValuesRow (entity, elementKey, cqnCopy, isNotNullable, isNullable) {
    const element = entity.elements[elementKey]
    if (cqnCopy.INSERT.columns.includes(element.name) || element.default === undefined) {
      return
    }

    if ((element.notNull && isNotNullable) || (!element.notNull && isNullable)) {
      cqnCopy.INSERT.columns.push(element.name)
      for (const row of cqnCopy.INSERT.rows) {
        row.push(element.default.val || element.default) // OLD CSN
      }
    }
  }

  _addDefaultValuesRows (cqn, entity, isNullable, isNotNullable) {
    const hasDefaultValues = this._hasDefaultValuesRows(cqn, entity, isNullable, isNotNullable)

    if (hasDefaultValues) {
      const cqnCopy = this._copyCqnInsert(cqn)

      for (const elementKey in entity.elements) {
        this._addDefaultValuesRow(entity, elementKey, cqnCopy, isNotNullable, isNullable)
      }

      return cqnCopy
    }

    return cqn
  }
}

module.exports = BaseClient
