const { resolveAssociation, isAssociation, isComplex } = require('../utils/associations')
const { config: { data: { sql_mapping: sqlMapping } } } = require('../cds')

/**
 * Check if the value is a function or reference to private function.
 * Return if any of the cases are true.
 * @param {string|function} fn -
 * @returns {function}
 * @throws Error
 * @private
 */
const _getMethod = fn => {
  if (typeof fn === 'function') {
    return fn
  }

  throw Error(`Method '${fn}' does not exist`)
}

/**
 * Get the entity name from CQN and check if it exists at CSN.
 * @param {Object} csn - Reflected CSN
 * @param {String} from - Entity name
 * @returns {string|undefined}
 * @private
 */
const _getEntityName = (csn, from) => {
  if (!from.ref || typeof csn !== 'object') {
    return
  }

  let entityName = from.ref[0]

  if (csn.definitions && csn.definitions[entityName]) {
    return entityName
  }

  entityName = entityName.replace(/_drafts$/i, '')

  if (csn.definitions && csn.definitions[entityName]) {
    return entityName
  }
}

const _refs = (refs, as) => {
  const arr = []

  for (const element of refs) {
    // multiple join are nested, so we need to find all the table names in there as well
    if (element.hasOwnProperty('join')) {
      arr.push(..._extractRefs(element))
      // Likely a union
    } else if (element.hasOwnProperty('SELECT')) {
      arr.push(..._extractRefs(element.SELECT.from, as))
    } else {
      arr.push(element)
    }
  }

  return arr
}

const _extractRefs = (from, as) => {
  if (from.SELECT) {
    return _extractRefs(from.SELECT.from, from.SELECT.as)
  }

  if (from.hasOwnProperty('join')) {
    // cqn with join in from
    return _refs(from.args)
  }

  if (from.hasOwnProperty('SET')) {
    return _refs(from.SET.args, from.SET.as || from.as)
  }

  const ref = { ref: from.ref, as: from.as }

  if (as) {
    ref.as = as
  }

  return [ref]
}

const _addMapperFunction = (elements, toService, key, type, from, allCombinations) => {
  if (!toService.has(type)) {
    return
  }

  const convertFunction = _getMethod(toService.get(type))

  // ambiguous cases will lead to SQL syntax errors anyway, so no need for a check
  elements.set(key, convertFunction)

  if (allCombinations) {
    elements.set(`${from.ref.join('.')}.${key}`, convertFunction)
    elements.set(`${from.as}.${key}`, convertFunction)
    elements.set(`${from.as}_${key}`, convertFunction)
  }
}

const _filterUnique = (value, index, arr) => {
  return arr.indexOf(value) === index
}

/**
 * Get a map of all possible elements and their mappers.
 * @param {Map} toService - Mapping instructions for data conversions based on CDS data types
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @param {Boolean} [allCombinations] - Include all possible combinations. Defaults to false.
 * @returns {Map<any, any>}
 * @private
 */
const _getElementCombinations = (toService, csn, cqn, allCombinations = false) => {
  const elements = new Map()

  // Get list of available and relevant entities as defined by from
  for (const from of _extractRefs(cqn.SELECT.from).filter(_filterUnique)) {
    const entityName = _getEntityName(csn, from)

    if (!entityName) {
      continue
    }

    const entity = csn.definitions[entityName]

    for (const key of Object.keys(entity.elements)) {
      const element = entity.elements[key]

      // Complex type
      if (isComplex(element)) {
        for (const complexKey of Object.keys(element.elements)) {
          _addMapperFunction(
            elements,
            toService,
            `${key}_${complexKey}`,
            element.elements[complexKey].type,
            from,
            allCombinations
          )
        }
      } else {
        // Flat type
        _addMapperFunction(elements, toService, key, element.type, from, allCombinations)
      }
    }
  }

  return elements
}

const _getCastFunction = ({ type }) => {
  switch (type) {
    case 'cds.Boolean':
      return Boolean
    case 'cds.Integer':
      return Number
    default:
      return String
  }
}

/**
 * Get a map of to be converted elements and their conversion functions.
 * @param {Map} toService - Mapping instructions for data conversions based on CDS data types
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @returns {Map<any, any>}
 * @private
 */
const _getMapperForListedElements = (toService, csn, cqn) => {
  const elements = _getElementCombinations(toService, csn, cqn, true)
  const mapper = new Map()

  for (const element of cqn.SELECT.columns) {
    if (element.ref) {
      const joinedName = element.ref.join('.')
      const name = element.as ? element.as : joinedName

      if (element.cast) {
        mapper.set(name, _getCastFunction(element.cast))
      } else if (elements.has(joinedName)) {
        mapper.set(name, elements.get(joinedName))
      } else if (elements.has(name)) {
        mapper.set(name, elements.get(name))
      }
    } else if (element.as && element.cast) {
      mapper.set(element.as, _getCastFunction(element.cast))
    }
  }

  return mapper
}

/**
 * Based on CSN and CQN get a map on how to map the result.
 * @param {Map} toService - Mapping instructions for data conversions based on CDS data types
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @returns {Map<any, any>}
 * @private
 */
const getPostProcessMapper = (toService, csn = {}, cqn = {}) => {
  // No mapper defined or irrelevant as no READ request
  if (!cqn.hasOwnProperty('SELECT')) {
    return new Map()
  }

  if (Array.isArray(cqn.SELECT.columns) && cqn.SELECT.columns.length !== 0 && !cqn.SELECT.columns.includes('*')) {
    return _getMapperForListedElements(toService, csn, cqn)
  }

  // No element/column specified
  return _getElementCombinations(toService, csn, cqn)
}

/**
 * Transform values for a result row.
 * @param {Object} row - To be converted row.
 * @param {Map} mapper - Instructions, how to transform.
 * @private
 */
const _transformRow = (row, mapper) => {
  /*
   * If mapper is iterated, no iteration at all will happen in case of no mappers.
   * Less iteration as if all row keys would iterated.
   */
  for (const [column, converter] of mapper.entries()) {
    row[column] = converter(row[column])
  }
}

/**
 * Post process the result as given by the db driver.
 * @param {*} result - The result as returned by the db driver.
 * @param {Map} dataMapper - Instructions, how to transform.
 * @returns {*}
 * @private
 */
const _postProcessData = (result, dataMapper) => {
  if (Array.isArray(result)) {
    for (let i = 0, length = result.length; i < length; i++) {
      _transformRow(result[i], dataMapper)
    }
  } else if (typeof result === 'object') {
    _transformRow(result, dataMapper)
  }

  return result
}

const _transformProperties = (row, propertyMapper) => {
  for (const key of Object.keys(row)) {
    if (propertyMapper.has(key)) {
      row[propertyMapper.get(key)] = row[key]

      delete row[key]
    }
  }
}

/**
 * Rename the properties.
 * @param {*} result - The result as returned by the db driver.
 * @param {Map} propertyMapper - Instructions, how to transform.
 * @returns {*}
 * @private
 */
const _postProcessProperties = (result, propertyMapper) => {
  if (Array.isArray(result)) {
    for (let i = 0, length = result.length; i < length; i++) {
      _transformProperties(result[i], propertyMapper)
    }
  } else if (typeof result === 'object') {
    _transformProperties(result, propertyMapper)
  }

  return result
}

const _transformBoth = (result, dataMapper, propertyMapper) => {
  if (Array.isArray(result)) {
    for (let i = 0, length = result.length; i < length; i++) {
      _transformProperties(result[i], propertyMapper)
      _transformRow(result[i], dataMapper)
    }
  } else if (typeof result === 'object') {
    _transformProperties(result, propertyMapper)
    _transformRow(result, dataMapper)
  }

  return result
}

const _mapHasEntries = map => {
  return map && map instanceof Map && map.size !== 0
}

const _postProcessObjStruct = (result, objStructMap) => {
  if (!result || !Array.isArray(result)) {
    return
  }

  for (let i = 0, length = result.length; i < length; i++) {
    let row = result[i]
    for (const key of Object.keys(row)) {
      if (objStructMap.has(key)) {
        const obj = {}
        let current = obj
        for (const element of objStructMap.get(key)) {
          current[element] = {}
          current = current[element]
        }
        current[key] = row[key]
        row = Object.assign(row, obj)

        delete row[key]
      }
    }
  }
}

/**
 * Post process the result as given by the db driver.
 * @param {*} result - The result as returned by the db driver.
 * @param {Map} dataMapper - Instructions, how to transform.
 * @param {Map} propertyMapper - Instructions, how to rename properties.
 * @returns {*}
 * @private
 */
const postProcess = (result, dataMapper, propertyMapper, objStructMapper) => {
  const hasDataMapper = _mapHasEntries(dataMapper)
  const hasPropertyMapper = _mapHasEntries(propertyMapper)

  if (hasDataMapper && hasPropertyMapper) {
    _transformBoth(result, dataMapper, propertyMapper)
  } else {
    if (hasDataMapper) {
      _postProcessData(result, dataMapper)
    }

    if (hasPropertyMapper) {
      _postProcessProperties(result, propertyMapper)
    }
  }

  if (objStructMapper) {
    _postProcessObjStruct(result, objStructMapper)
  }

  return result
}

const _getEntitiesOfFrom = from => {
  const entities = []
  if (from.args || from.SET) {
    const args = from.args || from.SET.args
    entities.push(..._getEntitiesOfFrom(args[0]), ..._getEntitiesOfFrom(args[1]))
  } else if (from.SELECT) {
    entities.push(..._getEntitiesOfFrom(from.SELECT.from))
  } else {
    entities.push(from.ref[0])
  }

  return entities
}

const _isAssocOrComp = (csn, from, element) => {
  const entities = _getEntitiesOfFrom(from)

  return entities.some(
    entity =>
      csn.definitions[entity] &&
      csn.definitions[entity].elements[element] &&
      (csn.definitions[entity].elements[element].type === 'cds.Association' ||
        csn.definitions[entity].elements[element].type === 'cds.Composition')
  )
}

const getStructMapper = (csn, cqn, propertyMapper) => {
  const map = new Map()

  if (
    csn &&
    cqn.SELECT &&
    Array.isArray(cqn.SELECT.columns) &&
    cqn.SELECT.columns.length !== 0 &&
    !cqn.SELECT.columns.includes('*')
  ) {
    for (const element of cqn.SELECT.columns) {
      if (element.ref && element.ref.length > 1 && _isAssocOrComp(csn, cqn.SELECT.from, element.ref[0])) {
        let property = element.ref[element.ref.length - 1]
        if (propertyMapper && propertyMapper.has(property)) {
          property = propertyMapper.get(property)
        }
        map.set(property, element.ref.slice(0, element.ref.length - 1))
      }
    }
  }

  return map
}

const _addToMap = (map, key) => {
  const allUpperKey = key.toUpperCase()

  if (key === allUpperKey) {
    return
  }

  map.set(allUpperKey, key)
}

const _addColumn = (map, from, element) => {
  _addToMap(map, element)

  if (from.ref) {
    _addToMap(map, `${from.ref.join('.')}.${element}`)
  }

  if (from.as) {
    _addToMap(map, `${from.as}.${element}`)
  }
}

const _addAssociationToMap = (map, from, element) => {
  for (const assocName of resolveAssociation(element)) {
    _addColumn(map, from, assocName)
  }
}

const _addComplexTypeToMap = (map, from, name, element) => {
  for (const complexName of Object.keys(element.elements)) {
    _addColumn(map, from, `${name}_${complexName}`)
  }
}

const _getKeyMapForAllElements = (csn, cqn) => {
  const map = new Map()

  // Get list of available and relevant entities as defined by from
  for (const from of _extractRefs(cqn.SELECT.from)) {
    const entityName = _getEntityName(csn, from)

    if (!entityName) {
      continue
    }

    for (const name of Object.keys(csn.definitions[entityName].elements)) {
      const element = csn.definitions[entityName].elements[name]

      if (isAssociation(element)) {
        _addAssociationToMap(map, from, element)
      } else if (isComplex(element)) {
        _addComplexTypeToMap(map, from, name, element)
      } else {
        _addColumn(map, from, name)
      }
    }
  }

  return map
}

const _getKeyMapForListedElements = cqn => {
  const map = new Map()

  for (const element of cqn.SELECT.columns) {
    if (element.as) {
      _addToMap(map, element.as)
    } else if (element.ref) {
      _addToMap(map, element.ref.join('.'))
    }
  }

  return map
}

/**
 * Provide a map with to be renamed properties.
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @param {Boolean} convertKeyNames - If the dbc converts columns to uppercase in plain mode, we need to convert back
 * @returns {Map<any, any>}
 */
const getPropertyMapper = (csn, cqn, convertKeyNames) => {
  if (!convertKeyNames || sqlMapping !== 'plain' || !cqn.SELECT) {
    return new Map()
  }

  // No element/column or '*' specified
  if (Array.isArray(cqn.SELECT.columns) && cqn.SELECT.columns.length !== 0 && !cqn.SELECT.columns.includes('*')) {
    return _getKeyMapForListedElements(cqn)
  }

  return _getKeyMapForAllElements(csn, cqn)
}

module.exports = {
  getPropertyMapper,
  getPostProcessMapper,
  getStructMapper,
  postProcess
}
