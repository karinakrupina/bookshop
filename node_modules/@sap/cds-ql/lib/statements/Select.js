const cds = require('../cds')
const Where = require('./Where')
const {
  IllegalFunctionArgumentError,
  JoinCalledError,
  UnexpectedFunctionCallError,
  HasBeenCalledError
} = require('../errors')
const { getOnCond } = require('@sap/cds-sql').onCond

const MODEL = Symbol.for('cds.ql.model')

/**
 * SELECT statement selects values or rows from a specific table.
 * @extends {Where}
 */
class Select extends Where {
  constructor () {
    super('SELECT')
  }

  /**
   * Wrapper that allows usages like:
   * SELECT(['column']).from('Table')
   * SELECT('column').from('Table')
   * SELECT.from('Table', ['column'])
   * @returns {function(*): Select}
   */
  static get select () {
    const fn = (...args) => {
      if (Array.isArray(args[0])) {
        args = args[0]
      }

      return {
        from: (entity, columns, model) => {
          return Select.from(entity, columns && columns.length !== 0 ? args.concat(columns) : args, model)
        }
      }
    }

    fn.from = Select.from
    fn.one = Select.one

    return fn
  }

  /**
   * Select entries of an entity.
   * @param {string|object} entity - entity name or an entity from reflection API or CQN
   * @param {array} columns Can be either an array or an array in string notation that specifies a list of column names or a function
   * @param {object} model the reflected CSN model
   * @returns {Select} this object instance for chaining.
   */
  static from (entity, columns, model) {
    if (!entity) {
      throw new IllegalFunctionArgumentError('entity')
    }

    const cqn = new Select()
    if (model) {
      Object.defineProperty(cqn, MODEL, { value: model })
    }
    cqn._parseColumns(columns, entity)
    cqn._parseEntity(entity)

    return cqn
  }

  /**
   * Select one entry of the entity. Can be used in combination with where() or byId().
   * @param {string|object} entity - entity name or an entity from reflection API or CQN
   * @param  {array} columns Can be either an array that specifies a list of column names or a function
   * @returns {Select} this object instance for chaining.
   */
  static one (entity, columns) {
    return Select.from(entity, columns).limit(1)
  }

  _parseColumns (columns, entity) {
    if (columns) {
      if (Array.isArray(columns)) {
        this._parseArray(columns, entity)
      } else if (columns instanceof Object && !this[MODEL]) {
        Object.defineProperty(this, MODEL, { value: columns })
      } else if (typeof columns === 'string' && columns.includes('{') && columns.includes('}')) {
        this.SELECT.columns = []
        if (columns.includes('.{')) {
          columns = `{${columns.replace(/{/g, '').replace(/}/g, '')}}`
        }
        const res = cds.parse.cql(`SELECT from ${entity} ${columns.replace(/'/g, '')}`)
        this._parseArray(res.SELECT.columns, entity)
      } else {
        throw new IllegalFunctionArgumentError('columns')
      }
    }
  }

  _parseEntity (entity) {
    if (typeof entity === 'string') {
      this._parseString(entity)
    } else if (typeof entity === 'object' && entity.hasOwnProperty('name')) {
      this._from(entity.name)
    } else if (typeof entity === 'object' && (entity.hasOwnProperty('SELECT') || entity.hasOwnProperty('SET'))) {
      this._fromCQN(entity)
    } else if (typeof entity === 'object') {
      this._fromObject(entity)
    } else {
      throw new IllegalFunctionArgumentError('entity')
    }
  }

  _fromObject (entity) {
    const key = this._getKey(entity, 'entity')
    if (key === 'ref') {
      // TODO: support further types of partial cqns like join.
      this.SELECT.from = entity
    } else {
      this._from(entity[key], key)
    }
  }

  /**
   * Group result by column names
   *
   * @param {...string} columns - String representing a column name.
   * @throws IllegalFunctionArgumentError
   * @returns {Select} this object instance for chaining.
   */
  groupBy (...columns) {
    if (columns.length === 0) {
      throw new IllegalFunctionArgumentError('columns')
    }

    columns.forEach(column => {
      this._addColumnToGroupBy(column)
    })

    return this
  }

  /**
   *  Used to specify column names in SELECT
   *
   * @param {array|string} columns Can be either a list of arguments, an array or a string for inline structure
   * @returns {Select} this object instance for chaining.
   */
  columns (columns) {
    if (columns) {
      // check if entity is received in .from as cqn or not
      const entity = this._getEntityNameFromCQN(this.SELECT.from)
      if (Array.isArray(columns) || (typeof columns === 'string' && columns.startsWith('{'))) {
        this._parseColumns(columns, entity)
      } else {
        this._parseColumns([...arguments], entity)
      }
    }
    return this
  }

  /**
   * Orders result by column names
   * @param {string|object} columnName - Column name or object describing the order
   * @param {string} [order] - sorting order, defaults to asc
   * @example
   * orderBy('Author', 'asc')
   * orderBy({Author: 'asc'})
   * @returns {Select} this object instance for chaining.
   */
  orderBy (columnName, order) {
    if (typeof columnName === 'string') {
      this._addColumnToOrderBy(columnName, order)
    } else if (typeof columnName === 'object') {
      this._addColumnToOrderByAsObject(columnName)
    } else {
      throw new IllegalFunctionArgumentError('columnName')
    }

    return this
  }

  /**
   * Add inner join.
   *
   * @param tableName - Table name to be used for join.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If where or having was already called.
   */
  join (tableName, as) {
    return this._join(tableName, as, 'inner')
  }

  /**
   * Add left join.
   *
   * @param tableName - Table name to be used for join.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If where or having was already called.
   */
  leftJoin (tableName, as) {
    return this._join(tableName, as, 'left')
  }

  /**
   * Add right join.
   *
   * @param tableName - Table name to be used for join.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If where or having was already called.
   */
  rightJoin (tableName, as) {
    return this._join(tableName, as, 'right')
  }

  /**
   * Add full join.
   *
   * @param tableName - Table name to be used for join.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If where or having was already called.
   */
  fullJoin (tableName, as) {
    return this._join(tableName, as, 'full')
  }

  /**
   * .on can only be used after .join has been called.
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If called without calling join before.
   */
  on (arg1, arg2, arg3, arg4) {
    if (!this._getCQN().from.hasOwnProperty('join')) {
      throw new JoinCalledError(true)
    }
    this._getCQN().from.on = this._parseArguments(arg1, arg2, arg3, arg4)
    return this
  }

  /**
   * Add having. Can not be called before .where.
   * @example
   *  * Fluid usage:
   * having(`name like`, 'foo', `and ( ratio between`, 0.1, `and`, 0.3, `or ratio >`, 0.9, `)`)
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed. Can be an aggregation function.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Select} this object instance for chaining.
   * @throws IllegalFunctionArgumentError - If no arguments are passed
   * @throws HasBeenCalledError - If called more than once
   * @throws UnexpectedFunctionCallError - If called in wrong context
   *
   */
  having (arg1, arg2, arg3, arg4) {
    if (!arg1) {
      throw new IllegalFunctionArgumentError('arg1')
    }

    const cqn = this._getCQN()
    if (cqn.having) {
      return this._andHaving(...arguments)
    }

    cqn.having = []
    return this._having(...arguments)
  }

  _having (...args) {
    if (args.length === 0) {
      throw new IllegalFunctionArgumentError('arg1')
    }

    // currently we only support fluid usage with 4+ args
    // or with a first arg containing expression indicator
    if (arguments.length > 4 || this._hasExpressionIndicator(args[0])) {
      this._getCQN().having.push(...this._fluidUsage(...args))
      return this
    }

    const needBrackets = args[0] instanceof Object && (args[0].or || args[0].and)
    needBrackets
      ? this._getCQN().having.push('(', ...this._parseArguments(...args), ')')
      : this._getCQN().having.push(...this._parseArguments(...args))
    return this
  }

  _andHaving () {
    return this._setAndOrBracket('and', 'having', ...arguments)
  }

  /**
   * Add distinct.
   * @returns {Select} this object instance for chaining.
   * @throws HasBeenCalledError - If called more than once
   *
   */
  distinct () {
    const cqn = this._getCQN()
    if (cqn.distinct) {
      throw new HasBeenCalledError('distinct')
    }
    cqn.distinct = true

    return this
  }

  /**
   * Add limit.
   * @param {Number} rows - the number of records to return
   * @param {Number} [offset] - skip that many rows before beginning to return rows
   * @returns {Select} this object instance for chaining.
   * @throws IllegalFunctionArgumentError - if rows parameter not specified
   * @throws HasBeenCalledError - If called more than once
   *
   */
  limit (rows, offset) {
    if (!rows) {
      throw new IllegalFunctionArgumentError('rows')
    }

    const cqn = this._getCQN()

    if (cqn.limit) {
      throw new HasBeenCalledError('limit')
    }

    cqn.limit = { rows: { val: rows } }
    if (offset) {
      cqn.limit.offset = { val: offset }
    }

    return this
  }

  _join (tableName, as, kind) {
    if (!tableName) {
      throw new IllegalFunctionArgumentError('tableName')
    }

    if (this._getCQN().where) {
      throw new UnexpectedFunctionCallError('join')
    }

    if (this._getCQN().having) {
      throw new UnexpectedFunctionCallError('join')
    }

    const ref = { ref: [tableName] }

    if (as) {
      ref.as = as
    }

    if (this._getCQN().from.hasOwnProperty('join')) {
      this._getCQN().from = { join: kind, args: [this._getCQN().from, ref] }
      return this
    }

    const from = this._getCQN().from
    this._getCQN().from = { join: kind, args: [from, ref] }

    return this
  }

  _parseNameAndKeys (associationString) {
    const elements = associationString.match(/[^,[\]]+/g) // [Books, ID=10] or [books, ID=10] or [books]
    const result = { name: elements[0] }

    if (elements.length > 1) {
      result.keys = {}

      for (const e of elements.slice(1)) {
        const parts = e.split('=')
        result.keys[parts[0]] = parts[1]
      }
    }

    return result
  }

  _getReflectedAssociation (entityName, associationName) {
    if (
      ['cds.Association', 'cds.Composition'].includes(
        this[MODEL].definitions[entityName].elements[associationName].type
      )
    ) {
      return this[MODEL].definitions[entityName].elements[associationName].target
    }
  }

  _getEntityNameFromServiceName (serviceName) {
    return this[MODEL].definitions[serviceName].name || this[MODEL].definitions[serviceName].source
  }

  _entityName (name, previousEntityName) {
    return !previousEntityName
      ? this._getEntityNameFromServiceName(name)
      : this._getReflectedAssociation(previousEntityName, name)
  }

  _getEntityNameFromCQN (cqn) {
    while (cqn.SELECT) {
      cqn = cqn.SELECT.from
    }

    return this._getEntityNameFromUnionCQN(cqn) || this._entityFromRef(cqn.ref)
  }

  _getEntityNameFromUnionCQN (cqn) {
    if (cqn.SET) {
      return cqn.SET.args
        .map(arg => {
          return this._getEntityNameFromCQN(arg)
        })
        .filter(name => {
          return !name.endsWith('_drafts')
        })[0]
    }
    if (cqn.join) {
      return cqn.args
        .map(arg => {
          return this._getEntityNameFromCQN(arg)
        })
        .filter(name => {
          return !name.endsWith('_drafts')
        })[0]
    }
  }

  _entityFromRef (ref) {
    if (ref) return ref[0]
  }

  _addKeysToWhere (cqn, keys, tableAlias) {
    if (keys) {
      for (const key of Object.keys(keys)) {
        cqn.where(`${tableAlias}.${key}`, keys[key])
      }
    }
  }

  _addExistsToWhere (cqn, previousCqn) {
    cqn.where('exists', previousCqn)
  }

  _addOnCondToWhere (cqn, entity, tableAlias, identifier) {
    const onCond = getOnCond(
      this[MODEL].definitions[entity.previous].elements[entity.current],
      entity.current,
      this[MODEL],
      tableAlias,
      identifier
    )

    const previousRef = {
      identifier: onCond[0].ref[0],
      refname: onCond[0].ref[1]
    }
    const currentRef = {
      refname: onCond[2].ref[1],
      identifier: onCond[2].ref[0]
    }

    const params = [previousRef, onCond[1], currentRef]
    cqn.where(...params)
  }

  _parseAssociation (parts) {
    let previousCqn, previousEntityName

    for (let i = 0; i < parts.length; i++) {
      const lastElement = i === parts.length - 1
      const tableAlias = `T${i}`
      const { name, keys } = this._parseNameAndKeys(parts[i])
      const entityName = this._entityName(name, previousEntityName)
      let currentCqn

      // last element is 'this'
      if (lastElement) {
        this._from(entityName, tableAlias)
        this._addKeysToWhere(this, keys, tableAlias)
      } else {
        currentCqn = Select.from(entityName, [1])
        currentCqn._from(entityName, tableAlias)
        this._addKeysToWhere(currentCqn, keys, tableAlias)
      }

      if (previousCqn) {
        this._addOnCondToWhere(previousCqn, { current: name, previous: previousEntityName }, tableAlias, `T${i - 1}`)

        if (lastElement) {
          this._addExistsToWhere(this, previousCqn)
        } else {
          this._addExistsToWhere(currentCqn, previousCqn)
        }
      }

      previousCqn = currentCqn
      previousEntityName = entityName
    }
  }

  _parseString (entity) {
    if (entity === '') {
      throw new IllegalFunctionArgumentError('entity')
    }
    // associations look like Authors[10]:books
    const parts = entity.split(':')

    if (parts.length === 1) {
      const parsed = this._parseStringElement(entity)
      this._from(parsed.ref[0], parsed.as)
    } else {
      this._parseAssociation(parts)
    }
  }

  _from (entityName, asName) {
    this.SELECT.from = { ref: [entityName] }

    if (asName) {
      this.SELECT.from.as = asName
    }
  }

  _fromCQN (cqn) {
    this.SELECT.from = cqn

    if (cqn.SET && cqn.SET.as) {
      this.SELECT.as = cqn.SET.as
      delete cqn.SET.as
    }
  }

  _addColumnToOrderByAsObject (columnObject) {
    this._extractKeysAndValuesFromObject(columnObject).forEach(item => {
      this._addColumnToOrderBy(item.key, item.value)
    })
  }

  _extractKeysAndValuesFromObject (object) {
    const array = []

    for (const key of Object.keys(object)) {
      array.push({ key: key, value: object[key] })
    }

    return array
  }

  _addColumnToOrderBy (column, order = 'asc') {
    let res
    if (this._isFunction(column)) {
      res = this._parseFunction(column)
    } else {
      res = column.includes('.') ? this._parseElementWithDot(column, this.SELECT.from.ref[0]) : { ref: [column] }
    }
    if (this.SELECT.hasOwnProperty('orderBy')) {
      this.SELECT.orderBy.push(res)
    } else {
      this.SELECT.orderBy = [res]
    }

    if (order === 'desc') {
      this.SELECT.orderBy[this.SELECT.orderBy.length - 1].sort = 'desc'
    } else if (order === 'asc') {
      this.SELECT.orderBy[this.SELECT.orderBy.length - 1].sort = 'asc'
    } else {
      throw new IllegalFunctionArgumentError('order')
    }
  }

  _addColumnToGroupBy (column) {
    const res =
      typeof column === 'string' && column.includes('.')
        ? this._parseElementWithDot(column, this.SELECT.from.ref[0])
        : { ref: [column] }

    if (this.SELECT.hasOwnProperty('groupBy')) {
      this.SELECT.groupBy.push(res)
    } else {
      this.SELECT.groupBy = [res]
    }
  }

  _parseArray (columns, entityName) {
    if (!this.SELECT.columns) {
      this.SELECT.columns = []
    }

    for (let i = 0, length = columns.length; i < length; i++) {
      if (typeof columns[i] === 'string' && columns[i + 1] instanceof Array) {
        this.SELECT.columns.push(this._parseElement({ [`expand(${columns[i]})`]: columns[i + 1] }))
        i++
      } else if (typeof columns[i] === 'string' && columns[i].includes('.')) {
        this.SELECT.columns.push(this._parseElementWithDot(columns[i], entityName))
      } else {
        this.SELECT.columns.push(this._parseElement(columns[i]))
      }
    }
  }

  _parseElement (element) {
    if (typeof element === 'string') {
      return this._parseStringElement(element)
    }

    if (typeof element === 'object') {
      return this._parseObjectElement(element)
    }

    if (this._isNumber(element)) {
      return this._parseNonCastedElement(element)
    }

    throw new IllegalFunctionArgumentError('columns')
  }

  /**
   * @examples
   * COUNT(1) AS count
   * SUM(number) AS number
   * COUNT(1)
   * @private
   */
  _parseStringElement (element) {
    const parts = element.split(' ')
    if (parts.length === 1) {
      // cannot be zero
      return this._parseNonCastedElement(element)
    }

    if (parts.length === 3 && parts[1].toUpperCase() === 'AS') {
      return this._parseCastedElement(parts[0], parts[2])
    }
    throw new IllegalFunctionArgumentError('element')
  }

  /**
   * @examples
   * {amount: 'COUNT(1)'}
   * {amount: 'SUM(number)'}
   * @private
   */
  _parseObjectElement (object) {
    // partial CQN: function calls and binding parameters are refs
    if (
      object.hasOwnProperty('val') ||
      object.hasOwnProperty('ref') ||
      object.hasOwnProperty('xpr') ||
      object.hasOwnProperty('SELECT')
    ) {
      return object
    }

    const key = this._getKey(object, 'columns')

    if (key.startsWith('expand(') && Array.isArray(object[key])) {
      return this._parseExpand(key, object[key])
    }

    return this._parseCastedElement(key, object[key])
  }

  _getKey (object, argumentName) {
    const key = Object.keys(object)[0]

    if (!key) {
      throw new IllegalFunctionArgumentError(argumentName)
    }

    return key
  }

  _parseExpand (expr, elements) {
    const ref = {
      ref: [expr.replace(/(^expand\(|\)$)/g, '')]
    }
    ref['expand'] = []
    for (const element of elements) {
      ref['expand'].push(this._parseElement(element))
    }
    return ref
  }

  _parseElementWithDot (column, entityName) {
    if (column.includes('.{')) {
      return { ref: this._matchInline(column) }
    }
    const parts = column.split(/\./)
    if (this[MODEL] && this._isAssociation(entityName, parts[0])) {
      return { ref: parts }
    }

    return this._parseStringElement(column)
  }

  _parseCastedElement (element, castedName) {
    const castedElement = this._parseNonCastedElement(element)
    castedElement.as = castedName
    return castedElement
  }

  /**
   * @examples
   * COUNT(1) => {ref: ['COUNT', {args: '1'}]}
   * SUM(number) => {ref: ['SUM', {args: [{ref: ['number']}]}]}
   * @private
   */
  _parseNonCastedElement (column) {
    if (this._isNumber(column)) {
      return { val: column }
    }

    if (this._isFunction(column)) {
      return this._parseFunction(column)
    }

    return { ref: [column] }
  }

  valueOf () {
    return `SELECT * FROM ${Select._quoteElement(this.SELECT.from.ref[0])} `
  }
}

module.exports = Select
