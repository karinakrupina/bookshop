const Where = require('./Where')
const { IllegalFunctionArgumentError } = require('../errors')

/**
 * UPDATE statement updates values or rows from a specific table.
 * @extends {Where}
 */
class Update extends Where {
  constructor () {
    super('UPDATE')
  }

  static entity (entity) {
    const cqn = new Update()
    cqn.UPDATE.entity = Where._isEntity(entity)

    return cqn
  }

  /**
   * Sets the values that should be updated
   *
   * @example
   * UPDATE('Authors').set({NAME: 'Jon Doe', STOCK: 123})
   *
   * @param {object} valueObject contains the properties that should be updated
   */
  set (valueObject) {
    if (this._isInvalidValueObject(valueObject)) {
      throw new IllegalFunctionArgumentError('values')
    }

    this.UPDATE.data = this._convertToCqnObject(valueObject)
    return this
  }

  _convertToCqnObject (valueObject) {
    const cqnObj = {}
    for (const key in valueObject) {
      cqnObj[key] = this._generateValObj(valueObject[key], key)
    }
    return cqnObj
  }

  _generateValObj (value, key) {
    if (value === null || value === undefined) {
      return { val: null }
    }

    if (['-=', '+=', '*=', '/=', '%='].includes(Object.keys(value)[0])) {
      const op = Object.keys(value)[0]
      const val = value[op]
      return { xpr: [{ ref: [key] }, op.substring(0, 1), { val: val }] }
    }

    if (value['=']) {
      return { ref: [value['=']] }
    }

    return { val: value }
  }

  _isInvalidValueObject (valueObject) {
    if (!(valueObject instanceof Object) || Array.isArray(valueObject)) {
      return true
    }

    for (const key of Object.keys(valueObject)) {
      if (
        valueObject[key] === undefined ||
        (valueObject[key] instanceof Object &&
          !Array.isArray(valueObject[key]) &&
          Object.keys(valueObject[key]).length === 0)
      ) {
        return true
      }
    }

    return false
  }

  valueOf () {
    return `UPDATE ${Update._quoteElement(this.UPDATE.entity)} `
  }
}

module.exports = Update
