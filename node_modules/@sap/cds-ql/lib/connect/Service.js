const Pool = require('./Pool')
const _options = require('./options')
const resolved = require('./resolved')
const cds = require('../cds')
const { IllegalFunctionArgumentError } = require('../errors')

/**
 * Service to acquire db connection clients.
 */
class Service {
  /**
   * Creates a Service according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {String} [datasource] - name of datasource
   * @param {Object} [options] - Pool and Client settings
   * @param {Object} [options.pool] - The min and max pool settings.
   * @param {number} [options.pool.min] - The minimum number of db connection clients.
   * @param {number} [options.pool.max] - The maximum number of db connection clients.
   * @param {number} [options.pool.idleTimeoutMillisForPools] - The time interval in ms until an idle pool is
   * evicted.
   * Default 60000 ms (1 min).
   * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * Default 10000 ms (10 s).
   * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * Defaults to half of options.pool.min, but at least 2.
   * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * Default 30000 ms (30 s).
   * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * Default 480000 ms (8 min).
   * @param {Object} options.kind - The to be used DB client.
   * @param {Object} [options.credentials] - Credentials how to connect with a client
   * @param {string} [options.credentials.host] - Address to the db
   * @param {string} [options.credentials.port] - Port for db
   * @param {string} [options.credentials.user] - Username for authentication
   * @param {string} [options.credentials.password] - Password for authentication
   * @param {boolean} [options.multiTenant] - true, if mt is active
   */
  constructor (datasource, options) {
    this.options = _options(datasource, options)

    if (this.options.multiTenant === true && this.options.package) {
      this._enrichOptions = this.options.package.options
    }

    this._init()
    this._pools = new Map()

    // Create cache for accessing entities
    Object.defineProperties(this, { _entities: { value: {} } })
  }

  _init () {
    // 1.  Save current functions
    const _run = this.run
    const _foreach = this.foreach
    const _deploy = this.deploy

    // 2. Load the model asynchronously
    const done = this._loadServiceModel(this.options.model)

      // 4. Remove/Replace placeholders when loaded
      .then(() => {
        delete this.then
        delete this.catch
        this.run = _run
        this.foreach = _foreach
        this.deploy = _deploy

        return this
      })

    // 3. Add placeholder methods to defer operations until the model is loaded
    this.then = (resolve, reject) => done.then(resolve).catch(reject)
    this.catch = reject => done.catch(reject)
    this.run = (...args) => done.then(() => this.run(...args))
    this.foreach = (...args) => done.then(() => this.foreach(...args))
    this.deploy = (...args) => done.then(() => this.deploy(...args))
  }

  _loadServiceModel (model) {
    if (model) {
      return cds.load(model).then(csn => {
        this.model = cds.linked(cds.unfold.for.odata(csn))
      })
    }

    return Promise.resolve()
  }

  get model () {
    // throw an error unless model is loaded
    const target =
      (this.options.credentials ? this.options.credentials.database : '') || this.options.url || this.options.host || ''

    throw new Error(
      `${this.options.model ? 'Model not yet loaded' : 'No model configured'} for service ${
        this.options.kind
      }: ${target}`
    )
  }

  set model (csn) {
    Object.defineProperty(this, 'model', { writable: 1, value: csn })
  }

  // delegate to linked model
  get entities () { return this.model.entities }

  /**
   * Acquires a db client from the session.
   * @param {Object} [clientOptions] - Client settings
   * @param {string} [clientOptions.user] - The user name for the db connection.
   * @param {string} [clientOptions.locale] - The language identifier.
   * @param {string} [clientOptions.JWT] - Full JWT from (HTTP) request.
   * @param {string} [clientOptions.tenantId] - GUID of a tenant.
   * @returns {Promise.<Object>} A promise for the acquired db client.
   */
  acquire (clientOptions = {}) {
    let poolKey

    try {
      poolKey = this._getPoolIdentifier(clientOptions.tenantId)
    } catch (err) {
      return Promise.reject(err)
    }

    const pool = this._pools.get(poolKey)

    // First call, or pool has been invalidated
    if (!pool) {
      return this._createPool(poolKey).then(pool => {
        return this._acquire(pool, poolKey, clientOptions)
      })
    }

    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      return pool.then(() => {
        return this._acquire(this._pools.get(poolKey), poolKey, clientOptions)
      })
    }

    return this._acquire(pool, poolKey, clientOptions)
  }

  // TODO: Replace with correct implementation
  transaction (req) {
    return {
      run: (...args) => {
        return req ? req.run(...args) : this.run(...args)
      }
    }
  }

  /**
   * Get the identifier for the pool.
   * @param {string} tenantId
   * @returns {string}
   * @private
   */
  _getPoolIdentifier (tenantId) {
    if (this.options.multiTenant) {
      if (tenantId) {
        return tenantId
      }

      throw new IllegalFunctionArgumentError('tenantId')
    }

    return 'singleTenant'
  }

  _handlePoolEviction (pool) {
    if (pool.noClientsBorrowed) {
      return this._disconnect(pool, pool._name)
    }
  }

  _clearPoolTimeout (pool) {
    if (pool._timeout !== undefined) {
      clearTimeout(pool._timeout)
      delete pool._timeout
    }
  }

  _setPoolTimeout (pool) {
    if (this.options.pool.idleTimeoutMillisForPools > 0) {
      this._clearPoolTimeout(pool)

      pool._timeout = setTimeout(() => {
        this._handlePoolEviction(pool)
      }, this.options.pool.idleTimeoutMillisForPools)
    }
  }

  /**
   * Create a pool instance if a test connect succeeds.
   * @param poolKey
   * @returns {*|Function|Promise<T>}
   * @private
   */
  _createPool (poolKey) {
    const ready = this._getAndCheckCredentials(poolKey)
      .then(options => {
        return this._createPoolInstance(options, poolKey)
      })
      .catch(err => {
        // Crash the node instance on purpose
        setImmediate(() => {
          throw err
        })

        // Throw again or other errors will occur until next tic is reached.
        throw err
      })

    this._pools.set(poolKey, ready)

    return ready
  }

  _createPoolInstance (options, poolKey) {
    const pool = new Pool(options)
    pool._name = poolKey
    this._pools.set(poolKey, pool)

    return pool
  }

  /**
   * Load credentials from instance manager if needed.
   * Test connect in any case.
   * @param {string} tenantId
   * @returns {Object}
   * @private
   */
  _getAndCheckCredentials (tenantId) {
    if (this.options.multiTenant) {
      return this._getServiceCredentials(tenantId).then(options => {
        return this._testConnection(options)
      })
    }

    return this._testConnection(this.options)
  }

  /**
   * Get the credentials for a service by id.
   * @param tenantId
   * @returns {*}
   * @private
   */
  _getServiceCredentials (tenantId) {
    if (!this._instanceManager) {
      return this._getInstanceManager().then(() => {
        return this._getInstanceCredentials(tenantId)
      })
    }

    return this._getInstanceCredentials(tenantId)
  }

  /**
   * Used to initialize the instance manager only once.
   * @returns {Promise}
   * @private
   */
  _getInstanceManager () {
    return new Promise((resolve, reject) => {
      // require only when needed
      let options = this.options.credentials || this.options
      options = Object.assign(options, { cache_max_items: 1, cache_item_expire_seconds: 1 })
      require('@sap/instance-manager').create(options, (err, instanceManager) => {
        if (err) {
          reject(err)
          return
        }

        this._instanceManager = instanceManager
        resolve()
      })
    })
  }

  /**
   * Use the instance manager instance to get the actual credentials.
   * @param tenantId
   * @returns {Promise<any>}
   * @private
   */
  _getInstanceCredentials (tenantId) {
    return new Promise((resolve, reject) => {
      this._instanceManager.get(tenantId, (err, instance) => {
        if (err) {
          reject(err)
          return
        }

        if (!instance || !instance.credentials) {
          reject(new IllegalFunctionArgumentError('tenantId'))
          return
        }

        // Get defaults from general options; mostly pool options are relevant
        const options = Object.assign({}, this.options, { kind: this.options.kind })
        options.pool = Object.assign({}, options.pool)
        options.credentials = Object.assign({}, options.credentials, instance.credentials)

        // A client might not provide the "options" function
        try {
          if (this._enrichOptions) {
            this._enrichOptions(options)
          }
        } catch (e) {
          reject(e)
          return
        }

        // Merge with options from , so one can set certain options like pool.
        resolve(options)
      })
    })
  }

  /**
   * Test the credentials by doing a test connect.
   * @param {Object} options
   * @returns {Promise<Object>}
   * @private
   */
  _testConnection (options) {
    const Client = options.package.Client
    const client = new Client(options.credentials || options)

    return client
      .connect()
      .then(() => {
        return client.end()
      })
      .then(() => {
        return options
      })
  }

  /**
   * Acquire a client from the pool.
   * @param {Object} pool
   * @param {Object} poolKey
   * @param {Object} clientOptions
   * @returns {Promise}
   * @private
   */
  _acquire (pool, poolKey, clientOptions) {
    return pool.acquire(clientOptions).then(client => {
      // add information to client, so it can be returned to correct pool.
      client._poolKey = poolKey

      return client
    })
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return this._destroyRelease('release', client)
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    return this._destroyRelease('destroy', client)
  }

  _destroyRelease (command, client) {
    const pool = this._getPoolFromClient(client)

    if (!pool) {
      return Promise.reject(new Error('bla'))
    }

    this._setPoolTimeout(pool)

    return pool[command](client)
  }

  _getPoolFromClient (client) {
    const pool = this._pools.get(client._poolKey)

    delete client._poolKey

    return pool
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   * @param {string} [tenantId] - GUID of a tenant.
   */
  disconnect (tenantId) {
    if (this._pools.size === 0) {
      return Promise.resolve()
    }

    if (tenantId) {
      const pool = this._pools.get(tenantId)
      return pool ? this._disconnect(pool, tenantId) : Promise.reject(new Error(`No pool for tenantId ${tenantId}`))
    }

    const disconnects = []

    for (const [poolKey, pool] of this._pools) {
      disconnects.push(this._disconnect(pool, poolKey))
    }

    return Promise.all(disconnects)
  }

  _disconnect (pool, poolKey) {
    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      return pool.then(() => {
        return this._cleanupPool(this._pools.get(poolKey), poolKey)
      })
    }

    return this._cleanupPool(pool, poolKey)
  }

  _cleanupPool (pool, poolKey) {
    return pool.disconnect().then(() => {
      this._clearPoolTimeout(pool)
      this._pools.delete(poolKey)
    })
  }

  /**
   * Execute CQN or SQL outside of the odata package.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @returns {Object} thenable, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  run (query, values) {
    const runs = []
    const promise = this.acquire().then(client => {
      let chain = client.run(query, values)

      for (const args of runs) {
        chain = chain.then(() => {
          return client.run(...args).catch(err => {
            throw err
          })
        })
      }

      return chain
        .then(res => {
          return this.release(client).then(() => {
            return res
          })
        })
        .catch(err => {
          return this.release(client).then(() => {
            throw err
          })
        })
    })

    const then = (resolve, reject) => {
      return promise.then(resolve).catch(reject)
    }
    const end = {
      then: then,
      catch: promise.catch
    }

    then.run = (...args) => {
      runs.push(args)
      return end
    }

    return end
  }

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion
   * instead of materializing the full set in memory before.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {function} cb - synchronous function to process each row of the result set.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  foreach (query, values, cb) {
    return this.acquire().then(client => {
      return client
        .foreach(query, values, cb)
        .then(() => this.release(client))
        .catch(err => {
          return this.release(client).then(() => {
            throw err
          })
        })
    })
  }

  /**
   * Drops all tables/views and creates them again
   * @param {object} csn the unreflected CSN.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    return this.acquire().then(client => {
      return this._load(csn).then(csn => {
        return client
          .deploy(csn)
          .then(() => this.release(client))
          .catch(err => {
            return this.release(client).then(() => {
              throw err
            })
          })
          .then(() => {
            return this.runInit(csn)
          })
      })
    })
  }

  runInit (csn) {
    const { join, sep } = require('path')
    const paths = new Set([join(process.cwd(), 'db')])
    const regxp = new RegExp('^(.*\\' + sep + 'db)(?:$|\\' + sep + ')', 'i')

    for (const file of csn._sources || []) {
      const [, path] = file.match(regxp) || []

      if (path) {
        paths.add(join(path))
      }
    }

    const all = []

    for (const path of paths) {
      all.push(this._runInit(path))
    }

    return Promise.all(all).then(() => {})
  }

  _runInit (givenPath) {
    const init = resolved(givenPath, 'init')

    return (typeof init === 'function' ? init() : init) || Promise.resolve()
  }

  _load (csn, ...args) {
    if (typeof csn === 'string') {
      args.unshift(csn)

      return cds.load(args).then(csn => {
        this.model = cds.linked(csn)
        return csn
      })
    }

    this.model = cds.linked(csn)
    return Promise.resolve(csn)
  }
}

if (process.env.DEBUG) {
  const { stdout } = require('./debug')

  class DebugSession extends Service {
    acquire (...args) {
      stdout('acquire connection')
      return super.acquire(...args)
    }

    release (...args) {
      stdout('release connection')
      return super.release(...args)
    }

    disconnect () {
      stdout('disconnect session')
      return super.disconnect()
    }
  }

  module.exports = DebugSession
} else {
  module.exports = Service
}
