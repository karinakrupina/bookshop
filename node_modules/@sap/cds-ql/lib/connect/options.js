const { IllegalFunctionArgumentError } = require('../errors')
const xsenv = require('./xsenv')
const runBlock = require('../statements/runBlock')
const cds = require('../cds')

/**
 * The credentials might be configured at the package.json
 * @returns {Object}
 * @private
 */
const _getFromCdsEnv = datasource => {
  const { env: { requires } } = require('../cds')

  if (requires) {
    // Do not change deep structures
    if (requires[datasource]) {
      return JSON.parse(JSON.stringify(requires[datasource]))
    }

    if (!datasource && requires.db) {
      return JSON.parse(JSON.stringify(requires.db))
    }
  }

  return { pool: {} }
}

const _getCredentials = (kind, url) => {
  // TODO: revisit once there are more sources than HANA and SQLite
  if (kind === 'sqlite') {
    return { database: url }
  }

  return { url: url }
}

/**
 * Parse a string into options.
 * @param {string} datasource
 * @returns {Object}
 * @private
 */
const _parseOptionsString = (datasource = '') => {
  const [, kind, url] = datasource.match(/^(\w+)(?::(.+))?$/) || []

  if (url) {
    return {
      kind: kind,
      credentials: _getCredentials(kind, url)
    }
  }

  // if there is only one match, it is a reference to a data source configuration at "requires"
  return _getFromCdsEnv(kind)
}

const _decorated = fn => {
  const { stdout } = require('./debug')

  return function (...args) {
    if (args.length > 2) {
      stdout(args[0], args[1])
    } else {
      stdout(...args)
    }

    return fn.apply(this, args)
  }
}

const _addDebugToClient = driver => {
  // The driver has a different method for select and transactions
  if (driver.prototype._runSingle) {
    driver.prototype._executeSelect = _decorated(driver.prototype._executeSelect)
    driver.prototype._runSingle = _decorated(driver.prototype._runSingle)

    return
  }

  driver.prototype._executeSQL = _decorated(driver.prototype._executeSQL)
}

/**
 * Provided clients will have the @sap group and cds- prefix.
 * Custom can have any string.
 * @param kind
 * @returns {*}
 * @private
 */
const _getDriverPackage = kind => {
  switch (kind) {
    case 'hana':
    case 'sqlite':
      return require(`@sap/cds-${kind}`)
    case undefined:
    case null:
    case '':
      throw new IllegalFunctionArgumentError('options.kind')
    default:
      return require(kind)
  }
}

/**
 * In case the kind is provided as string, require and use the package
 * @param {Object} options
 * @private
 */
const _addClientToOptions = options => {
  if (options.package) {
    return
  }

  if (typeof options.kind === 'function') {
    options.package = { Client: options.kind }
    return
  }

  options.package = _getDriverPackage(options.kind)

  if (options.multiTenant !== true) {
    options.package.options(options)
  }

  options.package.inject(cds.cds)

  if (!options.package.Client.prototype._runBlock) {
    options.package.Client.prototype._runBlock = runBlock

    if (process.env.DEBUG) {
      _addDebugToClient(options.package.Client)
    }
  }
}

/**
 * Get defaults or additional data for the given options.
 * @param {String} [datasource]
 * @param {Object} [options]
 * @returns {Object}
 * @private
 */
const checkOptions = (datasource, options) => {
  if (datasource && typeof datasource === 'object') {
    return checkOptions(undefined, datasource)
  }

  options =
    datasource || !options ? Object.assign(_parseOptionsString(datasource), options) : Object.assign({}, options)

  if (options.credentials) {
    options.credentials = Object.assign({}, options.credentials)
  }

  // Fallback
  if (options.driver) {
    options.kind = options.kind || options.driver
  }

  options.pool = Object.assign(
    {
      numTestsPerEvictionRun: options.pool && options.pool.min > 2 ? Math.ceil(options.pool.min / 2) : 2,
      softIdleTimeoutMillis: 30000,
      idleTimeoutMillis: 480000
    },
    options.pool,
    { testOnBorrow: true }
  )

  xsenv(options)

  _addClientToOptions(options)

  return options
}

module.exports = checkOptions
