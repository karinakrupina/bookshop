/**
 * Pool to acquire db connection clients.
 */
class Pool {
  /**
   * Creates a Pool according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {Object} options - Pool and Client settings
   * @param {Object} [options.pool] - The min and max pool settings.
   * @param {number} [options.pool.min] - The minimum number of db connection clients.
   * @param {number} [options.pool.max] - The maximum number of db connection clients.
   * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * @param {Object} options.kind - The to be used DB client.
   * @param {Object} [options.credentials] - Credentials how to connect with a client
   * @param {string} [options.credentials.host] - Address to the db
   * @param {string} [options.credentials.port] - Port for db
   * @param {string} [options.credentials.user] - Username for authentication
   * @param {string} [options.credentials.password] - Password for authentication
   */
  constructor (options) {
    this._pool = this._genericPool.createPool(this._getPoolFactory(options), options.pool)
  }

  _getPoolFactory (options) {
    return {
      /**
       * Connects the db client.
       *
       * @returns {Promise}
       * @private
       */
      create: () => {
        const Client = options.package.Client
        const client = new Client(options.credentials || options)
        return client.connect()
      },

      /**
       * Closes the database connection of the client and returns a promise which will be resolved upon success.
       *
       * @returns {Promise}
       * @private
       */
      destroy: client => {
        return client.end()
      },

      /**
       * Validate whether the client is in a valid state and successfully connected to the database or not.
       * @returns {Promise}
       * @private
       */
      validate: client => {
        return Promise.resolve(client.isValid())
      }
    }
  }

  get _genericPool () {
    return require('generic-pool')
  }

  /**
   * Acquires a db client from the session.
   * @param {Object} [clientOptions] - Client settings
   * @param {string} [clientOptions.user] - The user name for the db connection.
   * @param {string} [clientOptions.locale] - The language identifier.
   * @returns {PromiseLike.<Object>} A promise for the acquired db client.
   */
  acquire (clientOptions) {
    const options = Object.assign({ user: '', locale: 'en_US' }, clientOptions)

    return this._pool.acquire().then(client => {
      client.setLocale(options.locale)
      client.setUser(options.user)

      return client
    })
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return this._pool.release(client)
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    return this._pool.destroy(client)
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   */
  disconnect () {
    return this._pool.drain().then(() => {
      return this._pool.clear()
    })
  }

  get noClientsBorrowed () {
    return this._pool.borrowed === 0
  }
}

module.exports = Pool
