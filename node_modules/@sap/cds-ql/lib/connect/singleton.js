const { SessionInstanceError } = require('../errors')
const Service = require('./Service')

const _cache = {}
let _primary

/**
 * Create a singleton session instance to a database.
 * @param {String} [datasource] - name of datasource
 * @param {Object} [options] - Kind, connect and pool options.
 * @param {string|function} [options.kind] - Reference to a client facade or dependency injection of a custom one.
 * @param {string} [options.url] - Connect options in url format.
 * @param {Object} [options.pool] - The min and max pool options.
 * @param {number} [options.pool.min] - The minimum number of db connection clients.
 * @param {number} [options.pool.max] - The maximum number of db connection clients.
 * @param {number} [options.pool.evictionRunIntervalMillisForPools] - The time interval in ms until an idle pool is
 * evicted.
 * Default 60000 ms (1 min).
 * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
 * clients in a pool.
 * Default 10000 ms (10 s).
 * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
 * Defaults to half of options.pool.min, but at least 2.
 * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
 * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
 * options.pool.min.
 * Default 30000 ms (30 s).
 * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
 * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
 * client and creates a new one to meet options.pool.min.
 * Default 480000 ms (8 min).
 * @param {Object} [options.credentials] - Information how to connect to data source.
 * @param {Boolean} [primary] - If this connection is primary.
 * @returns {PromiseLike} resolves if session creation was successful, rejects if not
 */
const connect = (datasource, options, primary = false) => {
  if (((datasource && _cache[datasource]) || (primary && _primary)) && options) {
    throw new Error('Cannot access cache with options')
  }

  if (typeof datasource !== 'object' && _cache[datasource]) {
    return _cache[datasource]
  }

  if (primary && _primary) {
    return _primary.session
  }

  const session = new Service(datasource, options)

  if (datasource) {
    _cache[datasource] = session
  }

  if (primary) {
    _primary = {
      datasource,
      session
    }
  }

  return session
}

/**
 * Acquires a db client from the session.
 * @param {Object} [clientOptions] - Client settings
 * @param {string} [clientOptions.user] - The user name for the db connection.
 * @param {string} [clientOptions.locale] - The language identifier.
 * @returns {Promise.<Object>} A promise for the acquired db client.
 * @alias module:singleton.acquire
 */
const acquire = clientOptions => {
  if (_primary) {
    return _primary.session.acquire(clientOptions)
  }

  return Promise.reject(new SessionInstanceError())
}

/**
 * Releases a db client to be reused by the session.
 * @param {Client} client - The client that should be released
 * @returns {Promise} A promise for the release of the client
 * @alias module:singleton.release
 */
const release = client => {
  if (_primary) {
    return _primary.session.release(client)
  }

  return Promise.reject(new SessionInstanceError())
}

/**
 * Destroy a db client to be recreated by the session.
 * @param {Client} client - The client that should be destroyed
 * @returns {Promise} A promise for the destruction of the client
 * @alias module:singleton.release
 */
const destroy = client => {
  if (_primary) {
    return _primary.session.destroy(client)
  }

  return Promise.reject(new SessionInstanceError())
}

/**
 * Disconnects and deletes the session instance.
 * @param {string} [tenantId] - GUID of a tenant.
 * @returns {Promise} Promise without a parameter.
 * @alias module:singleton.disconnect
 */
const disconnect = tenantId => {
  if (_primary) {
    return _primary.session.disconnect(tenantId).then(() => {
      if (!tenantId) {
        delete _cache[_primary.datasource]
        _primary = null
      }
    })
  }

  return Promise.reject(new SessionInstanceError())
}

/**
 * Checks if a session instance is available
 * @returns {boolean} true if session is available
 */
const hasSession = () => {
  return Boolean(_primary)
}

/**
 * Execute CQN or SQL outside of the odata package.
 *
 * @param {string|object} query - SQL string or CQN object generated by the DML statements.
 * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
 * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
 *
 */
const run = (query, values) => {
  if (_primary) {
    return _primary.session.run(query, values)
  }

  return Promise.reject(new SessionInstanceError())
}

/**
 * Executes the statement and processes the result set one by one.
 * Should be used if huge result sets are expected to process it in a streaming-like fashion
 * instead of materializing the full set in memory before.
 *
 * @param {string|object} query - SQL string or CQN object generated by the DML statements.
 * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
 * @param {function} cb - synchronous function to process each row of the result set.
 * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
 */
const foreach = (query, values, cb) => {
  if (_primary) {
    return _primary.session.foreach(query, values, cb)
  }

  return Promise.reject(new SessionInstanceError())
}

/**
 * Drops all tables/views and creates them again
 * @param {object} csn the unreflected CSN.
 * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
 */
const deploy = csn => {
  if (_primary) {
    return _primary.session.deploy(csn)
  }

  return Promise.reject(new SessionInstanceError())
}

/**
 * @module singleton
 */
module.exports = {
  acquire,
  connect,
  destroy,
  disconnect,
  hasSession,
  release,
  run,
  foreach,
  deploy
}
