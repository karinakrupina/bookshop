const { reflect, infer, builtin:{types} } = require('../index'), { cached, set } = reflect
const { any, struct, array, context, service, entity, annotation } = types
const kinds = { context, service, entity, view:entity, annotation }
const isLinked = Symbol()

module.exports = cached (m => {
	const rm = reflect(m,1)
	return rm[isLinked] ? rm : Object.defineProperty (rm, isLinked, {value:true})
	.foreach (_link)
	.foreach ('view', _infer)  //> 2nd pass to also resolve targets via paths in from clauses
})

function _link (d, name, parent, defs) {
	if (!d) return
	if (parent)   set (d,'parent', parent)
	if (!d.name)  set (d,'name', name)
	if (d.target) set (d,'_target', _link (d.target.inline, '<inline>', d,defs) || _resolve (d.target,defs))
	if (d.via) 	  set (d,'_via', _link (d.via.inline, '<inline>', d,defs) || _resolve (d.via,defs))
	for (let e in d.elements) _link (d.elements[e],e,d,defs)
	const proto = d.type ? _resolve (d.type,defs) : kinds [d.kind]
		|| ( d.elements ? struct : d.items ? array : any )
	try { d.__proto__ = proto } catch(e) {
		throw new Error (`circular dependency: ${d.name} -> ${proto.name}`)
	}
	return d
}

function _infer  (v, n,p, defs) {
	const q = v.query;  if (!q.SELECT || !q.SELECT.from || !q.SELECT.from.ref)  return
	const t = v.__proto__ = infer (q,defs) || _unresolved ('invalid query?', entity)
    if (t)  Object.defineProperty (v,'source',{value: t.name})
}
const _resolve = (x,defs) => defs[x] || types[x] || (defs[x] = _unresolved(x))
const _unresolved = (x,p=any)  => ({name:x, __proto__:p, isUnresolved:true})
