class any {
	get kind(){
		return this.set('kind', this.parent ? 'element' : this.query ? 'entity' : 'type')
	}
	is (kind) {
		if (typeof kind === 'function')  return this instanceof kind
		if (kind === 'struct')  return this.elements !== undefined
		else return this.kind === kind
	}
	own (property) {
		let pd = Reflect.getOwnPropertyDescriptor (this, property)
		if (pd)  return pd.value || pd.get(this)
	}
	set (property, value) {
		Reflect.defineProperty (this, property, { value, writable:1, configurable:1 })
        return value
	}
	constructor(...aspects){ _mixin(this,...aspects) }
	mixin (...aspects) { _mixin (this, ...aspects); return this }
	static mixin (...aspects) { _mixin (this.prototype, ...aspects) }
}

class entity extends any {
	is (kind) {
		return kind === 'entity' || kind === 'struct' || super.is(kind)
	}
	get keys() {
		let ee=this.elements, keys, dict={}
		for (let e in ee)  if (ee[e].key)  (keys=dict)[e] = ee[e]
        return this.set ('keys',keys)
	}
}

class Association extends any {
	is (kind) {
		return kind === 'Association' || this.type.endsWith(kind) || super.is(kind)
	}
	get is2one() {
		let c = this.cardinality
		return !c || c.max === 1 || !c.max && !c.targetMax || c.targetMax === 1
	}
    get is2many() {
		return !this.is2one
	}
	get keys() {
		if (!this.on && this.is2one && this._target) {
			let keys=[], tks = this._target.keys
			for (let k in tks)  keys.push ({ ref: [tks[k].name] })
			return this.set ('keys',keys)
		}
		return this.set ('keys', undefined)
	}
}

const classes = module.exports = {
	any, mixin (classes, defs = _bootstrap.definitions) {
		if (!defs) { // first-time called from core
			defs = _bootstrap (_bootstrap.definitions = classes)
			classes = { any, entity, Association }
		}
		// mixin the classes' prototypes into definitions
		for (let each in classes)  _mixin (defs[each], classes[each])
		return defs
	}
}

function _mixin (o, ...aspects) {
	for (let each of aspects) {
		const aspect = each.prototype || each
		for (let p of Reflect.ownKeys(aspect)) {
			p in {constructor:1,prototype:1} || Reflect.defineProperty (
				o, p, Reflect.getOwnPropertyDescriptor (aspect,p)
			)
		}
	}
}

function _bootstrap (defs) {
	for (let n in defs) { // first ensure all are linked to any
		const d = defs[n];  if (!d.type)  d.__proto__ = any.prototype
	}
	for (let n in defs) {
		const d = defs[n], c = classes[n] = function(...all){ _mixin(this,...all) }
		Object.setPrototypeOf (c, d.__proto__.constructor)
		Reflect.defineProperty (d, 'constructor', {value:c})
		Reflect.defineProperty (c, 'prototype', {value:d})
		Reflect.defineProperty (c, 'name', {value:n})
	}
	defs.any = any.prototype
	return defs
}