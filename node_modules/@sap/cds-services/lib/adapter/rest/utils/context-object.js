const getStatements = require('../../utils/getStatements')
const restToCqn = require('../rest-to-cqn')
const getAnnotatedElements = require('../../utils/getAnnotatedElements')
const getKeyValuePair = require('./key-value-pair')
const { addDefaultValuesDeep } = require('../../../util/dataProcessUtils')

const _isCustomOperation = element => {
  return element.kind === 'action' || element.kind === 'function'
}

/**
 * Get data from odata-v4.
 * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
 * For function invocations the URL parameters are set as data.
 * For CREATE and UPDATE annotated columns can be mixed in.
 *
 * @param {string} component - odata-v4 component which processes this request.
 * @param req
 * @param annotatedColumns - in case of insert and update we might have annotated columns for user/now
 * @returns {Object}
 * @private
 */
const _getData = ({ method, segments }, annotatedColumns, target, req) => {
  // TODO: what to do by reading collections
  const keyValues = method === 'CREATE' ? {} : getKeyValuePair(target, segments[1])

  if (method === 'READ' || method === 'DELETE') {
    return keyValues
  }

  const data = Object.assign({}, req.body)

  for (const key of Object.keys(keyValues)) {
    data[key] = keyValues[key]
  }

  for (const column of annotatedColumns) {
    data[column.name] = column.value
  }

  if (target && (req.method === 'POST' || req.method === 'PUT')) {
    addDefaultValuesDeep(data, target)
  }

  return data
}

const _getAnnotatedColumns = (method, context) => {
  switch (method) {
    case 'CREATE':
      return getAnnotatedElements('insert', context)
    case 'UPDATE':
      return getAnnotatedElements('update', context)
    default:
      return []
  }
}

const getContextObject = (service, parsedUrl, req, res) => {
  const context = {
    get data () {
      if (_isCustomOperation(parsedUrl.segments[parsedUrl.segments.length - 1])) {
        // TODO: if action or function we do not support parameters yet
        // retrieve function/action parameters
        return {}
      }

      const annotatedColumns = _getAnnotatedColumns(parsedUrl.method, this)
      const data = _getData(parsedUrl, annotatedColumns, this.target, req)
      Object.defineProperty(context, 'data', { value: data })
      return data
    },
    get query () {
      const query = restToCqn(context, parsedUrl)

      Object.defineProperty(context, 'query', { value: query })
      return query
    },
    get target () {
      let target

      // TODO: replace with generic solution, target is either the first segment (no associations) or undefined for custom operations
      if (!_isCustomOperation(parsedUrl.segments[0])) {
        target = parsedUrl.segments[0]
      }
      Object.defineProperty(context, 'target', { value: target })

      return target
    },
    get statements () {
      const statements = getStatements(service)

      Object.defineProperty(context, 'statements', { value: statements })

      return statements
    },
    get _ () {
      const _ = { req, res }
      Object.defineProperty(context, '_', { value: _ })
      return _
    }
  }

  return context
}

module.exports = getContextObject
