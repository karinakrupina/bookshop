const { getError } = require('../../../errors')

const _normalizeAndSplitUrl = req => {
  // if (Object.keys(req.query).length > 0) {
  //   throw getError(400, 'query parameters are not yet supported')
  // }

  // Normalize /path////to/someWhere into path/to/someWhere and split by path
  const parts = `/${req.path}/`
    .replace(/[/]+/g, '/')
    .replace(/\/(.*)\//, '$1')
    .split('/')

  // TODO: replace with generic solution, currently we do not support longer urls
  if (parts.length > 3) {
    throw getError(400, 'navigation is not yet supported')
  }

  return parts
}

const _enrichCustomOperation = (csnElement, customOperationName) => {
  return Object.assign({ name: customOperationName }, csnElement)
}

const _initializeParsed = method => {
  return {
    method: method,
    segments: []
  }
}

const _validateEntityOrCustomOperation = (customOperation, entity, name) => {
  if (!entity) {
    throw getError(404, `Requested resource ${name} is not found`)
  }

  if (entity.kind === 'entity') {
    return entity
  }

  if (entity.kind === customOperation) {
    return _enrichCustomOperation(entity, name)
  }

  throw getError(400, `${name} is neither a valid resource or an unbound ${customOperation}`)
}

const _validateEntity = entity => {
  if (!entity) {
    throw getError(404)
  }

  if (entity.kind === 'entity') {
    return entity
  }

  throw getError(400, `${entity.name} is not a valid resource`)
}

const _validateCustomOperation = (entity, name, customOperation) => {
  if (entity.actions && entity.actions[name] && entity.actions[name].kind === customOperation) {
    return _enrichCustomOperation(entity.actions[name], name)
  }

  throw getError(400, `${name} is not a bound ${customOperation}`)
}

const _setConvenienceProperties = parsed => {
  const lastElement = parsed.segments[parsed.segments.length - 1]

  if (typeof lastElement === 'string') {
    parsed.isCollection = false
  } else if (lastElement.kind === 'entity') {
    parsed.isCollection = true
  } else {
    parsed.customOperation = parsed.segments.length === 1 ? `unbound${lastElement.kind}` : `bound${lastElement.kind}`
  }
}

const parseCreateOrReadUrl = (method, entities, req) => {
  const parts = _normalizeAndSplitUrl(req)
  const customOperation = method === 'READ' ? 'function' : 'action'
  const parsed = _initializeParsed(method)

  // TODO: replace with generic solution
  if (parts.length === 1) {
    parsed.segments.push(_validateEntityOrCustomOperation(customOperation, entities[parts[0]], parts[0]))
  }

  if (parts.length === 2) {
    if (method === 'CREATE') {
      throw getError(400, 'POST is only supported on resource collections or actions')
    }

    parsed.segments.push(_validateEntity(entities[parts[0]]), parts[1])
  }

  if (parts.length === 3) {
    const entity = _validateEntity(entities[parts[0]])
    const key = parts[1]
    const operation = _validateCustomOperation(entity, parts[2], customOperation)

    parsed.segments.push(entity, key, operation)
  }

  _setConvenienceProperties(parsed)

  return parsed
}

const parseUpdateOrDeleteUrl = (method, entities, req) => {
  const parts = _normalizeAndSplitUrl(req)

  // TODO: replace with generic solution
  if (parts.length !== 2) {
    throw getError(400, 'PUT/PATCH and DELETE are only supported on a specific resource')
  }
  const entity = _validateEntity(entities[parts[0]])

  return {
    method: method,
    segments: [entity, parts[1]]
  }
}

module.exports = {
  parseCreateUrl: (entities, req) => {
    return parseCreateOrReadUrl('CREATE', entities, req)
  },
  parseReadUrl: (entities, req) => {
    return parseCreateOrReadUrl('READ', entities, req)
  },
  parseUpdateUrl: (entities, req) => {
    return parseUpdateOrDeleteUrl('UPDATE', entities, req)
  },
  parseDeleteUrl: (entities, req) => {
    return parseUpdateOrDeleteUrl('DELETE', entities, req)
  }
}
