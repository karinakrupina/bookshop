const getKeyValuePair = require('../utils/key-value-pair')

const _removeKey = (obj, key) => {
  const res = Object.assign({}, obj)
  delete res[`${key}`]
  return res
}

const _cqnForCustomOperations = ({ statements: { SELECT }, target }, { customOperation, segments }) => {
  // if custom operation is unbound, query is undefined
  if (customOperation.startsWith('bound')) {
    return SELECT.from(target).where(getKeyValuePair(target, segments[1]))
  }
}

const _createToCQN = (context, parsedUrl) => {
  if (!parsedUrl.customOperation) {
    return context.statements.INSERT.into(context.target).entries(context.data)
  }

  return _cqnForCustomOperations(context, parsedUrl)
}

const _readToCQN = (context, parsedUrl) => {
  if (!parsedUrl.customOperation) {
    const cqn = context.statements.SELECT.from(context.target)

    return parsedUrl.isCollection ? cqn : cqn.where(context.data)
  }

  return _cqnForCustomOperations(context, parsedUrl)
}

const _updateToCQN = (context, parsedUrl) => {
  const key = Object.keys(context.target.keys)[0]
  const value = parsedUrl.segments[parsedUrl.segments.length - 1]

  return context.statements
    .UPDATE(context.target)
    .set(_removeKey(context.data, Object.keys(context.target.keys)[0]))
    .where(key, value)
}

module.exports = (context, parsedUrl) => {
  // TODO: replace with generic solution
  switch (parsedUrl.method) {
    case 'CREATE':
      return _createToCQN(context, parsedUrl)
    case 'READ':
      return _readToCQN(context, parsedUrl)
    case 'UPDATE':
      return _updateToCQN(context, parsedUrl)
    case 'DELETE':
      return context.statements.DELETE.from(context.target).where(context.data)
    default:
      return {}
  }
}
