const { AuditLogNotWritten } = require('../../errors')
const getColumns = require('../../services/utils/columns')
const eventMap = new Map([
  ['CREATE', '@AuditLog.Operation.Insert'],
  ['READ', '@AuditLog.Operation.Read'],
  ['UPDATE', '@AuditLog.Operation.Update'],
  ['DELETE', '@AuditLog.Operation.Delete']
])
const _isRelevantOperation = (event, entity) => {
  return entity[eventMap.get(event)]
}

const _relevantColumns = target => {
  const columns = getColumns(target)

  const relevantColumns = {
    keys: {},
    sensitive: {},
    fieldSemantics: {
      keys: {}
    }
  }

  for (const column of columns) {
    if (column.key) {
      relevantColumns.keys[column.name] = column
    }

    if (column['@PersonalData.FieldSemantics']) {
      switch (column['@PersonalData.FieldSemantics']) {
        case 'DataSubjectRole':
          relevantColumns.fieldSemantics.role = column
          break
        case 'DataSubjectType':
          relevantColumns.fieldSemantics.type = column
          break
        case 'DataSubjectId':
          relevantColumns.fieldSemantics.keys[column.name] = column
          break
      }
    }

    if (column['@PersonalData.IsSensitive']) {
      relevantColumns.sensitive[column.name] = column
    }
  }

  return relevantColumns
}

const _isRelevantAttribute = (context, row, attribute) => {
  if (context.event === 'UPDATE') {
    return context.diff.some(d => d.name === attribute)
  }

  // no audit logging for creating, reading, deleting sensitive fields which is not set
  return row[attribute] !== null
}

const _getAuditLogData = (context, columns, row) => {
  const auditLogData = {
    attributes: {},
    dataSubject: {
      keys: {}
    },
    diff: context.diff,
    auditObject: {
      type: context.target.name,
      keys: {}
    },
    tenant: context.attr.identityZone,
    user: context.user.id
  }
  const properties = Object.keys(row)

  for (const property of properties) {
    if (columns.keys[property]) {
      auditLogData.auditObject.keys[property] = row[property].toString()
    }

    if (columns.sensitive[property] && _isRelevantAttribute(context, row, property)) {
      auditLogData.attributes[property] = row[property]
    }
  }

  if (context.target['@PersonalData.EntitySemantics'] === 'DataSubject') {
    auditLogData.dataSubject.type = context.target.name
    auditLogData.dataSubject.keys = auditLogData.auditObject.keys
  } else {
    auditLogData.dataSubject.type = row[columns.fieldSemantics.type.name]
    auditLogData.dataSubject.role = row[columns.fieldSemantics.role.name]

    const fieldSemanticsKeys = Object.keys(columns.fieldSemantics.keys)

    for (const key of fieldSemanticsKeys) {
      auditLogData.dataSubject.keys[key] = row[key].toString()
    }
  }

  return auditLogData
}

const _logReadAccess = (auditLogger, context) => {
  const promises = []
  let auditLogData

  const relevantColumns = _relevantColumns(context.target)

  for (const row of context.result) {
    auditLogData = _getAuditLogData(context, relevantColumns, row)
    if (Object.keys(auditLogData.attributes).length > 0) {
      promises.push(auditLogger.logReadAccess(auditLogData))
    }
  }

  return Promise.all(promises)
}

const _logDataChange = (auditLogger, context, phase) => {
  const relevantColumns = _relevantColumns(context.target)

  const auditLogData = _getAuditLogData(context, relevantColumns, context.oldData || context.data)
  if (Object.keys(auditLogData.attributes).length > 0) {
    return auditLogger.logDataChange({
      context,
      auditLogData,
      phase: phase
    })
  }
}

const _callAuditLogContinuation = (context, phase) => {
  return new Promise((resolve, reject) => {
    const status = phase === 'after commit' && context.success ? 'logSuccess' : 'logFailure'
    context._.auditLogContinuation[status](err => {
      if (err) {
        return reject(new AuditLogNotWritten(err, phase))
      }

      resolve()
    })
  })
}

module.exports = auditLogger => {
  return {
    /**
     * Starts the audit logging in case of a data change event or writes the log immediately for data read access.
     *
     * @param context - the context object
     * @returns {*|Promise} - promise if relevant for audit logging, otherwise undefined
     */
    personalDataBeforeCommitHandler: context => {
      if (_isRelevantOperation(context.event, context.target)) {
        if (context.event === 'READ') {
          return _logReadAccess(auditLogger, context)
        }

        return _logDataChange(auditLogger, context, 'before commit')
      }
    },

    /**
     * Finishes the audit logging in case of a data change event and commit.
     *
     * @param result - the result of the event
     * @param context - the context object
     * @returns {Promise}
     */
    personalDataAfterCommitHandler: (result, context) => {
      if (_isRelevantOperation(context.event, context.target) && context._.auditLogContinuation) {
        return _callAuditLogContinuation(context, 'after commit')
      }
    },

    /**
     * In case of failed commit: finishes the audit logging in case of a data change event and rollback.
     * In case of failed on handler: starts audit logging
     *
     * @param context - the context object
     * @returns {Promise}
     */
    personalDataBeforeRollbackHandler: context => {
      const phase = 'before rollback'

      if (_isRelevantOperation(context.event, context.target) && context.event !== 'READ') {
        if (context._.auditLogContinuation) {
          return _callAuditLogContinuation(context, phase)
        }

        return _logDataChange(auditLogger, context, phase)
      }
    },

    /**
     * Finishes the audit logging in case of a data change event and rollback.
     *
     * @param result - the result of the event
     * @param context - the context object
     * @returns {Promise}
     */
    personalDataAfterRollbackHandler: (result, context) => {
      if (_isRelevantOperation(context.event, context.target) && context._.auditLogContinuation) {
        return _callAuditLogContinuation(context, 'after rollback')
      }
    }
  }
}
