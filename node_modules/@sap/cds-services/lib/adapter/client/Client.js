const cds = require('../../cds')

// Handlers
const handlerArguments = require('./handlers/arguments')
const handlerPostProcess = require('./handlers/post-process')
const cqnToData = require('./handlers/cqn-to-data')

const { FeatureNotSupported, NoServiceFound, NotInModel } = require('../../errors')

const IS_BATCH = Symbol.for('IS_BATCH')
const OPEN_REQUESTS = Symbol.for('OPEN_REQUESTS')

// Lazy loading, to prevent a recursion
const isService = cdsService => {
  if (!(cdsService instanceof require('../../services/Service'))) {
    throw new NoServiceFound()
  }
}

/**
 * Local service client.
 */
class Client {
  /**
   * @param {Service} cdsService
   * @throws ModelNotDefined - in case no or an invalid csn model is provided.
   */
  constructor (cdsService) {
    isService(cdsService)

    this._cdsService = cdsService
    this.entities = cdsService.entities
    this._addCustomEvents(cdsService.model)
  }

  /**
   * Lookup CSN for any kind of non standard actions and functions.
   * Add them as static functions to this instance.
   * @param reflectedModel {Object}
   * @private
   */
  _addCustomEvents (reflectedModel) {
    this._addBoundEvents(reflectedModel)
    this._addUnboundEvents(reflectedModel)
  }

  /**
   * Find all bound actions and functions.
   * Add them as static functions to this instance.
   * @param reflectedModel
   * @private
   */
  _addBoundEvents (reflectedModel) {
    const entities = reflectedModel.all(element => {
      return element.kind === 'entity' && element.actions
    })

    for (const entity of entities) {
      for (const name of Object.keys(entity.actions)) {
        this._createFunctionsAndActions(name, entity.actions[name], entity)
      }
    }
  }

  /**
   * Find all unbound actions and functions.
   * Add them as static functions to this instance.
   * @param reflectedModel {Object}
   * @private
   */
  _addUnboundEvents (reflectedModel) {
    const elements = reflectedModel.all(element => {
      return element.kind === 'action' || element.kind === 'function'
    })

    for (const element of elements) {
      const [, name] = element.name.match(/^(?:.*\.)?([^.]+)$/)
      this._createFunctionsAndActions(name, element)
    }
  }

  /**
   * Create handlers for functions and actions and add them to the instance of the client.
   * @param name {string}
   * @param element {Object}
   * @param [entity] {Object}
   * @private
   */
  _createFunctionsAndActions (name, element, entity) {
    const argsParser = handlerArguments(element, entity)
    const postProcess = handlerPostProcess(element)

    let _context

    this[name] = (...args) => {
      const thenable = {
        with: context => {
          _context = this._startTransactionProperty(context)
          return thenable
        },
        then: (resolve, reject) => {
          return this._eventToService(name, entity, undefined, argsParser(args), _context)
            .then(postProcess)
            .then(resolve)
            .catch(reject)
        },
        catch: reject => {
          return this._eventToService(name, entity, undefined, argsParser(args), _context).catch(reject)
        }
      }

      return thenable
    }
  }

  /**
   * Read an entity and use any prototype function the SELECT API offers.
   * @param entity {Object}
   * @param [columns] {Array}
   * @returns {Promise}
   */
  read (entity, columns) {
    return this._promised('READ', entity, columns)
  }

  /**
   * Insert an entity and use any prototype function the INSERT API offers.
   * @param entity {Object}
   * @returns {Promise}
   */
  insert (entity) {
    return this._promised('CREATE', entity)
  }

  /**
   * Update an entity and use any prototype function the UPDATE API offers.
   * @param entity {Object}
   * @returns {Promise}
   */
  update (entity) {
    return this._promised('UPDATE', entity)
  }

  /**
   * Delete an entity and use any prototype function the DELETE API offers.
   * @param entity {Object}
   * @returns {Promise}
   */
  delete (entity) {
    return this._promised('DELETE', entity)
  }

  /**
   * Run any type of query against the service
   * @param query
   */
  run (query) {
    if (typeof query === 'string') {
      query = cds.parse.cql(query)
    }

    return this._runCqnByService(query)
  }

  _runCqnByService (query) {
    if (!query) {
      return Promise.reject(new FeatureNotSupported())
    }

    if (query.SELECT) {
      return this._cqnToService('READ', this._getEntity(query.SELECT.from), query)
    }

    if (query.INSERT) {
      return this._cqnToService('CREATE', query.INSERT.into, query)
    }

    if (query.UPDATE) {
      return this._cqnToService('UPDATE', query.UPDATE.entity, query)
    }

    if (query.DELETE) {
      return this._cqnToService('DELETE', query.DELETE.from, query)
    }

    return Promise.reject(new FeatureNotSupported())
  }

  _getEntity (from) {
    if (from.hasOwnProperty('join')) {
      from = from.args[0].ref ? from.args[0] : from.args[from.args.length - 1]
    }

    return from.ref[from.ref.length - 1]
  }

  _runCqnAtService (event, entity, query, context) {
    const normalizedEntity = this._validateEntity(entity)

    if (!normalizedEntity) {
      return Promise.reject(new NotInModel(entity, this._cdsService.model.find('service')['@source']))
    }

    return this._eventToService(event, normalizedEntity, query, undefined, context)
  }

  _cqnToService (event, entity, query) {
    let _context

    const thenable = {
      with: context => {
        _context = this._startTransactionProperty(context)
        return thenable
      },
      then: (resolve, reject) => {
        return this._runCqnAtService(event, entity, query, _context)
          .then(resolve)
          .catch(reject)
      },
      catch: reject => this._runCqnAtService(event, entity, query, _context).catch(reject)
    }

    return thenable
  }

  /**
   * Lazy loading and decoration of QL API.
   * @returns {Object}
   * @private
   */
  get _statements () {
    const { statements: { SELECT, INSERT, UPDATE, DELETE } } = require('@sap/cds-ql')
    const statements = {
      SELECT: {
        from: (entity, columns) => {
          return SELECT.from(entity, columns, this._cdsService.reflected)
        },
        one: (entity, columns) => {
          return SELECT.one(entity, columns, this._cdsService.reflected)
        }
      },
      INSERT: INSERT,
      UPDATE: UPDATE,
      DELETE: DELETE
    }

    Object.defineProperty(this, '_statements', { value: statements })

    return statements
  }

  _startTransactionProperty (context) {
    if (!context._) {
      context._ = {}
    }

    // Batch request request
    if (context._.doNotFinishTransaction) {
      if (!context._[OPEN_REQUESTS]) {
        context._[IS_BATCH] = true
      } else {
        context._[OPEN_REQUESTS]++
      }
    } else {
      context._.doNotFinishTransaction = true
      context._[OPEN_REQUESTS] = 1
    }

    return context
  }

  /**
   * Extend an QL API object instance to be a promise.
   * If then or catch are used, the query is run against the data source.
   * @param event {String}
   * @param entity {Object}
   * @param [columns] {Array}
   * @returns {Promise}
   * @private
   */
  _promised (event, entity, columns) {
    const normalizedEntity = this._validateEntity(entity)

    if (!normalizedEntity) {
      return this._errorReturn(event, entity)
    }

    const cqn = this._getCQN(event, normalizedEntity, columns)

    let _context

    cqn.with = context => {
      _context = this._startTransactionProperty(context)

      return cqn
    }
    cqn.then = (resolve, reject) => {
      return this._eventToService(event, normalizedEntity, cqn, undefined, _context)
        .then(resolve)
        .catch(reject)
    }
    cqn.catch = reject => {
      return this._eventToService(event, normalizedEntity, cqn, undefined, _context).catch(reject)
    }

    return cqn
  }

  /**
   * Simulate a rejected promise with a thenable in cases the entity is unknown.
   * @param event {String}
   * @param entity {Object}
   * @returns {Object}
   * @private
   */
  _errorReturn (event, entity) {
    const rejected = Promise.reject(
      new NotInModel(
        typeof entity === 'object' ? entity.name : entity,
        this._cdsService.model.find('service')['@source']
      )
    )

    const cqn = this._getCQN(event, 'dummy')
    cqn.with = () => cqn
    cqn.then = (resolve, reject) => {
      return rejected.catch(reject)
    }
    cqn.catch = reject => {
      return rejected.catch(reject)
    }

    return cqn
  }

  /**
   * Try to find the entity or identify the entity given as string.
   * @param entity {Object}
   * @returns {Object|Boolean}
   * @private
   */
  _validateEntity (entity) {
    if (!entity) {
      return false
    }

    const name = typeof entity === 'object' ? entity.name : entity
    const definitions = this._cdsService.model.definitions
    const service = this._cdsService._options.service

    if (definitions[name]) {
      return definitions[name]
    }

    if (definitions[`${service}.${name}`]) {
      return definitions[`${service}.${name}`]
    }

    const parts = name.split('_')

    return parts.length === 1 ? false : this._validateEntity(parts.pop())
  }

  /**
   * The default events for actions and functions are well known.
   * Translate them into constructing calls against the QL API.
   * @param event {String}
   * @param entity {Object}
   * @param [columns] {Array}
   * @returns {Object}
   * @private
   */
  _getCQN (event, entity, columns) {
    switch (event) {
      case 'READ':
        return this._statements.SELECT.from(entity, columns, this._cdsService.model)
      case 'CREATE':
        return this._statements.INSERT.into(entity)
      case 'UPDATE':
        return this._statements.UPDATE(entity)
      case 'DELETE':
        return this._statements.DELETE.from(entity)
    }
  }

  /**
   * Create a context object for the service call.
   * @param [entity] {Object}
   * @param [cqn] {Object}
   * @param [data] {Object}
   * @param [sharedContext] {Object}
   * @returns {*}
   * @private
   */
  _createContextObject (entity, cqn, data, sharedContext) {
    const context = {
      get data () {
        const parsed = data || cqnToData(cqn)
        Object.defineProperty(context, 'data', { value: parsed })
        return parsed
      },
      statements: this._statements,
      _: sharedContext ? sharedContext._ : {}
    }

    if (entity) {
      context.target = entity
    }

    if (cqn) {
      context.query = cqn
    }

    if (sharedContext && sharedContext.run) {
      context.run = sharedContext.run
    }

    if (sharedContext && sharedContext.draftMetadata) {
      context.draftMetadata = sharedContext.draftMetadata
    }

    return context
  }

  _endTransactionProperty (_) {
    if (_[IS_BATCH]) {
      return
    }

    _[OPEN_REQUESTS]--

    if (_[OPEN_REQUESTS] === 0) {
      delete _.doNotFinishTransaction
    }
  }

  /**
   * Dispatch the API call to the underlying service.
   * @param event {String}
   * @param entity {Object}
   * @param cqn {Object}
   * @param [data] {Object}
   * @param [sharedContext] {Object}
   * @returns {Promise<Array>}
   * @private
   */
  _eventToService (event, entity, cqn, data, sharedContext) {
    const context = this._createContextObject(entity, cqn, data, sharedContext)

    return this._cdsService
      .processEvent(event, context)
      .then(result => {
        this._endTransactionProperty(context._)

        return result
      })
      .catch(err => {
        this._endTransactionProperty(context._)

        throw err
      })
  }
}

module.exports = Client
