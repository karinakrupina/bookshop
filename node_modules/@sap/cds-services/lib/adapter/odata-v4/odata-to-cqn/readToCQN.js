const QueryOptions = require('@sap/odata-server').QueryOptions
const getColumns = require('../../../services/utils/columns')
const { isDraftEnabled } = require('../../../services/utils/compositionTree')
const { addKeysToWhere, buildPath, isNavigation, isPathSupported } = require('./selectHelper')
const { FeatureNotSupported } = require('../../../errors')

const expressionToCQN = require('./expressionToCQN')
const orderByToCQN = require('./orderByToCQN')
const selectToCQN = require('./selectToCQN')
const searchToCQN = require('./searchToCQN')
const expandToCQN = require('./expandToCQN')
const applyToCQN = require('./applyToCQN')
const topSkipToCQN = require('./topSkipToCQN')
const topSkipWithPaginationToCQN = require('./topSkipWithPaginationToCQN')

const SUPPORTED_SEGMENT_KINDS = [
  'ENTITY',
  'ENTITY.COLLECTION',
  'NAVIGATION.TO.ONE',
  'NAVIGATION.TO.MANY',
  'PRIMITIVE.PROPERTY',
  'COUNT'
]

const _filter = (uriInfo, queryOptions, cqn) => {
  if (queryOptions && queryOptions.$filter) {
    cqn.where(expressionToCQN(uriInfo.getQueryOption(QueryOptions.FILTER)))
  }
}

const _includeBrackets = string => {
  let quotes = 0

  for (let i = 0, length = string.length; i < length; i++) {
    if (string.charAt(i) === '"' && string.charAt(i - 1) !== '\\') {
      quotes = quotes === 0 ? quotes + 1 : quotes - 1
    }
    if (string.charAt(i) === '(' && quotes === 0) {
      return true
    }
  }

  return false
}

const _search = (reflectedEntity, uriInfo, cqn, queryOptions) => {
  const search = uriInfo.getQueryOption(QueryOptions.SEARCH)
  if (search) {
    if (_includeBrackets(queryOptions.$search)) {
      throw new FeatureNotSupported('Parenthesis operator in query options is not supported')
    }

    const allowedTypes = ['cds.String', 'cds.UUID', 'cds.Date', 'cds.Time', 'cds.DateTime', 'cds.Timestamp']
    const allowedColumns = getColumns(reflectedEntity).filter(column => allowedTypes.includes(column.type))
    const filteredColumns = allowedColumns.filter(column => column['@Search.defaultSearchElement'])
    const columns = filteredColumns.length > 0 ? filteredColumns : allowedColumns

    cqn.where(...searchToCQN(columns.map(column => column.name), search))
  }
}

const _orderby = (uriInfo, queryOptions, cqn) => {
  if (queryOptions) {
    orderByToCQN(cqn.SELECT, uriInfo.getQueryOption(QueryOptions.ORDERBY))
  }
}

const _getKeysFromObject = keysObject => {
  const keys = []
  for (const key of Object.keys(keysObject)) {
    if (keysObject[key].foreignKeys) {
      // OLD CSN
      for (const foreignKey of Object.keys(keysObject[key].foreignKeys)) {
        keys.push(`${key}_${foreignKey}`)
      }
    } else if (keysObject[key].keys) {
      for (const foreignKey of keysObject[key].keys) {
        keys.push(`${key}_${foreignKey.ref[0]}`)
      }
    } else {
      keys.push(key)
    }
  }

  return keys
}

const _select = (queryOptions, keys) => {
  if (queryOptions && queryOptions.$select) {
    const keyColumns = []
    if (keys) {
      keyColumns.push(..._getKeysFromObject(keys))
    }

    return selectToCQN(queryOptions.$select, keyColumns)
  }

  return []
}

const _apply = (uriInfo, queryOptions) => {
  if (queryOptions && queryOptions.$apply) {
    return applyToCQN(uriInfo.getQueryOption(QueryOptions.APPLY))
  }
  return {}
}

const _groupBy = (groupBy, cqn) => {
  if (groupBy && groupBy.length !== 0) {
    for (const col of groupBy) {
      cqn.groupBy(col)
    }
  }
}

const _expand = (maxExpandSize, uriInfo) => {
  const expand = uriInfo.getQueryOption(QueryOptions.EXPAND)

  if (!expand || expand.length === 0) {
    return []
  }

  return expandToCQN(maxExpandSize, expand, uriInfo.getFinalEdmType())
}

const _topSkip = (queryOptions, cqn) => {
  if (queryOptions && (queryOptions.$top || queryOptions.$skip)) {
    topSkipToCQN(cqn, {
      top: queryOptions.$top ? parseInt(queryOptions.$top) : Number.MAX_SAFE_INTEGER,
      skip: queryOptions.$skip ? parseInt(queryOptions.$skip) : undefined
    })
  }
}

const _getPropertyParam = pathSegments => {
  const prop = pathSegments[pathSegments.length - 1].getProperty()
  return prop === null ? [] : [prop.getName()]
}

const _isCollectionOrToMany = kind => {
  return kind === 'ENTITY.COLLECTION' || kind === 'NAVIGATION.TO.MANY'
}

const _isCount = kind => {
  return kind === 'COUNT'
}

/**
 * Transform odata READ request into a CQN object.
 *
 * @param {Object} service - Service, which will process this request.
 * @param {object} context - Contains request information and utility methods like statements.
 * @param {object} req - An odata request.
 * @private
 */
const readToCQN = (service, { statements: { SELECT }, target }, req) => {
  const uriInfo = req.getUriInfo()
  const segments = uriInfo.getPathSegments()
  isPathSupported(SUPPORTED_SEGMENT_KINDS, segments)

  const queryOptions = req.getQueryOptions()
  const reflectedEntity = target
  const entityName = reflectedEntity.name
  const entityParam = isNavigation(segments) ? buildPath(service.name, segments) : target
  const propertyParam = _getPropertyParam(segments)
  const apply = _apply(uriInfo, queryOptions)
  const select = _select(queryOptions, reflectedEntity.keys)
  const expand = _expand(service._options.maxExpandSize, uriInfo)

  // TODO: Correct implementation of the combined apply, select and expand as described in
  // http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/odata-data-aggregation-ext-v4.0.html
  // part 3.16

  propertyParam.push(...select)

  if (apply.aggregations && apply.aggregations.length !== 0) {
    propertyParam.push(...apply.aggregations)
  }

  if (apply.groupBy && apply.groupBy.length !== 0) {
    propertyParam.push(...apply.groupBy)
  }

  if (expand.length !== 0) {
    if (select.length === 0) {
      propertyParam.push(...getColumns(service.model.definitions[entityName]).map(column => column.name))
    }
    propertyParam.push(...expand)
  }

  const cqn = SELECT.from(entityParam, propertyParam.length > 0 ? propertyParam : undefined)

  addKeysToWhere(segments, cqn, isDraftEnabled(service.model.definitions, entityName))

  const kind = segments[segments.length - 1].getKind()

  if (_isCollectionOrToMany(kind) || _isCount(kind)) {
    _filter(uriInfo, queryOptions, cqn)
    _search(reflectedEntity, uriInfo, cqn, queryOptions)
    _groupBy(apply.groupBy, cqn)
  }

  if (_isCollectionOrToMany(kind)) {
    _orderby(uriInfo, queryOptions, cqn)
    _topSkip(queryOptions, cqn)
    topSkipWithPaginationToCQN(uriInfo, cqn)
  }

  return cqn
}

module.exports = readToCQN
