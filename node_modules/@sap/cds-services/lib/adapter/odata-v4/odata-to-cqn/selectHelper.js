const { FeatureNotSupported } = require('../../../errors')

const addKeysToWhere = (segments, cqn, isDraftEnabled) => {
  if (isNavigation(segments)) {
    return
  }

  const keyPredicates = segments[0].getKeyPredicates()
  const keys = {}

  for (const keyPredicate of keyPredicates) {
    if (isDraftEnabled && keyPredicate.getEdmRef().getName() === 'IsActiveEntity') {
      keys['IsActiveEntity'] = { val: keyPredicate.getText() === 'true' } // value checked by odata-v4
    } else {
      keys[keyPredicate.getEdmRef().getName()] = keyPredicate.getText()
    }
  }

  if (Object.keys(keys).length !== 0) {
    cqn.where(keys)
  }
}

const _getKeysFromUriParam = uriParam => `${uriParam.getEdmRef().getName()}=${uriParam.getText()}`

const _keyPredicatesToSegmentKeys = keyPredicates => {
  if (keyPredicates.length === 0) {
    return ''
  }

  return `[${keyPredicates.map(_getKeysFromUriParam).join(',')}]`
}

const buildPath = (serviceName, pathSegments) => {
  return pathSegments
    .filter(s => s.getProperty() === null)
    .map(s => {
      const entitySet = s.getEntitySet()
      const segmentElement = entitySet ? `${serviceName}.${entitySet.getName()}` : s.getNavigationProperty().getName()

      return `${segmentElement}${_keyPredicatesToSegmentKeys(s.getKeyPredicates())}`
    })
    .join(':')
}

const isPathSupported = (supported, pathSegments) => {
  for (const segment of pathSegments) {
    if (!supported.includes(segment.getKind())) {
      throw new FeatureNotSupported(`Request parameter ${segment.getKind()} is not supported`)
    }
  }
}

const isNavigation = pathSegments => {
  return pathSegments.length > 1 && pathSegments[1].getKind().startsWith('NAVIGATION')
}

module.exports = {
  addKeysToWhere,
  buildPath,
  isNavigation,
  isPathSupported
}
