const odata = require('@sap/odata-server')
const ResourceKind = odata.uri.UriResource.ResourceKind
const TransformationKind = odata.uri.Transformation.TransformationKind
const ExpressionKind = odata.uri.Expression.ExpressionKind
const StandardMethod = odata.uri.AggregateExpression.StandardMethod

const { FeatureNotSupported } = require('../../../errors')

const AGGREGATION_METHODS = new Map([
  [StandardMethod.SUM, 'sum'],
  [StandardMethod.MIN, 'min'],
  [StandardMethod.MAX, 'max'],
  [StandardMethod.AVERAGE, 'avg']
])

const _getColumnName = expression => {
  switch (expression.getKind()) {
    case ExpressionKind.MEMBER:
      return expression
        .getPathSegments()[0]
        .getProperty()
        .getName()
    default:
      throw new FeatureNotSupported(`Expression ${expression.getKind()} is not supported`)
  }
}

const checkAggregateExpression = aggregateExpression => {
  if (
    aggregateExpression.getInlineAggregateExpression() ||
    aggregateExpression.getFrom().length ||
    (aggregateExpression.getPathSegments().length &&
      aggregateExpression.getPathSegments()[0].getKind() !== ResourceKind.COUNT)
  ) {
    throw new FeatureNotSupported('Only simple aggregations are supported')
  }
}

const _addAggregation = aggregateExpression => {
  const columnName = _getColumnName(aggregateExpression.getExpression())
  const method = AGGREGATION_METHODS.get(aggregateExpression.getStandardMethod())
  const aggregation = `${method}(${columnName})`
  const alias = aggregateExpression.getAlias()
  if (alias) {
    const column = {}
    column[aggregation] = alias
    return column
  } else {
    return aggregation
  }
}

const _addCount = aggregateExpression => {
  const alias = aggregateExpression.getAlias()
  if (alias) {
    return { 'count(*)': alias }
  } else {
    return 'count(*)'
  }
}

const _createColumnsForAggregateExpressions = aggregateExpressions => {
  let columns = []
  for (const aggregateExpression of aggregateExpressions) {
    checkAggregateExpression(aggregateExpression)
    if (aggregateExpression.getExpression() && aggregateExpression.getStandardMethod() !== null) {
      columns.push(_addAggregation(aggregateExpression))
    } else {
      // checked in checkAggregateExpression to be ResourceKind.COUNT
      columns.push(_addCount(aggregateExpression))
    }
  }
  return columns
}

const _createNavGroupBy = pathSegments => {
  let name = pathSegments[0].getNavigationProperty().getName()
  for (let i = 1; i < pathSegments.length; i++) {
    name += pathSegments[i].getProperty()
      ? '.' + pathSegments[i].getProperty().getName()
      : '.' + pathSegments[i].getNavigationProperty().getName()
  }
  return name
}

/**
 * Add odata apply to a CQN object.
 *
 * @param {string} transformations - odata-v4 transformaion object
 *
 * @private
 */
const applyToCQN = transformations => {
  const res = { groupBy: [], aggregations: [] }
  const transformation = transformations[0]
  switch (transformation.getKind()) {
    case TransformationKind.GROUP_BY:
      if (transformation.getTransformations().length) {
        res.aggregations.push(
          ..._createColumnsForAggregateExpressions(transformation.getTransformations()[0].getExpressions())
        )
      }
      for (const item of transformation.getGroupByItems()) {
        if (item.getPathSegments()[0].getProperty()) {
          const name = item
            .getPathSegments()[0]
            .getProperty()
            .getName()
          res.groupBy.push(name)
        } else if (item.getPathSegments()[0].getNavigationProperty()) {
          res.groupBy.push(_createNavGroupBy(item.getPathSegments()))
        }
      }
      return res
    case TransformationKind.AGGREGATE:
      if (transformation.getExpressions().length) {
        res.aggregations.push(..._createColumnsForAggregateExpressions(transformation.getExpressions()))
      }
      return res
    default:
      throw new FeatureNotSupported(`Transformation ${transformation.getKind()} is not supported`)
  }
}

module.exports = applyToCQN
