const odata = require('@sap/odata-server')
const ExpressionKind = odata.uri.Expression.ExpressionKind
const BinaryOperatorKind = odata.uri.BinaryExpression.OperatorKind
const UnaryOperatorKind = odata.uri.UnaryExpression.OperatorKind
const MethodKind = odata.uri.MethodExpression.MethodKind
const ResourceKind = odata.uri.UriResource.ResourceKind
const EdmPrimitiveTypeKind = odata.edm.EdmPrimitiveTypeKind
const { FeatureNotSupported } = require('../../../errors')

const _binaryOperatorToCQN = new Map()
_binaryOperatorToCQN.set(BinaryOperatorKind.EQ, '=')
_binaryOperatorToCQN.set(BinaryOperatorKind.NE, '!=')
_binaryOperatorToCQN.set(BinaryOperatorKind.GE, '>=')
_binaryOperatorToCQN.set(BinaryOperatorKind.GT, '>')
_binaryOperatorToCQN.set(BinaryOperatorKind.LE, '<=')
_binaryOperatorToCQN.set(BinaryOperatorKind.LT, '<')

const _convert = expression => {
  const type = expression.getType()

  if (!type) {
    return { val: null }
  }

  const value = expression.getText()

  switch (type) {
    case EdmPrimitiveTypeKind.Boolean:
      return { val: value === true || value === 'true' }
    case EdmPrimitiveTypeKind.Byte:
    case EdmPrimitiveTypeKind.SByte:
    case EdmPrimitiveTypeKind.Int16:
    case EdmPrimitiveTypeKind.Int32:
      return { val: parseInt(value) }
    case EdmPrimitiveTypeKind.Decimal:
    case EdmPrimitiveTypeKind.Single:
    case EdmPrimitiveTypeKind.Double:
      return { val: parseFloat(value) }
    default:
      return { val: value }
  }
}

const _segmentFromMember = segment => {
  switch (segment.getKind()) {
    case ResourceKind.PRIMITIVE_PROPERTY:
    case ResourceKind.COMPLEX_PROPERTY:
    case ResourceKind.PRIMITIVE_COLLECTION_PROPERTY:
    case ResourceKind.COMPLEX_COLLECTION_PROPERTY:
      return segment.getProperty().getName()
    case ResourceKind.NAVIGATION_TO_ONE:
      return segment.getNavigationProperty().getName()
    default:
      throw new FeatureNotSupported(`ResourceKind ${segment.getKind()} is not supported`)
  }
}

const _getMemberRecursively = pathSegments => {
  const [segment, ...nextSegments] = pathSegments

  if (segment.getKind() === ResourceKind.NAVIGATION_TO_ONE) {
    return [_segmentFromMember(segment), ..._getMemberRecursively(nextSegments)]
  }

  return [_segmentFromMember(segment)]
}

const _member = expression => ({ ref: _getMemberRecursively(expression.getPathSegments()) })

const _getParameters = expression => {
  return expression.getParameters().map(parameter => {
    return expressionToCQN(parameter)
  })
}

const _like = (column, value, operator) => {
  return [column, operator ? 'not like' : 'like', value]
}

const _genericFn = (methodName, args) => {
  return { ref: [methodName, { args }] }
}

const _throwIfSecondArgumentIsNotSupported = param => {
  if (param.getKind() === ExpressionKind.METHOD) {
    throw new FeatureNotSupported(`Functions are not yet supported as second parameter`)
  }

  if (param.getKind() === ExpressionKind.MEMBER) {
    throw new FeatureNotSupported(`Properties are not yet supported as second parameter`)
  }
}

/**
 * Evaluate an method expression, which in SQL would be 'column condition value'.
 * Can also be nested.
 * @param {Object} expression
 * @param {string} [operator] - Operator, that might be used to invert a method or similar
 * @private
 */
const _method = (expression, operator) => {
  const parameters = _getParameters(expression)
  switch (expression.getMethod()) {
    case MethodKind.CONTAINS:
      _throwIfSecondArgumentIsNotSupported(expression.getParameters()[1])
      return _like(parameters[0], { val: `%${parameters[1].val}%` }, operator)
    case MethodKind.STARTSWITH:
      _throwIfSecondArgumentIsNotSupported(expression.getParameters()[1])
      return _like(parameters[0], { val: `${parameters[1].val}%` }, operator)
    case MethodKind.ENDSWITH:
      _throwIfSecondArgumentIsNotSupported(expression.getParameters()[1])
      return _like(parameters[0], { val: `%${parameters[1].val}` }, operator)
    case MethodKind.NOW:
      return { val: new Date(Date.now()).toISOString() }
    case MethodKind.TOUPPER:
      return _genericFn('upper', parameters)
    case MethodKind.TOLOWER:
      return _genericFn('lower', parameters)
    case MethodKind.TRIM:
    case MethodKind.LENGTH:
      return _genericFn(expression.getMethod(), parameters)
    default:
      throw new FeatureNotSupported(`Method ${expression.getMethod()} is not supported`)
  }
}

const _compare = (operator, left, right) => {
  return [left, _binaryOperatorToCQN.get(operator), right]
}

const _binary = expression => {
  const operator = expression.getOperator()
  const left = expressionToCQN(expression.getLeftOperand())
  const right = expressionToCQN(expression.getRightOperand())

  switch (operator) {
    case BinaryOperatorKind.AND:
      return [...left, 'and', ...right]
    case BinaryOperatorKind.OR:
      return ['(', ...left, 'or', ...right, ')']
    case BinaryOperatorKind.EQ:
    case BinaryOperatorKind.NE:
    case BinaryOperatorKind.GE:
    case BinaryOperatorKind.GT:
    case BinaryOperatorKind.LE:
    case BinaryOperatorKind.LT:
      return _compare(operator, left, right)
    default:
      throw new FeatureNotSupported(`BinaryOperator ${expression.getOperator()} is not supported`)
  }
}

const _unary = expression => {
  if (expression.getOperator() !== UnaryOperatorKind.NOT) {
    throw new FeatureNotSupported(`UnaryOperator ${expression.getOperator()} is not supported`)
  }

  return expressionToCQN(expression.getOperand(), UnaryOperatorKind.NOT)
}

/**
 * Convert a odata-v4 filter expression object into a CQN object.
 *
 * @param {Object} expression - odata filter expression
 * @param {string} [operator] - Operator, that might be used to invert a method or similar
 * @private
 */
const expressionToCQN = (expression, operator) => {
  switch (expression.getKind()) {
    case ExpressionKind.ALIAS:
      return expressionToCQN(expression.getExpression())
    case ExpressionKind.BINARY:
      return _binary(expression)
    case ExpressionKind.LITERAL:
      return _convert(expression)
    case ExpressionKind.MEMBER:
      return _member(expression)
    case ExpressionKind.METHOD:
      return _method(expression, operator)
    case ExpressionKind.UNARY:
      return _unary(expression)
    default:
      throw new FeatureNotSupported(`Expression ${expression.getKind()} is not supported`)
  }
}

module.exports = expressionToCQN
