const {
  QueryOptions,
  Components: { DATA_READ_HANDLER },
  uri: { UriResource: { ResourceKind: { BOUND_FUNCTION, COUNT, FUNCTION_IMPORT, NAVIGATION_TO_ONE } } }
} = require('@sap/odata-server')

const { getError } = require('../../../errors')
const getContextObject = require('../utils/context-object')
const { isCustomOperation, maxPageSize, skipToken } = require('../utils/request')
const { toODataResult } = require('../utils/event')
const { validateResourcePathLength } = require('../utils/request')

/**
 * Checks whether a bound function or function import is invoked.
 * @param {Array} segments - The uri path segments of the request.
 * @returns {boolean} - True if a function is invoked, else false.
 * @private
 */
const _isFunction = segments => [BOUND_FUNCTION, FUNCTION_IMPORT].includes(segments[segments.length - 1].getKind())

/**
 * Get the name of the function which will be used as event name at the service.
 * @param {Object} context
 * @param {Object} lastSegment
 * @returns {string}
 * @private
 */
const _getEventName = (context, lastSegment) => {
  const invokedFunction = lastSegment.getFunction()

  return context.target ? invokedFunction.getName() : invokedFunction.getFullQualifiedName().toString()
}

/**
 * Check which type needs to be returned. If the result is not of this type, convert.
 * @param {Object} lastSegment
 * @param {*} result
 * @returns {string|Object}
 * @private
 */
const _convertResult = (lastSegment, result) => {
  if (!Array.isArray(result) && lastSegment.isCollection()) {
    return toODataResult([result])
  }

  if (Array.isArray(result) && !lastSegment.isCollection()) {
    return toODataResult(result[0])
  }

  return toODataResult(result)
}

/**
 * Invoke a function.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _invokeFunction = (service, context, segments) => {
  const lastSegment = segments[segments.length - 1]
  const functionName = _getEventName(context, lastSegment)
  return service.processEvent(functionName, context).then(result => {
    return _convertResult(lastSegment, result)
  })
}

/**
 * Checks whether a count of entities is requested
 * (not count embedded into collection).
 * @param {Array} segments - The uri path segments of the request.
 * @returns {boolean} - True if a count of entities is requested, else false.
 * @private
 */
const _isCount = segments => {
  return segments[segments.length - 1].getKind() === COUNT
}

/**
 * Get the count by using the general READ CQN and alter it to a COUNT query.
 * @param {Object} service
 * @param {Object} readContext
 * @param {boolean} shareContext
 * @return {Promise}
 * @private
 */
const _getCount = (service, readContext, shareContext = false) => {
  // Copy CQN including from and where and changing columns
  const select = readContext.statements.SELECT.from(readContext.query.SELECT.from, [{ 'COUNT(1)': 'counted' }])

  if (readContext.query.SELECT.where) {
    select.SELECT.where = readContext.query.SELECT.where
  }

  const context = shareContext ? Object.assign({}, readContext) : readContext

  // remove as Object.defineProperty would cause a conflict
  delete context.query

  // Define new CQN
  context.query = select

  return (
    service
      .processEvent('READ', context)
      // Transform into scalar result
      .then(result => {
        return result[0] && result[0].counted ? result[0].counted : 0
      })
  )
}

/**
 * Checks whether a collection of entities or a single entity is requested.
 * Returns false in case of a custom operation.
 * @returns {boolean} - True if a collection of entities is requested, else false.
 * @private
 */
const _isCollection = segments => {
  const lastEntitySegment = Array.from(segments)
    .reverse()
    .find(segment => segment.getProperty() === null)
  const kind = lastEntitySegment.getKind()

  return (
    !isCustomOperation(segments) &&
    kind !== NAVIGATION_TO_ONE &&
    kind !== COUNT &&
    lastEntitySegment.getKeyPredicates().length === 0
  )
}

/**
 * Checks whether the count needs to be included in the result set as an annotation.
 * @param {Object} req - The odata-v4 request.
 * @returns {boolean}
 * @private
 */
const _checkIfCountToBeIncluded = req => {
  return req.getUriInfo().getQueryOption(QueryOptions.COUNT)
}

/**
 * Checks whether single entity via navigation-to-one is requested.
 * @returns {boolean}
 * @private
 */
const _isNavigationToOne = segments => {
  return segments[segments.length - 1].getKind() === NAVIGATION_TO_ONE
}

/**
 * Reading the full entity or only a property of it is alike.
 * In case of an entity, odata-v4 wants the value an object structure,
 * in case of a property as scalar.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _readEntityOrProperty = (service, context, segments) => {
  return service.processEvent('READ', context).then(result => {
    // TODO: Check wether source entity exists
    if (result.length === 0 && _isNavigationToOne(segments)) {
      return toODataResult(null)
    }

    // Reading one entity or a property of it should yield only a result length of one.
    if (result.length !== 1) {
      throw getError(404)
    }

    const propertyElement = segments[segments.length - 1].getProperty()

    return toODataResult(propertyElement === null ? result[0] : result[0][propertyElement.getName()])
  })
}

/**
 * Read an entity collection without including the count of the total amount of entities.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionNoCount = (service, context, req) => {
  return service.processEvent('READ', context).then(result => {
    const modifiedResult = toODataResult(result)
    const pageSize = maxPageSize(req.getUriInfo().getPathSegments())

    if (pageSize && result.length === pageSize) {
      modifiedResult['*@odata.nextLink'] = skipToken(req.getUriInfo()) + pageSize
    }

    return modifiedResult
  })
}

/**
 * Read an entity collection and include the count count of the total amount of entities.
 * odata-v4 wants the count to be added as annotation.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionWithCount = (service, context, req) => {
  // When there is a limit, there might be need for getting the actual value
  if (context.query.SELECT.limit) {
    // Share one db client for both service request if not already batched
    let finishTransaction = false

    if (context.run && !context._.doNotFinishTransaction) {
      finishTransaction = true // not in batch
      context._.doNotFinishTransaction = true // still use the same pool connection for all db queries
    }

    // Request the count and collection in parallel
    return Promise.all([_readCollectionNoCount(service, context, req), _getCount(service, context, true)]).then(
      ([result, count]) => {
        result['*@odata.count'] = count

        // End transaction block in case of non batch
        if (finishTransaction && context._.endTransactionIfConnected) {
          delete context._.doNotFinishTransaction // not in batch: finish transaction manually as bellow

          return context._.endTransactionIfConnected('COMMIT', context).then(() => {
            return result
          })
        }

        return result
      }
    )
  }

  // No limit, use the length property
  return _readCollectionNoCount(service, context, req).then(result => {
    result['*@odata.count'] = result.value.length

    return result
  })
}

/**
 * Depending on the read request segments, create one ore more reading service request.
 * @param {Object} service
 * @param {Object} req
 * @param {Object} res
 * @return {Promise}
 * @private
 */
const _readAndTransform = (service, req, res) => {
  const context = getContextObject(DATA_READ_HANDLER, service, req, res)
  const segments = req.getUriInfo().getPathSegments()

  if (_isFunction(segments)) {
    return _invokeFunction(service, context, segments)
  }

  // Scalar count is requested
  if (_isCount(segments)) {
    return _getCount(service, context).then(result => {
      return toODataResult(result)
    })
  }

  if (_isCollection(segments)) {
    if (_checkIfCountToBeIncluded(req)) {
      return _readCollectionWithCount(service, context, req)
    }

    return _readCollectionNoCount(service, context, req)
  }

  return _readEntityOrProperty(service, context, segments)
}

/**
 * The handler that will be registered with odata-v4.
 *
 * If an entity collection is read, it calls next with result as an Array with all entities of the collection.
 * If a count of the entities in the collection is requested, it uses number of the entities as a Number value.
 * If an single entity is read, it uses the entity as an object.
 * If a property of a single entity is requested (e.g. /Books(1)/name), it unwraps the property from the result.
 * If the single entity to be read does not exist, calls next with error to return a 404.
 * In all other failure cases it calls next with error to return a 500.
 *
 * @param {Service} service
 * @param {Object} options
 * @return {Function}
 */
const read = (service, options) => {
  return (req, res, next) => {
    // End here if length is greater then allowed
    validateResourcePathLength(req, options)

    // Get the service result(s) and hand them over the odata-v4
    _readAndTransform(service, req, res)
      .then(result => {
        next(null, result)
      })
      .catch(err => {
        next(err)
      })
  }
}

module.exports = read
