const {
  Components: { DATA_DELETE_HANDLER, DATA_READ_HANDLER, DATA_CREATE_HANDLER, DATA_UPDATE_HANDLER }
} = require('@sap/odata-server')
const { isCustomOperation } = require('./request')
const odataToCQN = require('../odata-to-cqn/odataToCQN')
const getAnnotatedElements = require('../../utils/getAnnotatedElements')
const getStatements = require('../../utils/getStatements')
const { addDefaultValuesDeep } = require('../../../util/dataProcessUtils')

const _isFunctionInvocation = req =>
  req.getUriInfo().getLastSegment().getFunction || req.getUriInfo().getLastSegment().getFunctionImport

const _getTypeName = edmRef =>
  edmRef.getProperty
    ? edmRef
      .getProperty()
      .getType()
      .getName()
    : edmRef.getType().getName()

/**
 * The key predicates or function parameters will contain the keys and values for this request.
 * Combine all key value pairs into one object.
 * @param parameters
 * @returns {Object}
 * @private
 */
const _getParamData = parameters => {
  const paramData = {}

  for (const segmentParam of parameters) {
    const edmRef = segmentParam.getEdmRef()
    const typeName = _getTypeName(edmRef)

    // Convert any integer type into numeric values.
    paramData[edmRef.getName()] = typeName.startsWith('Int') ? Number(segmentParam.getText()) : segmentParam.getText()
  }

  return paramData
}

const _addForeignKeys = (req, data) => {
  // retrieve keys/values from the path segment representing the navigation source
  const navSourceSegment = req.getUriInfo().getPathSegments()[req.getUriInfo().getPathSegments().length - 2]
  const navSourceKeyValues = _getParamData(navSourceSegment.getKeyPredicates())

  // retrieve relevant foreign key properties of the target entity, including the corresponding source key properties
  const refConstraints = req
    .getUriInfo()
    .getLastSegment()
    .getNavigationProperty()
    .getPartner()
    .getReferentialConstraints()
  let refConstraint

  // set value of foreign key properties as specified in the navigation source segment
  for (const key of Object.keys(navSourceKeyValues)) {
    refConstraint = [...refConstraints].find(r => r[1].constraint.referencedProperty === key)
    // exclude source keys if they cannot be matched (e.g. isActiveEntity in draft scenario)
    if (refConstraint) {
      data[refConstraint[0]] = navSourceKeyValues[key]
    }
  }
}

/**
 * Get data from odata-v4.
 * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
 * For function invocations the URL parameters are set as data.
 * For CREATE and UPDATE annotated columns can be mixed in.
 *
 * @param {string} component - odata-v4 component which processes this request.
 * @param req
 * @param annotatedColumns - in case of insert and update we might have annotated columns for user/now
 * @returns {Object}
 * @private
 */
const _getData = (component, req, annotatedColumns, target) => {
  const lastSegment = req.getUriInfo().getLastSegment()
  const keyPredicates = lastSegment.getKeyPredicates()
  const keyValues = _getParamData(keyPredicates)

  if (component === DATA_READ_HANDLER && _isFunctionInvocation(req)) {
    const functionParameters = lastSegment.getFunctionParameters()
    const paramValues = _getParamData(functionParameters)

    // Working assumption for the case of name collisions: take the entity's key
    for (const key of Object.keys(keyValues)) {
      paramValues[key] = keyValues[key]
    }
    return paramValues
  }

  if (component === DATA_DELETE_HANDLER || component === DATA_READ_HANDLER) {
    return keyValues
  }

  // Use identifier from URL instead of body
  const data = req.getBody() || {}

  // Only to be done for post via navigation
  if (component === DATA_CREATE_HANDLER && lastSegment.getKind() === 'NAVIGATION.TO.MANY') {
    _addForeignKeys(req, data)
  }

  for (const key of Object.keys(keyValues)) {
    data[key] = keyValues[key]
  }

  for (const column of annotatedColumns) {
    data[column.name] = column.value
  }

  if (target && (req.getMethod() === 'POST' || req.getMethod() === 'PUT')) {
    addDefaultValuesDeep(data, target)
  }
  return data
}

const _getAnnotatedColumns = (component, context) => {
  switch (component) {
    case DATA_CREATE_HANDLER:
      return getAnnotatedElements('insert', context)
    case DATA_UPDATE_HANDLER:
      return getAnnotatedElements('update', context)
    default:
      return []
  }
}

/**
 * In case of batch request use the applicationData object as base,
 * else create a new object.
 * @param {Object} req - odata-v4 request object.
 * @param {Object} res - odata-v4 response object.
 * @return {Object}
 * @private
 */
const _getUnderscore = (req, res) => {
  let _ = req.getBatchApplicationData()

  // If batched, and first event of the batch, add indicator, to reuse the same db client.
  if (_ && _.doNotFinishTransaction === undefined) {
    _.doNotFinishTransaction = true
  }

  // Not batched, create object, that can be shared later on and will hold channel specifc details in any case.
  if (!_) {
    _ = {}
  }

  _.odataReq = req
  _.odataRes = res

  // Give the app developer access to the original (express) request object
  if (!_.req) {
    _.req = req.getIncomingRequest()
  }

  return _
}

/**
 * Try to find the name of the source entity at the services CSN.
 * @param {Object} service
 * @param {string} name
 * @returns {string}
 * @private
 */
const _findSourceEntityNameAtService = (service, name) => {
  return name === 'DRAFT.DraftAdministrativeData'
    ? service.model.find(element => {
      return (
        (element.query && element.query.target && element.query.target.name === name) ||
          (element.name !== 'DRAFT.DraftAdministrativeData' && element.source === name)
      ) // OLD CSN
    }).name
    : name
}

/**
 * Gets the name of the service entity targeted by the given navigation path.
 * Undefined in case of a function or action import.
 * @param {Service} service
 * @param {Array} pathSegments - The path segments of a uri.
 * @returns {string} - The name of the navigation target entity.
 * @private
 */
const _getTargetEntityName = (service, pathSegments) => {
  if (isCustomOperation(pathSegments, false)) {
    return undefined
  }

  /*
   * The cds.deploy does not create views in case of SQLite.
   * We need to go to the sources in case of projections.
   * TODO: Use the entity directly, once views are deployed.
   */
  let navSegmentName
  let entityName = `${service.name}.${pathSegments[0].getEntitySet().getName()}`

  for (const navSegment of pathSegments.filter(segment => segment.getNavigationProperty() !== null)) {
    navSegmentName = navSegment.getNavigationProperty().getName()
    entityName =
      navSegmentName === 'DraftAdministrativeData'
        ? 'DRAFT.DraftAdministrativeData'
        : service.model.definitions[entityName].elements[navSegmentName].target
  }

  return _findSourceEntityNameAtService(service, entityName)
}

const getContextObject = (component, service, req, res) => {
  const pathSegments = req.getUriInfo().getPathSegments()

  const context = {
    get data () {
      const annotatedColumns = _getAnnotatedColumns(component, this)
      const data = _getData(component, req, annotatedColumns, this.target)
      Object.defineProperty(context, 'data', { value: data, writable: true })
      return data
    },
    set data (value) {
      Object.defineProperty(context, 'data', { value: value, writable: true })
    },
    get query () {
      const query = odataToCQN(isCustomOperation(pathSegments) || component, service, context, req)
      Object.defineProperty(context, 'query', { value: query, writable: true })
      return query
    },
    set query (value) {
      Object.defineProperty(context, 'query', { value: value, writable: true })
    },
    get target () {
      const pathSegments = req.getUriInfo().getPathSegments()
      const definitions = service.model.definitions
      const target = definitions[_getTargetEntityName(service, pathSegments)]

      Object.defineProperty(context, 'target', { value: target })

      return target
    },
    get statements () {
      const statements = getStatements(service)

      Object.defineProperty(context, 'statements', { value: statements })

      return statements
    },
    _: _getUnderscore(req, res)
  }

  return context
}

module.exports = getContextObject
