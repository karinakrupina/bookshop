const { NextCalledBefore } = require('../../errors')

const { isDraftEnabled, isDraftRootEntity } = require('../utils/compositionTree')
const isSelectEntity = require('../utils/selectEntityUtils')

const Base = require('./Base')

const CALLED = Symbol.for('continuationCalled')

/**
 * Class representation of on middleware.
 * @augments Base
 * @alias module:hooks.On
 */
class On extends Base {
  _calculateDefaultHandlerCount (definition, model, isDraftEnabledService) {
    const { getDefaultHandlers } = require('../utils/defaultHandlers')
    const { getScenario } = require('../utils/handlerUtils')

    return getDefaultHandlers(
      isDraftEnabledService,
      isDraftEnabled(model.definitions, definition.name),
      isDraftRootEntity(model.definitions, definition.name),
      definition.name
    ).get(getScenario(definition)).on.size
  }

  /**
   * Constructs the on middleware handler.
   * @param {object} model - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   */
  constructor (model, service = '') {
    super(model, service)

    // fail handler
    this._defaultHandlerCount = 1

    const regex = new RegExp(`^${service.replace(/\./g, '\\.')}\\.\\w+$`)

    const isDraftEnabledService = Object.keys(model.definitions).some(
      key => model.definitions[key]['@odata.draft.enabled']
    )

    // Sum up the to be registered generic handlers.
    model.find(definition => {
      if (
        (definition.kind === 'entity' || isSelectEntity(definition, this._model)) && // OLD CSN: isSelectEntity
        definition.name.match(new RegExp(regex))
      ) {
        this._defaultHandlerCount += this._calculateDefaultHandlerCount(definition, model, isDraftEnabledService)
      }
    })
  }

  _addHandler (event, entity, handler) {
    if (this._handlers.length < this._defaultHandlerCount) {
      this._handlers.push({ event, entity, handler })
    } else {
      this._handlers.splice(this._handlers.length - this._defaultHandlerCount, 0, { event, entity, handler })
    }
  }

  /**
   * Check if a handler is registered for event and entity. Execute the handler that is registered,
   * with request and response as input parameter to the handler.
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .send(), .error(), ...
   * @param {string} context.target - the unreflected entity
   * @returns {Promise}
   */
  executeHandlerIfListed (event, context) {
    return new Promise((resolve, reject) => {
      this._addReply(resolve, context)
      this._addReject(reject, context)
      this._middleware(event, context, reject)
    })
  }

  _middleware (event, context, reject) {
    const calledFrom = {}
    const length = this._handlers.length

    let i = 0

    // Recursive function, which will work with closures i and length
    const next = (err, calledFromHandler) => {
      // Throw error if next is called twice from same handler
      if (calledFrom[calledFromHandler]) {
        throw new NextCalledBefore()
      }

      calledFrom[calledFromHandler] = true

      // Explicit end of chain by handler
      if (err) {
        reject(err)
        return
      }

      // Stop the chain, as reply has been called before
      if (context[CALLED]) {
        return
      }

      let handler

      // Check all registered handlers if registered for this event.
      while (i < length) {
        // Copy count and use to identify
        const count = i
        let nextCalled = false

        const nextOnce = err => {
          nextCalled = true
          return next(err, count)
        }

        handler = this._handlers[i]
        i++

        // We have to catch in order to be able to release the DB client.
        if (this._match(event, context, handler)) {
          try {
            this._handleLayerReturn(context, nextOnce, handler.handler(context, nextOnce), reject, nextCalled)
            return
          } catch (err) {
            reject(err)
            return
          }
        }
      }
    }

    next(null, -1)
  }

  /**
   * (a)sync code might be in place which can be expressed in various forms.
   * If a return is given, provide convenience.
   * @private
   */
  _handleLayerReturn (context, next, layerReturn, reject, nextWasCalled) {
    // Promise or equaly behaving thenables.
    if (layerReturn && layerReturn.then) {
      this._handleThanables(context, next, layerReturn, reject)
      return
    }

    // CQN means, we should run it
    if (this._isCQN(layerReturn)) {
      this._handleThanables(context, next, context.run(layerReturn), reject)
      return
    }

    //  This will break if a user calls next() inside setTimeout without returning a promise (not supported)
    if (layerReturn === undefined && !nextWasCalled && !context[CALLED]) {
      next()
      return
    }

    // A result is returned, that marks the end of the chain
    if (layerReturn !== undefined && typeof layerReturn !== 'function' && !context[CALLED]) {
      try {
        this._handleErrors(context)
      } catch (err) {
        reject(err)
      }

      context.reply(layerReturn)
    }
  }

  /**
   * The app dev decided to handle async processes on its own.
   * The result should be the end of the chain.
   * @private
   */
  _handleThanables (context, next, promise, reject) {
    return promise
      .then(result => {
        // app developer called .reply in the meantime. This check prevents double execution
        if (context[CALLED]) {
          return
        }

        context.reply(this._handleErrors(context, result))
      })
      .catch(reject)
  }
}

module.exports = On
