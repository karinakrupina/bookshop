const { getError, EventHandlerNotDefined, NotInModel } = require('../../errors')
const isSelectEntity = require('../utils/selectEntityUtils')
const { isDraftEnabled } = require('../utils/compositionTree')

const DEFAULT_EVENTS = [
  'BEFORE_CREATE',
  'CREATE',
  'BEFORE_CREATE_DRAFT',
  'CREATE_DRAFT',
  'DELETE',
  'READ',
  'UPDATE',
  'UPDATE_DRAFT',
  'COMMIT',
  'ROLLBACK'
]
const CRUD_EVENTS = ['READ', 'CREATE', 'UPDATE', 'DELETE']
const TRANSACTION_EVENTS = ['COMMIT', 'ROLLBACK']
const CALLED = Symbol.for('continuationCalled')

/**
 * Base class for hooks middleware.
 */
class Base {
  /**
   * Constructs a middleware handler.
   * @param {object} reflected - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   */
  constructor (reflected, service) {
    this._handlers = []
    this._model = reflected
    this._service = service
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string|Array} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', or an array of events
   * @param {string|Object} [entity] - Name of the entity or CSN entity, or an array of entities.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   */
  use (event, entity, handler) {
    const input = this._normalizeUseArgs({ arg1: event, arg2: entity, arg3: handler })
    this._replaceWildcardsFromInput(input)
    this._validateInput(input)
    this._addHandlerFromInput(input)
  }

  _validateInput (input) {
    this._handlerParamValid(input.handler)

    if (input.events) {
      for (const event of input.events) {
        if (input.entities) {
          for (const entity of input.entities) {
            this._entityParamValid(entity)
            this._eventParamValid(event, entity)
          }
        } else {
          this._eventParamValid(event, undefined)
        }
      }
    }
  }

  _addHandlerFromInput (input) {
    if (!input.events && !input.entities) {
      this._addHandler(undefined, undefined, input.handler)
      return
    }

    if (!input.entities && input.events) {
      for (const event of input.events) {
        this._addHandler(event, undefined, input.handler)
      }
      return
    }

    if (input.entities && input.events) {
      for (const event of input.events) {
        for (const entity of input.entities) {
          this._addHandler(event, entity, input.handler)
        }
      }
    }
  }

  _replaceWildcardsFromInput (input) {
    if (input.events) {
      if (input.events.includes('*')) {
        input.events = CRUD_EVENTS
        if (input.entities) {
          for (const entity of input.entities) {
            input.events.push(...this._entityBoundActions(entity))
          }
        } else {
          input.events = undefined
        }
      }
    }
  }

  _normalizeUseArgs ({ arg1, arg2, arg3 }) {
    if (arg3 && !arg2) {
      ;[arg2, arg3] = [arg3, arg2]
    }

    const handler = this._generateHandlerIfCQN(arg3 || arg2 || arg1)
    let events
    let entities

    if (arg1 && arg2 && arg3) {
      events = this._ensureArray(arg1).map(event => this._normalizeEvent(event))
      entities = this._ensureArray(arg2).map(entity => this._objectEntityToString(entity))
    }

    if (arg1 && arg2 && !arg3) {
      const _eventsOrEntities = this._ensureArray(arg1)
      if (_eventsOrEntities.length !== 0) {
        if (this._isModeledEntity(this._objectEntityToString(_eventsOrEntities[0]))) {
          entities = _eventsOrEntities.map(entity => this._objectEntityToString(entity))
          events = ['*']
        } else {
          events = _eventsOrEntities.map(event => this._normalizeEvent(event))
        }
      } else {
        // It's not clear if the empty array represents events or entities.
        // Assume both are empty.
        events = []
        entities = []
      }
    }
    return { events, entities, handler }
  }

  _normalizeEvent (event) {
    const eventToFullyQualified = this._eventToFullyQualified(event)
    if (this._isUnboundCustomOperation(eventToFullyQualified)) {
      return eventToFullyQualified
    }
    return event
  }

  _ensureArray (something) {
    return Array.isArray(something) ? something : [something]
  }

  _generateHandlerIfCQN (handler) {
    if (this._isCQN(handler)) {
      return context => {
        return context.run(handler)
      }
    }

    return handler
  }

  _eventToFullyQualified (event) {
    if (!this._isDefaultEvent(event) && typeof event === 'string') {
      return event.startsWith(this._service) ? event : `${this._service}.${event}`
    }
    return event
  }

  _objectEntityToString (entity) {
    if (typeof entity === 'object') {
      return (entity.kind === 'entity' || isSelectEntity(entity, this._model)) && // OLD CSN: isSelectEntity
        entity.name
        ? entity.name
        : false
    }

    if (typeof entity === 'string' && !entity.startsWith(this._service)) {
      return `${this._service}.${entity}`
    }

    return entity
  }

  _entityBoundActions (entity) {
    entity = this._objectEntityToString(entity)
    const objectEntity = entity && this._model.find(d => d.kind === 'entity' && d.name === entity)
    return objectEntity ? Object.keys(objectEntity.actions || {}) : []
  }

  _isCQN (object) {
    if (!object || typeof object !== 'object') {
      return false
    }

    if (object.SELECT) {
      return true
    }
    if (object.INSERT) {
      return true
    }
    if (object.UPDATE) {
      return true
    }

    return Boolean(object.DELETE)
  }

  /**
   * Basic check if the specified entity is a valid parameter for the event handler.
   * @param {string} entity - Entity parameter
   * @private
   */
  _entityParamValid (entity) {
    // Check if provided entity is defined in the reflection model
    if (typeof entity !== 'string' || !this._isModeledEntity(entity)) {
      throw new NotInModel(entity === false ? undefined : entity, this._model.find('service')['@source'])
    }
  }

  _isDefaultEvent (event) {
    return DEFAULT_EVENTS.includes(event)
  }

  _isTransactionEvent (event) {
    return TRANSACTION_EVENTS.includes(event)
  }

  /**
   * Basic check if the specified event is a valid parameter for the event handler.
   * @param {string} event - Event parameter
   * @param {string} [entity] - Entity parameter
   * @private
   */
  _eventParamValid (event, entity) {
    // Check validity of custom operations
    if (event && !this._isDefaultEvent(event)) {
      // Check if provided unbound custom operation is contained in the reflection model
      if (entity === undefined && !this._isUnboundCustomOperation(event)) {
        throw new NotInModel(event, this._model.find('service')['@source'])
      }

      // Check if provided bound custom operation is defined within the provided entity in the reflection model
      if (entity !== undefined && !this._isBoundCustomOperation(entity, event)) {
        throw new NotInModel(event, this._model.find('service')['@source'])
      }
    }
  }

  /**
   * Basic check if the specified handler is a valid parameter for the event handler.
   * @param {function} handler - Handler parameter
   * @private
   */
  _handlerParamValid (handler) {
    // Check if provided handler param has wrong type
    if (typeof handler !== 'function') {
      throw new EventHandlerNotDefined()
    }
  }

  /**
   * Checks whether or not an entity exists in the reflection model.
   * @param entity
   * @returns {boolean}
   * @private
   */
  _isModeledEntity (entity) {
    const serviceEntity = entity.startsWith(this._service) ? entity : `${this._service}.${entity}`
    return (
      this._model.find(
        d =>
          (d.kind === 'entity' || isSelectEntity(d, this._model)) && // OLD CSN: isSelectEntity
          d.name === serviceEntity
      ) !== undefined
    )
  }

  /**
   * Checks whether or not a provided event exists as unbound custom operation in the reflection model.
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isUnboundCustomOperation (event) {
    return this._model.find(d => ['action', 'function'].includes(d.kind) && d.name === event) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as bound custom operation in the reflection model.
   * @param {string} entity
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isBoundCustomOperation (entity, event) {
    return (
      this._model.find(
        d =>
          d.kind === 'entity' &&
          d.name === entity &&
          ((d.actions && d.actions[event]) || this._isDraftAction(event, entity))
      ) !== undefined
    )
  }

  // TODO remove if draftPrepare, draftEdit and draftActivate actions are part of the new CSN
  _isDraftAction (event, entity) {
    return (
      isDraftEnabled(this._model.definitions, entity) &&
      (event === 'draftPrepare' || event === 'draftEdit' || event === 'draftActivate')
    )
  }

  /**
   * Adds a middleware handler to the set.
   * @param event
   * @param entity
   * @param handler
   * @private
   */
  _addHandler (event, entity, handler) {
    this._handlers.push({
      event,
      entity,
      handler
    })
  }

  /**
   * Check if the handler should handle this event.
   * @return {boolean}
   * @private
   */
  _match (event, context, entry) {
    // Registered to all events
    if (!this._isTransactionEvent(event) && !entry.event && !entry.entity) {
      return true
    }

    if (entry.event !== event) {
      return false
    }

    if (entry.entity === undefined) {
      return true
    }

    return context.target && entry.entity === context.target.name
  }

  _handleErrors (context, result) {
    if (!context._.errors || context._.errors.length === 0) {
      return result
    }

    throw context._.errors.reduce(this._reduceErrors)
  }

  _reduceErrors (finalError, currentError) {
    if (!finalError) {
      return currentError
    }

    finalError.message += `, ${currentError.message}`

    return finalError
  }

  _addReject (reject, context, called) {
    /**
     * @param {number|Error|string} code - (status) code. If unknown it will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     */
    context.reject = (code, err) => {
      Object.defineProperty(context, called || CALLED, { configurable: true, value: true })
      reject(getError(code, err))
    }
  }

  _addReply (resolve, context) {
    context.reply = result => {
      Object.defineProperty(context, CALLED, { configurable: true, value: true })
      resolve(result)
    }
  }
}

module.exports = Base
