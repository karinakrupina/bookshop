const Base = require('./Base')
const CALLED = Symbol.for('rejectCalled')

/**
 * Class representation of after middleware.
 * @augments Base
 * @alias module:hooks.After
 */
class After extends Base {
  _addHandler (event, entity, handler) {
    this._handlers.push({
      event,
      entity,
      handler: this._addConvenienceWrapper(handler)
    })
  }

  /**
   * In case the app developer uses the single arguments row or each for his handler, he wants convenience.
   * This means, the framework has to wrap his function in an iterator in case the result is an array.
   * @param {function} handler
   * @return {function}
   * @private
   */
  _addConvenienceWrapper (handler) {
    if (/^\s*(?:\(\s*)?(?:row|each)\s*\)?\s*=>/.test(handler.toString())) {
      return result => {
        if (Array.isArray(result)) {
          for (const row of result) {
            handler(row)
          }

          return
        }

        handler(result)
      }
    }

    return handler
  }

  /**
   * Check if handlers are registered for event and entity. Execute all handlers that are registered,
   * with result being passed in as input parameter to the handler.
   * @param {string} event - name of the event like READ, UPDATE, ...
   * @param {Object} context - Contains request information and utility events like .reply(), .error(), ...
   * @param {Object} context.target - the unreflected entity.
   * @param {Object|Array} result - the result being received from the OnHandler. In case of a COMMIT or ROLLBACK event
   *                                this could also be the error that indicates that the transaction operation failed.
   */
  executeHandlerIfListed (event, context, result) {
    return new Promise((resolve, reject) => {
      delete context.reply
      this._addReject(reject, context, CALLED)

      this._execute(event, context, this._getResultAsArray(result))
        .then(resolve)
        .catch(reject)
    })
  }

  /**
   * Check if result is array and if not return result as single entry in an array.
   * @param result
   * @return {Array}
   * @private
   */
  _getResultAsArray (result) {
    // Null, 0, false, '', ... should be wrapped
    if (result === undefined) {
      return []
    }

    return Array.isArray(result) ? result : [result]
  }

  async _execute (event, context, result) {
    if (this._isTransactionEvent(event)) {
      return this._matchAndRunHandlers(event, context, result)
    }

    await this._matchAndRunHandlers(event, context, result)

    return this._handleErrors(context, result)
  }

  async _matchAndRunHandlers (event, context, result) {
    for (const entry of this._handlers) {
      if (context[CALLED]) {
        return
      }

      if (this._match(event, context, entry)) {
        const fnReturn = entry.handler(result, context)

        if (fnReturn && fnReturn.then) {
          await fnReturn
        }
      }
    }
  }
}

module.exports = After
