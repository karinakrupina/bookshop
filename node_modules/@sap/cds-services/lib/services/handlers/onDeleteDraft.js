const { getError } = require('../../errors/index')
const { isDraftRootEntity } = require('../utils/compositionTree')
const { getUpdateDraftAdminCQN } = require('../utils/draftUtils')
const { extractKeyConditions } = require('../utils/draftWhereUtils')
const { DB_CONNECTION_MISSING } = require('../utils/constants')

const _getSelectCQN = (context, keys) => {
  return context.statements.SELECT.from(context.target).where(keys.keyList)
}

const _getDraftEntityName = ({ target: { name } }) => `${name}_drafts`

const _getDraftSelectCQN = (context, keys) => {
  const draftEntityName = _getDraftEntityName(context)

  return context.statements.SELECT.from(`${draftEntityName}`, ['DraftUUID', 'InProcessByUser'])
    .join('DRAFT.DraftAdministrativeData')
    .on({ ref: ['DraftAdministrativeData_DraftUUID'] }, `=`, `"DRAFT.DraftAdministrativeData"."DraftUUID"`)
    .where(keys.keyList)
}

const _validate = (activeResult, draftResult, context, IsActiveEntity) => {
  if (
    (IsActiveEntity === true && activeResult.length === 0) ||
    (IsActiveEntity === false && draftResult.length === 0)
  ) {
    context.reject(404)
  }

  if (draftResult.length !== 0 && draftResult[0].InProcessByUser !== context.user.id) {
    context.reject(getError(403, 'Locked by another user'))
  }
}

const _getActiveDeleteCQN = ({ statements: { DELETE } }, entity, keys) => DELETE.from(entity).where(...keys)

const _getDraftDeleteCQN = ({ statements: { DELETE } }, entity, keys) => {
  return DELETE.from(`${entity.name}_drafts`).where(...keys)
}

const _getDraftAdminDeleteCQN = ({ statements: { DELETE } }, draftUUID) =>
  DELETE.from('DRAFT.DraftAdministrativeData').where({ draftUUID })

/**
 * Generic Handler for DELETE requests.
 * In case of success it returns an empty object.
 * If the entry to be deleted does not exist, it rejects with error to return a 404.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onDelete
 */
const onDeleteDraft = ({ service: { model: { definitions } = {} } = {} }) => context => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return Promise.resolve()
  }

  const keys = extractKeyConditions(context.query.DELETE.where)
  return Promise.all([context.run(_getSelectCQN(context, keys)), context.run(_getDraftSelectCQN(context, keys))]).then(
    ([activeResult, draftResult]) => {
      _validate(activeResult, draftResult, context, keys.IsActiveEntity)

      const source = definitions[context.target.name]
      const delCQNs = []

      delCQNs.push(_getDraftDeleteCQN(context, source, keys.keyList))
      if (keys.IsActiveEntity) {
        delCQNs.push(_getActiveDeleteCQN(context, source, keys.keyList))
      }

      if (draftResult.length !== 0) {
        const draftUUID = draftResult[0].DraftUUID
        if (isDraftRootEntity(definitions, context.target.name)) {
          delCQNs.push(_getDraftAdminDeleteCQN(context, draftUUID))
        } else {
          delCQNs.push(getUpdateDraftAdminCQN(context, draftUUID))
        }
      }

      context._oldData = keys.IsActiveEntity ? activeResult[0] : draftResult[0]
      return Promise.all(delCQNs.map(cqn => context.run(cqn))).then(() => {})
    }
  )
}

module.exports = onDeleteDraft
