const cds = require('../../cds')

const getClientIpFromRequest = require('../utils/clientIpFromRequest')

const _evaluate = (ref, context) => {
  return ref.reduce((prev, curr) => {
    return prev[curr.replace(/^\$/, '')]
  }, context)
}

const _valuesToOrConditions = (columnRef, op, values) => {
  const arr = ['(']

  for (const value of values) {
    if (arr.length !== 1) {
      arr.push('or')
    }

    arr.push(columnRef, op, { val: value })
  }

  arr.push(')')

  return arr
}

const _xprToCondition = (context, columnRef, op, userRef) => {
  let attrValue = userRef.ref.length === 1 ? context.user.id : _evaluate(userRef.ref, context)

  if (Array.isArray(attrValue)) {
    return _valuesToOrConditions(columnRef, op, attrValue)
  }

  return [columnRef, op, { val: attrValue }]
}

/**
 * Replace $user with context.user.id
 * and $user.bla.bla with context.user.bla.bla.
 * Afterwards split to parts by space.
 *
 * @param annotatedWhere
 * @param context
 *
 * @private
 */
const _parseWhere = (annotatedWhere, context) => {
  const { xpr } = cds.parse.expr(annotatedWhere)

  return _parseWhereFromXpr(context, xpr)
}

const _parseWhereFromXpr = (context, xpr) => {
  const length = xpr ? xpr.length : 0

  const processed = []
  let i = 0

  while (i < length) {
    if (typeof xpr[i] === 'object' && xpr[i].SELECT && xpr[i].SELECT.where) {
      xpr[i].SELECT.where = _parseWhereFromXpr(context, xpr[i].SELECT.where)
    }

    if (xpr[i].ref && typeof xpr[i + 1] === 'string' && xpr[i + 2].ref) {
      if (xpr[i].ref[0] === '$user') {
        processed.push(..._xprToCondition(context, xpr[i + 2], xpr[i + 1], xpr[i]))
      } else if (xpr[i + 2].ref[0] === '$user') {
        processed.push(..._xprToCondition(context, xpr[i], xpr[i + 1], xpr[i + 2]))
      } else {
        processed.push(xpr[i], xpr[i + 1], xpr[i + 2])
      }
      i += 3
    } else {
      processed.push(xpr[i])
      i++
    }
  }

  return processed
}

const _cqnToData = on => {
  const data = {}
  const length = on.length
  let i = 0

  while (i < length) {
    if (on[i].ref && on[i + 1] === '=' && on[i + 2].val) {
      data[on[i].ref[on[i].ref.length - 1]] = on[i + 2].val
      i += 3
    } else {
      i++
    }
  }

  return data
}

const _changeUpdate = (annotations, context) => {
  if (annotations.where.length === 0) {
    return
  }

  const parsed = _cqnToData(_parseWhere(annotations.where[0], context))

  if (context.data) {
    Object.assign(context.data, parsed)
  }

  Object.assign(context.query.UPDATE.data, parsed)
}

/**
 * Get generic authorization handler for CRUD requests on entity level.
 * The handler to be registered as a before handler.
 *
 * @param annotations - prepared authorization (restrict or requires) annotations
 * @param auditLogger - the audit logger object
 */
const getAuthEntityHandler = (annotations, auditLogger) => {
  /**
   * @param context - operation object, that provides error, continuation and other functions as well as information
   * regarding the current operation.
   */
  return context => {
    if (annotations.to && !context.user.has(annotations.to)) {
      auditLogger.logMissingPermissions({
        user: context.user.id,
        ip: getClientIpFromRequest(context._.req),
        tenant: context.attr.identityZone
      })

      return context.reject(403)
    }

    if (context.query.INSERT || !annotations.where) {
      return
    }

    if (context.query.UPDATE) {
      _changeUpdate(annotations, context)
    }

    for (const where of annotations.where) {
      context.query.where(..._parseWhere(where, context))
    }
  }
}

module.exports = getAuthEntityHandler
