const { getCompositionSet, getCompositionTree } = require('./compositionTree')
const { getKeyData } = require('./draftWhereUtils')
const DRAFT_COLUMNS = ['IsActiveEntity', 'HasActiveEntity', 'HasDraftEntity', 'DraftAdministrativeData_DraftUUID']
const _getEntities = (nameSet, definitions) => {
  const entities = []

  for (const name of nameSet) {
    entities.push(definitions[name])
  }

  return entities
}
const _isAssocOrComp = element => element.type === 'cds.Association' || element.type === 'cds.Composition'

const _getColumns = entity => {
  return Object.values(entity.elements)
    .filter(e => !_isAssocOrComp(e) && !DRAFT_COLUMNS.includes(e.name))
    .map(e => e.name)
}

const _generateSelectCqnsFromRootDraft = (entities, context, draftUUID) => {
  const draftCqns = []
  for (const entity of entities) {
    draftCqns.push(
      context.statements.SELECT.from(`${entity.name}_drafts`)
        .columns(_getColumns(entity))
        .where('DraftAdministrativeData_DraftUUID', draftUUID)
    )
  }

  return draftCqns
}

const _createMapOfResults = (entities, draftResults) => {
  const map = new Map()

  for (let i = 0, length = entities.length; i < length; i++) {
    map.set(entities[i].name, draftResults[i])
  }

  return map
}

const _generateEntitiesOfLevelMap = (map, obj, level = 0) => {
  for (const compositionElement of obj.compositionElements) {
    const newLevel = level + 1
    map.has(newLevel) ? map.get(newLevel).push(compositionElement) : map.set(newLevel, [compositionElement])
    _generateEntitiesOfLevelMap(map, compositionElement, newLevel)
  }
}

const _currentAndParentMatch = (currentValue, parentValue, backLinks) => {
  let match = true
  for (const backLink of backLinks) {
    if (parentValue[backLink.target_element] !== currentValue[backLink.name]) {
      match = false
      break
    }
  }
  return match
}

const _linkResultsOfLevelToParent = (entitiesOfLevelMap, level, resultMap) => {
  const currentLevelEntities = entitiesOfLevelMap.get(level)
  const currentData = currentLevelEntities.map(({ source }) => resultMap.get(source))

  if (level === 0) {
    return currentData
  }

  for (let i = 0, length = currentLevelEntities.length; i < length; i++) {
    const backLinks = currentLevelEntities[i].backLinks
    const parentData = resultMap.get(currentLevelEntities[i].target)
    for (const currentValue of currentData[i]) {
      for (const parentValue of parentData) {
        if (!parentValue[currentLevelEntities[i].name]) {
          parentValue[currentLevelEntities[i].name] = []
        }

        if (_currentAndParentMatch(currentValue, parentValue, backLinks)) {
          parentValue[currentLevelEntities[i].name].push(currentValue)
        }
      }
    }
  }

  return _linkResultsOfLevelToParent(entitiesOfLevelMap, level - 1, resultMap)
}

const _generateResultObject = (entitiesOfLevelMap, resultMap) => {
  const maxLevel = entitiesOfLevelMap.size - 1
  return _linkResultsOfLevelToParent(entitiesOfLevelMap, maxLevel, resultMap)
}

const _readRoot = (context, requestActiveData) => {
  const keys = Object.keys(context.target.keys).filter(key => key !== 'IsActiveEntity')
  const keyData = getKeyData(keys, context.query.SELECT.where)
  return context.run(
    context.statements.SELECT.from(requestActiveData ? context.target.name : `${context.target.name}_drafts`).where(
      keyData
    )
  )
}

const _readDraftAdministrativeData = (context, draftUUID) =>
  context.run(context.statements.SELECT.from('DRAFT.DraftAdministrativeData').where({ DraftUUID: draftUUID }))

const readDraftCompositionTree = async (service, context) => {
  const root = await _readRoot(context, false)
  if (root.length === 0) context.reject(404)
  const draftAdministrativeData = await _readDraftAdministrativeData(context, root[0].DraftAdministrativeData_DraftUUID)

  const compSet = getCompositionSet(service.model.definitions, context.target.name)
  const entities = _getEntities(compSet, service.model.definitions)

  const draftCQNs = _generateSelectCqnsFromRootDraft(entities, context, root[0].DraftAdministrativeData_DraftUUID)
  const results = await Promise.all(draftCQNs.map(cqn => context.run(cqn)))
  const resultMap = _createMapOfResults(entities, results)
  const compositionTree = getCompositionTree(service.model.definitions, context.target.name, false)
  const entitiesOfLevelMap = new Map([[0, [compositionTree]]])
  _generateEntitiesOfLevelMap(entitiesOfLevelMap, compositionTree)

  return { data: _generateResultObject(entitiesOfLevelMap, resultMap), administrativeData: draftAdministrativeData[0] }
}

module.exports = {
  readDraftCompositionTree
}
