const { readAndDeleteKeywords } = require('./draftWhereUtils')

const getServiceNamespace = targetName => targetName.replace(/\.\w+$/i, '')
const getEntityName = source => source.replace(/.+\./, '')
const getDraftName = (serviceNamespace, entityName) => `${serviceNamespace}.${entityName}_drafts`

const _getParentCQNWithKeyColumn = (parentCQN, parentKeyName) => {
  const parentCQNWithKeyColumn = Object.assign({}, parentCQN)
  parentCQNWithKeyColumn.SELECT = Object.assign({}, parentCQN.SELECT)
  parentCQNWithKeyColumn.SELECT.columns = [{ ref: [parentKeyName] }]
  return parentCQNWithKeyColumn
}

const getSubCQNs = ({ definitions, context, rootCQN, compositionTree, selectFromDraft = false }) => {
  const subCQNs = []
  const serviceNamespace = getServiceNamespace(context.target.name)
  // only one backLink, must be managed and point to parent
  const _generateSubCQNs = (parentEntity, parentCQN, compositionElements, level = 1) => {
    for (const element of compositionElements) {
      const backLink = element.backLinks[0]

      const parentKey = Object.keys(parentEntity.elements)
        .map(elementName => parentEntity.elements[elementName])
        .filter(element => element.key)

      if (parentKey[0]) {
        const subCQN = context.statements.SELECT.from(
          selectFromDraft ? getDraftName(serviceNamespace, getEntityName(element.source)) : element.source
        ).where({ ref: [backLink.name] }, 'in', _getParentCQNWithKeyColumn(parentCQN, parentKey[0].name))

        subCQNs.push({ cqn: subCQN, level })
        _generateSubCQNs(definitions[element.source], subCQN, element.compositionElements, level + 1)
      }
    }
  }

  _generateSubCQNs(context.target, rootCQN, compositionTree.compositionElements)

  return subCQNs
}

/**
 * Converts db entity names in the composition set to draft entity names
 * e.g. dataModel.Books will be converted to service.namespace.Books_drafts
 *
 * @param {*} compositionSet
 * @param {*} model
 * @param {*} context
 */
const draftNamesForCompositionSet = (compositionSet, model, { target: { name } }) => {
  // remove entity name
  const serviceNamespace = name.match(/.*\./)[0]

  const servicesInNamespace = Object.keys(model)
    .map(key => model[key])
    .filter(entity => entity.name.startsWith(serviceNamespace))
  const result = []

  for (const entity of compositionSet) {
    servicesInNamespace.map(({ source, name }) => {
      if (source === entity) {
        return result.push(`${name}_drafts`)
      }
    })
  }

  return result
}

const getUpdateDraftAdminCQN = ({ statements, user }, draftUUID) => {
  const set = {
    InProcessByUser: user.id,
    LastChangedByUser: user.id,
    LastChangeDateTime: new Date(Date.now()).toISOString()
  }

  return statements
    .UPDATE('DRAFT.DraftAdministrativeData')
    .set(set)
    .where({ DraftUUID: draftUUID })
}

const getEnrichedCQN = (cqn, select, draftWhere, addLimitOrder = true) => {
  if (draftWhere && draftWhere.length !== 0) {
    cqn.where(draftWhere)
  }

  if (select.distinct) {
    cqn.distinct()
  }

  if (select.having) {
    cqn.having(select.having)
  }

  // groupBy, orderBy and limit do not support partial CQNs
  if (select.groupBy) {
    cqn.SELECT.groupBy = select.groupBy
  }

  if (select.orderBy && addLimitOrder) {
    cqn.SELECT.orderBy = select.orderBy
  }

  if (select.limit && addLimitOrder) {
    cqn.SELECT.limit = select.limit
  }

  return cqn
}

// Only works for root entity, otherwise the relative position needs to be adapted
const setStatusCodeAndHeader = (response, keys, entityName, isActiveEntity) => {
  response.setStatusCode(201)

  const keysString = Object.keys(keys)
    .map(key => `${key}=${keys[key]}`)
    .join(',')
  response.setHeader('location', `../${entityName}(${keysString},IsActiveEntity=${isActiveEntity})`)
}

const removeDraftUUID = result => {
  if (Array.isArray(result)) {
    for (const row of result) {
      delete row.DraftAdministrativeData_DraftUUID
    }
  } else {
    delete result.DraftAdministrativeData_DraftUUID
  }

  return result
}

const activeVersionExists = context => {
  const newWhere = [...context.query.SELECT.where]
  readAndDeleteKeywords(['IsActiveEntity'], newWhere)
  return context
    .run(context.statements.SELECT.from(context.target, [1]).where(newWhere))
    .then(result => result.length > 0)
}

const isDraftActivateAction = context => context._.odataReq.getUrlObject().path.endsWith('draftActivate')

module.exports = {
  getServiceNamespace,
  getDraftName,
  getEntityName,
  getSubCQNs,
  draftNamesForCompositionSet,
  getUpdateDraftAdminCQN,
  getEnrichedCQN,
  removeDraftUUID,
  setStatusCodeAndHeader,
  activeVersionExists,
  isDraftActivateAction
}
