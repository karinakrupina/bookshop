const cds = require('../cds')
const { getError } = require('../errors')

// Service hooks and generic handlers
const handlers = require(`./handlers`)
const { After, Before, On, Reject } = require('./hooks')

// Service utils
const auditLogger = require('./utils/auditlog')
const { isDraftEnabled, isDraftRootEntity } = require('./utils/compositionTree')
const { getDefaultHandlers, getScenario } = require('./utils/defaultHandlers')
const getDiff = require('./utils/diff')
const { checkIntegrity } = require('./utils/handlerUtils')
const isSelectEntity = require('./utils/selectEntityUtils')
const logger = require('./utils/logger')

// Local client facade
const clientFor = require('../adapter/client/for')

// Utils used also at adapters
const personalDataHandler = require('../adapter/utils/personalDataHandler')
const getAnnotations = require('../adapter/utils/getAnnotations')

const CALLED = Symbol.for('continuationCalled')

/**
 * Generic Service Event Handler.
 */
class Service {
  /**
   * Constructs an OData service for the given CDS model.
   * @param {Object} csn - the reflected CSN.
   * @param {Object} options - configuration options
   * @param {function} [impl] - init function to register custom handlers.
   * @throws {ModelNotDefined}
   */
  constructor ({ csn, reflectedModel }, options) {
    cds.service.providers.push(this)

    this._options = options
    this.name = options.service
    this.model = reflectedModel
    this._csn = csn

    this.definition = reflectedModel.definitions[this.name]

    this.entities = reflectedModel.childrenOf(this.definition)
    this.types = reflectedModel.childrenOf(this.name, 0, x => x.kind === 'type')

    this._handlers = {
      before: new Before(this.model, this.name),
      on: new On(this.model, this.name),
      after: new After(this.model, this.name),
      reject: new Reject(this.model, this.name)
    }

    this._addDefaultMiddleware()
    this._addDefaultHandler()
    this._addDefaultPersonalDataHandler()
  }

  /**
   * Require logger on first usage.
   * Could be provided via options.
   *
   * @returns {Object}
   */
  get logger () {
    const log = logger(this._options)
    Object.defineProperty(this, 'logger', { value: log })
    return log
  }

  /**
   * Require @sap/audit-logging on first usage.
   * @returns {Object}
   * @private
   */
  get _auditLogger () {
    const audit = auditLogger(this._options.auditlog, this.logger)
    Object.defineProperty(this, '_auditLogger', { value: audit })
    return audit
  }

  _addDefaultMiddleware () {
    this._registerPassportMiddleware()
  }

  _registerPassportMiddleware () {
    const passport = require('../adapter/utils/passport')(this._options, this.model.definitions)

    if (passport) {
      this.use(passport.initialize())
      this.use(
        require('../adapter/utils/passportAuthenticateCallback')(
          passport,
          this._options.passport ? this._options.passport.strategy : {},
          this._auditLogger
        )
      )
      this.use(require('../adapter/utils/serviceAuth')(this.model.definitions[this.name], this._auditLogger))
      // Security annotations, but no passport
    } else if (passport === false) {
      this.use(require('../adapter/utils/serviceAuth')(this.model.definitions[this.name], this._auditLogger))
    }
  }

  /**
   * Registers custom handlers.
   * @param {function} impl - init function to register custom handlers.
   */
  with (impl) {
    if (typeof impl === 'function') {
      impl.apply(this, [this])
    }
    return this
  }

  /**
   * Register default on handlers for all entities of the service.
   * If the entity is marked with @readonly annotation only default handler for read is registered, others are rejected.
   * If the entity is marked with @insertonly annotation only default handler for insert is registered, others are rejected.
   * @private
   */
  _addDefaultHandler () {
    this._addDefaultBeforeAuthHandler()

    const localClient = clientFor(this._options.at)
    const isDraftEnabledService = Object.keys(this.model.definitions).some(
      key => this.model.definitions[key]['@odata.draft.enabled']
    )

    if (isDraftEnabledService) {
      this.model['IS_SERVICE_DRAFT'] = true
    }

    for (const entity of this._getServiceEntities()) {
      const { before, on, reject } = getDefaultHandlers(
        isDraftEnabledService,
        isDraftEnabled(this.model.definitions, entity.name),
        isDraftRootEntity(this.model.definitions, entity.name),
        entity.name
      ).get(getScenario(entity))

      this._addDefaultBeforeHandler(before, localClient, entity)
      this._addDefaultOnHandler(on, localClient, entity)
      this._addDefaultRejectHandler(reject, entity.name)
    }

    // Final handler, that will throw an error
    this.on(handlers.finalOn)

    // Generic commit/rollback
    this.on('COMMIT', handlers.onCommit)
    this.on('ROLLBACK', handlers.onRollback)
  }

  _addReferenceIntegrityHandler (method, entity) {
    this.before(method, entity, checkIntegrity)
  }

  _isReferenceIntegrityCheckNeeded (entity, service) {
    return (
      !this.model['IS_SERVICE_DRAFT'] &&
      !(entity['@cds.integrity.skip'] !== false && (entity['@cds.integrity.skip'] || service['@cds.integrity.skip']))
    )
  }

  _addDefaultBeforeHandler (before, localClient, entity) {
    for (const [method, handlerName] of before) {
      this.before(method, entity, handlers[handlerName]({ service: this, localClient }))
    }

    if (this._isReferenceIntegrityCheckNeeded(entity, this.model.definitions[this.name])) {
      this._addReferenceIntegrityHandler(['CREATE', 'UPDATE'], entity)
    }
  }

  _addDefaultOnHandler (on, localClient, entity) {
    for (const [method, handlerName] of on) {
      this.on(method, entity, handlers[handlerName]({ service: this, localClient }))
    }
  }

  _addDefaultRejectHandler (reject, entityName) {
    if (reject.length) {
      this.reject(reject, entityName)
    }
  }

  /**
   * Checks if entity has annotation '@PersonalData.EntitySemantics' and value is either 'DataSubject' or
   * 'DataSubjectDetails'.
   * @param entity
   * @returns {boolean}
   * @private
   */
  _isPersonalDataRelevant (entity) {
    const allowedAnnotations = ['DataSubject', 'DataSubjectDetails']
    return (
      entity['@PersonalData.EntitySemantics'] && allowedAnnotations.includes(entity['@PersonalData.EntitySemantics'])
    )
  }

  /**
   * Register default before commit and after commit/rollback handler for the entity.
   * @param entity
   * @private
   */
  _registerPersonalDataHandler (entity) {
    const {
      personalDataBeforeCommitHandler,
      personalDataAfterCommitHandler,
      personalDataBeforeRollbackHandler,
      personalDataAfterRollbackHandler
    } = personalDataHandler(this._auditLogger)

    if (
      entity['@AuditLog.Operation.Insert'] ||
      entity['@AuditLog.Operation.Update'] ||
      entity['@AuditLog.Operation.Delete']
    ) {
      this.before('COMMIT', entity, personalDataBeforeCommitHandler)
      this.after('COMMIT', entity, personalDataAfterCommitHandler)
      this.before('ROLLBACK', entity, personalDataBeforeRollbackHandler)
      this.after('ROLLBACK', entity, personalDataAfterRollbackHandler)
    } else if (entity['@AuditLog.Operation.Read']) {
      this.before('COMMIT', entity, personalDataBeforeCommitHandler)
    }
  }

  /**
   * Register default before commit and after commit/rollback handler for all personal data annotated entities of the
   * service.
   * @private
   */
  _addDefaultPersonalDataHandler () {
    for (const entity of this._getServiceEntities()) {
      if (this._isPersonalDataRelevant(entity)) {
        this._registerPersonalDataHandler(entity)
      }
    }
  }

  /**
   * Register default before handlers for all authorization annotated entities of the service.
   * @private
   */
  _addDefaultBeforeAuthHandler () {
    this.before(handlers.beforeAll(this._options.defaultLocale))

    for (const entity of this._getServiceEntities()) {
      const annotations = getAnnotations(entity)

      for (const key of Object.keys(annotations)) {
        this.before(key, entity, handlers.beforeEntityAuth(annotations[key], this._auditLogger))
      }
    }
  }

  _getServiceEntities () {
    const regex = new RegExp(`^${this.name.replace(/\./g, '\\.')}\\.\\w+$`)

    return [
      ...this.model.each(definition => {
        return (
          (definition.kind === 'entity' || isSelectEntity(definition, this.model)) && // OLD CSN: isSelectEntity
          definition.name.match(regex)
        )
      })
    ]
  }

  _isRejectedInternalEvent (event, { target }) {
    if (['CREATE_DRAFT', 'UPDATE_DRAFT'].includes(event)) {
      return this._handlers.reject.has('CREATE', target)
    }

    return event === 'draftEdit' ? this._handlers.reject.has('UPDATE', target) : false
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  before (event, entity, handler) {
    this._handlers.before.use(event, entity, handler)

    return this
  }

  /**
   * Replace an handler for a specific event type and entity.
   * @param {string} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  on (event, entity, handler) {
    this._handlers.on.use(event, entity, handler)

    return this
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * In case an arrow function with '(each) =>' is used for the event handler an iterator for the result set will be added automatically.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  after (event, entity, handler) {
    this._handlers.after.use(event, entity, handler)

    return this
  }

  /**
   * Reject an event type, list of event types or an event type for a entity.
   * @param {string|Array} event - Specific event type or list of types.
   * @param {string|Object|Array} [entity] - Name of the entity or CSN entity or list of entities the event type should be rejected for.
   * The list can be specified either as Array or as multiple parameters.
   * @returns {Service}
   */
  reject (...args) {
    this._handlers.reject.use(...args)

    return this
  }

  /**
   * Express like middleware registration.
   * @returns {Service}
   */
  use (...args) {
    if (!this._handlers.router) {
      this._handlers.router = require('express').Router()
    }

    this._handlers.router.use(...args)

    return this
  }

  /**
   * Execute all registered middleware.
   * @param {Object} req
   * @param {Object} res
   * @param {Function} next
   * @returns {undefined} if no router is present
   */
  routerHandle (req, res, next) {
    if (!this._handlers.router) {
      next()
      return
    }

    const end = err => {
      if (err) {
        // err.status is http error code from passport
        res.status(err.statusCode || err.status || 500)
        res.send({
          error: {
            code: err.code,
            message: err.message
          }
        })

        return
      }

      next()
    }

    this._handlers.router.handle(req, res, end)
  }

  /**
   * Process an event from any adapter/channel.
   * @param {string} event
   * @param {Object} context
   * @returns {Promise<Array>}
   */
  async processEvent (event, context) {
    if (this._handlers.reject.has(event, context.target) || this._isRejectedInternalEvent(event, context)) {
      throw getError(405)
    }

    this._addError(context)
    this._addRunIfPrimarySessionExists(context)
    this._addLogger(context)

    let result

    try {
      result = this._storeDataOperations(event, context, await this._actionsFunctionsHandlers(event, context))
    } catch (err) {
      await this._commitRollback('ROLLBACK', context, this._storeDataOperations(event, context, err))
      throw err
    }

    return this._commitRollback('COMMIT', context, result)
  }

  /**
   * Check for registered handlers.
   * Execute in sequence before, on, after, beforeCommit, commit, onCommit.
   * @param {string} event
   * @param {Object} context
   * @private
   */
  async _actionsFunctionsHandlers (event, context) {
    let result = await this._handlers.before.executeHandlerIfListed(event, context)

    // Reply has not been used at before
    if (!context[CALLED]) {
      result = await this._handlers.on.executeHandlerIfListed(event, context)
    }

    return this._handlers.after.executeHandlerIfListed(event, context, result)
  }

  async _commitRollback (command, context, result) {
    if (context._.doNotFinishTransaction === undefined) {
      await this._executeFinishTransactionHandlers(command, context)
    }

    return result
  }

  async _executeFinishTransactionHandlers (command, context) {
    try {
      // Remove the flag for being called before
      delete context[CALLED]

      await this._beforeEndTransactionBlock(command, context._.dataOperations)
      await await this._handlers.on.executeHandlerIfListed(command, context)
    } catch (commandErr) {
      if (command === 'ROLLBACK' && context._.dbc && cds.session) {
        // F.U.B.A.R. we need to destroy the client if one is left
        await cds.session.destroy(context._.dbc)
        delete context._.dbc
        delete context.run
      } else if (command === 'COMMIT') {
        await this._executeFinishTransactionHandlers('ROLLBACK', context)
      }

      throw commandErr
    }

    await this._afterEndTransactionBlock(command, true, context._.dataOperations)

    // Remove, as the next batch group will have its own context
    delete context._.dataOperations
  }

  _addLogger (context) {
    context.log = this.logger
  }

  /**
   * Add .error function to context object.
   * @param {Object} context
   * @private
   */
  _addError (context) {
    /**
     * Error factory method.
     * Errors are not thrown. Instead they are collected in the array context._.errors.
     * @param {number|Error|string} code - HTTP status code. If unknown to @sap/odata-server, will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     */
    context.error = (code, err) => {
      context._.errors = context._.errors || []

      const error = getError(code, err)
      context._.errors.push(error)

      return error
    }
  }

  /**
   * Track the general event as commit event.
   * @param event
   * @param context
   * @param result
   * @private
   */
  _storeDataOperations (event, context, result) {
    context._.dataOperations = context._.dataOperations || []

    const dataOperation = {
      get query () {
        return context.query
      },
      target: context.target,
      data: context.data,
      // Event is not required by handler, but is useful for the app developer
      event: event,
      // Add the underscore, to give an app developer a cross event object
      _: Object.assign({}, context._, { dataOperations: undefined }),
      user: context.user,
      attr: context.attr
    }

    if (event === 'READ') {
      dataOperation.result = result
    } else {
      // Might be undefined; TODO: an API to set it.
      dataOperation.oldData = context._oldData

      // Lazy constructing of the diff
      Object.defineProperty(dataOperation, 'diff', {
        configurable: true,
        get: function () {
          const diff = getDiff(event, this.oldData, this.data)
          Object.defineProperty(dataOperation, 'diff', { value: diff })

          return diff
        }
      })
    }

    context._.dataOperations.push(dataOperation)

    return result
  }

  _beforeEndTransactionBlock (command, dataOperations = []) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      handlers.push(this._handlers.before.executeHandlerIfListed(command, dataOperation))
    }

    return Promise.all(handlers)
  }

  _afterEndTransactionBlock (command, success, dataOperations = []) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      dataOperation.success = success

      handlers.push(this._handlers.after.executeHandlerIfListed(command, dataOperation))
    }

    return Promise.all(handlers)
  }

  _getAcquireOptions (context) {
    if (context._.req) {
      return {
        JWT: context.attr ? context.attr.token : undefined,
        tenantId: context.attr ? context.attr.identityZone : undefined,
        user: context.user.id,
        locale: context.user.locale
      }
    }
    return undefined
  }

  _addRunIfPrimarySessionExists (context) {
    // Add the function so that the connection can be released in case of errors in complex scenarios like OData batch
    if (context._.doNotFinishTransaction && !context._.endTransactionIfConnected) {
      // Wrap to easily maintain the scope of this
      context._.endTransactionIfConnected = (...args) => {
        return this._executeFinishTransactionHandlers(...args)
      }
    }

    // cds.connect() has not been used yet
    if (!cds.session) {
      return
    }

    const _run = (...args) => {
      // Run has been used before, but acquire is not done yet
      if (context._.dbc instanceof Promise) {
        return context._.dbc.then(() => {
          if (context._.dbc.stack) {
            throw context._.dbc
          }

          return context._.dbc.execute(...args)
        })
      }

      // There has been an error on acquire
      if (context._.dbc && context._.dbc.stack) {
        return Promise.reject(context._.dbc)
      }

      // Run has been used before and acquire is done
      if (context._.dbc && context._.dbc.execute) {
        return context._.dbc.execute(...args)
      }

      // Acquire and execute
      context._.dbc = cds.session
        .acquire(this._getAcquireOptions(context))
        .then(client => {
          context._.dbc = client
          client.setCSN(this.model)

          return client.begin()
        })
        .catch(err => {
          context._.dbc = err

          throw err
        })
        .then(() => {
          return context._.dbc.execute(...args)
        })

      return context._.dbc
    }

    context.run = (...args) => {
      return this._addThenableToRun(_run(...args), _run)
    }
  }

  _addThenableToRun (promise, run) {
    const then = (resolve, reject) => {
      return promise.then(resolve).catch(reject)
    }

    then.run = (...args) => {
      return this._addThenableToRun(
        promise.then(() => {
          return run(...args)
        }),
        run
      )
    }

    return {
      then: then,
      catch: promise.catch
    }
  }
}

module.exports = Service
