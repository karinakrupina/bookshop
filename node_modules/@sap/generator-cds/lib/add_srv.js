const path = require('path');

const Constants = require('./constants');
const ExecHelper = require('./helper/exec_helper');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');
const MTAHelper = require('./helper/mta_helper');
const MvnArchetypes = require('./java/mvn_archetypes');
const XmlHelper = require('./helper/xml_helper');



class AddSrvHandler {
    constructor(addCommand) {
        this._addCommand = addCommand;
    }

    async getDbFolder(dest) {
        const dbFolder = path.resolve(dest, '..', Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_DB]);
        if (await FsHelper.pathExists(dbFolder) ) {
            return path.basename(dbFolder);
        }

        return null;
    }

    async stageCopyTemplates(dest, options) {
        this._addCommand.reportProgress(
            i18n.t(i18n.add_copying_templates, { dest, moduleType: Constants.MODULE_TYPE_SRV }),
            options.verbose
        );

        // generate node code only for WebIDE
        if (this._addCommand.isWebIDE() && options.srvTechnology === Constants.SRV_TECHNOLOGY_NODEJS) {
            await FsHelper.copyTemplate('srv/nodejs', dest, options);
        }
    }

    async stagePostProcessing(dest, options) {
        // command line execution
        if (options.srvTechnology === Constants.SRV_TECHNOLOGY_JAVA) {
            this._addCommand.reportProgress(i18n.init_creating_java_srv, options.verbose);
            await  this._runMvn(dest, options);

            this._addCommand.reportProgress(
                i18n.init_postprocessing_java_srv,
                options.verbose
            );
            const pomXmlPath = path.join(dest, 'pom.xml');
            await this._patchPomXml(pomXmlPath);
        }

        if (options.srvTechnology === Constants.SRV_TECHNOLOGY_NODEJS) {
            const packageJsonPath = path.join(dest, 'package.json'); // local package.json
            await this._addCommand.updateDependencies(packageJsonPath, options.debug);

            await this._extendLocalPackageJson(dest);
        }

        const yamlPath = path.join(dest, '..', 'mta.yaml');
        if (await FsHelper.pathExists(yamlPath)) {
            this._addCommand.reportProgress(i18n.t(i18n.init_creating_mta_file, { yamlPath }), options.verbose);
            await MTAHelper.update(
                dest,
                yamlPath,
                Constants.MODULE_TYPE_SRV,
                options
            );
        }

        await this._extendGlobalPackageJson(dest);
        await this._extendCdsrcJson(dest, options);
    }

    async _runMvn(dest, options) {
        let tempFolder;
        try {
            tempFolder = await FsHelper.createTempFolder('cds-gen-');
            const odataArchetypeCommand = MvnArchetypes.odataArchetypeCommand(
                options.javaPackage,
                options.projectName,
                options.odataVersion,
                options.verbose,
                options.debug
            );

            await ExecHelper.spawnCommand(
                odataArchetypeCommand,
                tempFolder,
                options.verbose
            );

            const mavenResultPath = path.join(
                tempFolder,
                `${options.projectName ? options.projectName + '-' : ''}srv`
            );

            // use await otherwise finally would be called and remove folder
            await FsHelper.copy(mavenResultPath, dest);
        } finally {
            if (tempFolder) {
                await FsHelper.remove(tempFolder);
            }
        }
    }

    async _patchPomXml(pomXmlPath) {
        if (await FsHelper.pathExists(pomXmlPath)) {
            const pomXml = await FsHelper.readFile(pomXmlPath);

            const pom = await XmlHelper.parse(pomXml);

            const pomPatchPluginXml = await FsHelper.readFile(
                FsHelper.getTemplate('srv/java/pom.patch.plugin.xml')
            );
            const pomPatchPlugin = await XmlHelper.parse(pomPatchPluginXml);
            pom.project.build[0].plugins = pomPatchPlugin;

            const pomPatchProfileXml = await FsHelper.readFile(
                FsHelper.getTemplate('srv/java/pom.patch.profile.xml')
            );
            const pomPatchProfile = await XmlHelper.parse(pomPatchProfileXml);
            pom.project.profiles = pom.project.profiles || []; // make sure array exists
            pom.project.profiles.unshift(pomPatchProfile);

            await FsHelper.writeFile(pomXmlPath, XmlHelper.stringify(pom));
        }
    }

    async _extendLocalPackageJson(dest) {
        const globalPackageJsonPath = path.join(dest, '..', 'package.json');
        if (await FsHelper.pathExists(globalPackageJsonPath)) {
            const globalPackageJson = await FsHelper.readJSON(globalPackageJsonPath);

            if (globalPackageJson.dependencies && globalPackageJson.dependencies.hdb) {
                const localPackageJsonPath = path.join(dest, 'package.json');
                if (await FsHelper.pathExists(localPackageJsonPath)) {
                    const localPackageJson = await FsHelper.readJSON(localPackageJsonPath);
                    localPackageJson.dependencies = localPackageJson.dependencies || {}
                    localPackageJson.dependencies.hdb = globalPackageJson.dependencies.hdb;

                    await FsHelper.writeJSON(localPackageJsonPath, localPackageJson, {
                        spaces: 4
                    });
                }
            }
        }
    }

    async _extendGlobalPackageJson(dest) {
        const packageJsonPath = path.join(dest, '..', 'package.json');
        if (await FsHelper.pathExists(packageJsonPath)) {
            const packageJson = await FsHelper.readJSON(packageJsonPath);
            packageJson.cds = packageJson.cds || {};
            const moduleFolder = path.basename(dest);

            packageJson.files = packageJson.files || [];
            if (!packageJson.files.includes(moduleFolder)) {
                packageJson.files.push(moduleFolder);
            }

            await FsHelper.writeJSON(packageJsonPath, packageJson, {
                spaces: 4
            });
        }
    }

    async _extendCdsrcJson(dest, options) {

        const cdsrcJsonPath = path.join(dest, '..', '.cdsrc.json');
        if (await FsHelper.pathExists(cdsrcJsonPath)) {
            const cdsrcJson = await FsHelper.readJSON(cdsrcJsonPath);
            cdsrcJson.build = cdsrcJson.build || {};
            cdsrcJson.build.tasks = cdsrcJson.build.tasks || [];

            const folderName = path.basename(dest);
            const newTasks = cdsrcJson.build.tasks.filter((task) => {
                return task.src !== folderName;
            });


            const buildTaskType = Constants.TASKS[Constants.MODULE_TYPE_SRV][options.srvTechnology];
            if (buildTaskType) {
                newTasks.push({
                    for: buildTaskType,
                    src: folderName,
                    options: {
                        model: options.modules // replace with folder names
                    }
                });
            }

            cdsrcJson.build.tasks = newTasks;

            await FsHelper.writeJSON(cdsrcJsonPath, cdsrcJson, {
                spaces: 4
            });
        }
    }
}

module.exports = AddSrvHandler;
