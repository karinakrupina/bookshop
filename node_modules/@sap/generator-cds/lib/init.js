const path = require('path');

const c = require('ansi-colors');

const Constants = require('./constants');
const Command = require('./command');
const AddCommand = require('./add');

const ExecHelper = require('./helper/exec_helper');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');


const CONFIG = Object.freeze({
    dbTechnology: {
        default: '',
        regex: new RegExp(Constants.REGEX_DB_TECHNOLOGY)
    },
    insecure: {
        default: false
    },
    javaPackage: {
        default: 'sample',
    },
    modules: {
        default: '',
        regex: new RegExp(Constants.REGEX_MODULES)
    },
    mta: {
        default: false
    },
    odataVersion: {
        default: 'odatav2'
    },
    skipInstall: {
        default: false
    },
    skipSampleModels: {
        default: false
    },
    srvMemory: {
        default: '512M',
        regex: /^[1-9]\d*\w?$/
    },
    srvTechnology: {
        default: 'nodejs',
        regex: new RegExp(Constants.REGEX_SRV_TECHNOLOGY)
    }
});

class InitCommand extends Command {
    constructor() {
        super(CONFIG);
        this._addCommand = new AddCommand();
    }

    get options() {
        return this._options;
    }

    async run(args, options, cdsEnv) {
        await super.run(args, options, cdsEnv);
        this._options.projectName = path.basename(path.resolve(this._options.destination));

        if (this._options.modules) {
            this._options.modules = this._options.modules.split(',');
        } else {
            this._options.modules = [];
        }

        // skip samples if not both srv and db are present
        const includesDbAndSrv = (this._options.modules.includes(Constants.MODULE_TYPE_DB) && this._options.modules.includes(Constants.MODULE_TYPE_SRV));
        this._options.skipSampleModels = this._options.skipSampleModels || !includesDbAndSrv;

        await this.execute(this._options.destination, this._options);

        await this.finalize();

        this.reportProgress(); // new line
        this.reportProgress(c.green(i18n.init_finished_successfully));
    }

    async execute(dest, options) {
        await this.checkPrecondition(dest, options);

        this.reportProgress(); // new line
        if (dest === '.') {
            this.reportProgress(i18n.init_creating_new_project_local, !options.quiet);
        } else {
            this.reportProgress(i18n.t(i18n.init_creating_new_project, {
                destination: dest
            }), !options.quiet);
        }
        this.reportProgress();

        await FsHelper.copyTemplate('project/common', dest, options);

        if (options.mta) {
            await FsHelper.copyTemplate('project/mta', dest, options);
        }

        if (!process.env[Constants.ENV_KEY_CDS_IDE]) {
            await FsHelper.copyTemplate('project/vscode', dest, options);
        }

        for (let moduleType of options.modules) {
            const moduleDest = path.join(dest, Constants.DEFAULT_MODULE_FOLDER[moduleType]);
            await this._addCommand.execute(moduleDest, moduleType, options);
        }

        if (!options.skipSampleModels) {
            if (options.modules.includes(Constants.MODULE_TYPE_DB)) {
                await FsHelper.copyTemplate(
                    'db/samples',
                    path.join(dest, Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_DB]),
                    options);
            }

            if (options.modules.includes(Constants.MODULE_TYPE_SRV)) {
                options.importDb = (options.modules.includes(Constants.MODULE_TYPE_DB)
                    ?`using my.bookshop as my from '../${Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_DB]}/data-model';`
                    : '');

                await FsHelper.copyTemplate(
                    'srv/samples',
                    path.join(dest, Constants.DEFAULT_MODULE_FOLDER[Constants.MODULE_TYPE_SRV]),
                    options);
            }
        }

        await this._stagePostProcessing(dest, options.modules, options);

    }
    async checkPrecondition(dest, options) {
        // with srv java use db hana, else print warning
        if (options.modules.includes(Constants.MODULE_TYPE_SRV)
            && options.modules.includes(Constants.MODULE_TYPE_DB)
            && options.srvTechnology === Constants.SRV_TECHNOLOGY_JAVA
            && options.dbTechnology !== Constants.DB_TECHNOLOGY_HANA) {
                this.reportWarning(i18n.init_srv_java_and_db_hana);
        }

        if (!options.force) {
            if (await FsHelper.pathExists(dest)) {
                const folderContent = await FsHelper.readdir(dest);
                if (folderContent.length > 0) {
                    throw new Error(i18n.t(i18n.command_target_exists, { dest }));
                }
            }
        }
    }

    async _stagePostProcessing(dest, modules, options) {
        // root config file processing
        const packageJsonPath = path.join(dest, 'package.json');
        this.reportProgress(i18n.t(i18n.init_updating_dependencies, {packageJsonPath}), options.verbose);
        await this.updateDependencies(packageJsonPath, options.debug);

        if (!options.skipInstall) {
            this.reportProgress(
                i18n.init_running_npm_install,
                options.verbose
            );
            const npmInstallCmd = [
                'npm',
                'install',
                '--no-package-lock',
                '--no-shrinkwrap'
            ];

            if (options.debug) {
                npmInstallCmd.push('-dd');
            }
            await ExecHelper.spawnCommand(npmInstallCmd, dest, !options.quiet);
        }
    }
}

module.exports = InitCommand;
