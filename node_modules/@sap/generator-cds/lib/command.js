const os = require('os');
const path = require('path');

const c = require('ansi-colors');

const Constants = require('./constants');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');
const Logger = require('./logger/logger');
const NpmDependenciesHelper = require('./helper/npm_dependencies_helper');
const OptionsHelper = require('./helper/options_helper');

const CONFIG = Object.freeze({
    force: {
        default: false
    },
    quiet: {
        default: false
    },
    verbose: {
        default: false
    },
    debug: {
        default: !!process.env.DEBUG
    }
});

class Command {
    constructor(childConfig) {
        this._config = { ...CONFIG, ...childConfig };

        this._options = {};
        this._cmdOptions = [];
        this._cmdFlags = [];

        // create OPTIONS and FLAGS arrays
        for (let key in this._config) {
            const configEntry = this._config[key];
            const cmdLine = OptionsHelper.generateCmdLine(key);
            if (typeof configEntry.default === 'boolean') {
                this._cmdFlags.push(cmdLine);
            } else {
                this._cmdOptions.push(cmdLine);
            }
        }
    }

    get options() {
        return this._options;
    }

    get cmdOptions() {
        return this._cmdOptions;
    }

    get cmdFlags() {
        return this._cmdFlags;
    }

    run(args, options, cdsEnv) {
        options = OptionsHelper.convertOptions(options);

        for (let configName in this._config) {
            let configValue = this._config[configName].default;

            this._options[configName] = configValue;
        }

        for (let optionName in options) {
            let optionValue = options[optionName];
            let option = this._config[optionName];

            if (!option) {
                throw new Error(
                    i18n.t(i18n.command_invalid_option, {
                        optionName,
                        optionValue
                    })
                );
            }

            if (typeof optionValue === 'string') {
                optionValue = optionValue.replace(/\s+/g, '');

                if (option.regex && !optionValue.match(option.regex)) {
                    throw new Error(
                        i18n.t(i18n.command_invalid_option_value, {
                            optionName,
                            optionValue
                        })
                    );
                }
            }

            this._options[optionName] = optionValue;
        }

        if (this._options.debug) {
            this._options.verbose = true;
            this._options.quiet = false;
        } else {
            if (this._options.verbose) {
                this._options.quiet = false;
            }
        }

        this._optionsProcessing(args, this._options, cdsEnv);
    }

    async finalize() {
        // print summary
        if (this._options.debug || process.env.GENERATION_LOG) {
            const createdFiles = FsHelper.getCreatedFiles();

            if (this._options.debug) {
                this.reportProgress();
                this.reportProgress(i18n.command_summary);

                createdFiles.forEach(file => {
                    this.reportProgress(i18n.t(i18n.command_created, { file }));
                });
            }

            if (process.env[Constants.ENV_VAR_GENERATION_LOG]) {
                const fileList = createdFiles.join(os.EOL);
                await FsHelper.writeFile(
                    process.env[Constants.ENV_VAR_GENERATION_LOG],
                    fileList,
                    true
                );
            }
        }
    }

    _optionsProcessing(args, options, cdsEnv) {
        // arg processing

        options.destination = path.normalize(args[0] || '.');

        options.genFolder =
            (cdsEnv && cdsEnv.build && cdsEnv.build.target) || Constants.DEFAULT_GEN_FOLDER;
    }

    reportProgress(message = '', show = true) {
        if (show) {
            Logger.info(message);
        }
    }

    reportWarning(message) {
        Logger.warn(c.yellow(message));
    }

    async updateDependencies(packageJsonPath, debug = false) {
        if (await FsHelper.pathExists(packageJsonPath)) {

            const packageJson = await FsHelper.readJSON(packageJsonPath);
            const newDependencies = await NpmDependenciesHelper.updateDependencies(
                packageJson.dependencies,
                debug
            );
            packageJson.dependencies = newDependencies;

            await FsHelper.writeJSON(packageJsonPath, packageJson, {
                spaces: 4
            });
        }
    }

    isWebIDE() {
        return process.env[Constants.ENV_KEY_CDS_IDE] === Constants.ENV_KEY_CDS_IDE_WEBIDE;
    }
}

module.exports = Command;
