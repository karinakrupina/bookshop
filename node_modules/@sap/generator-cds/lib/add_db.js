const path = require('path');

const Constants = require('./constants');
const FsHelper = require('./helper/fs_helper');
const i18n = require('./i18n/i18n');
const MTAHelper = require('./helper/mta_helper');
const NpmDependenciesHelper = require('./helper/npm_dependencies_helper');



class AddDbHandler {
    constructor(addCommand) {
        this._addCommand = addCommand;
    }

    async stageCopyTemplates(dest, options) {
        this._addCommand.reportProgress(i18n.t(i18n.add_copying_templates, { dest, moduleType: Constants.MODULE_TYPE_DB }), options.verbose);

        if (options.dbTechnology === Constants.DB_TECHNOLOGY_HANA) {
            await FsHelper.copyTemplate('db/hana', dest, options);
        }
    }

    async stagePostProcessing(dest, options) {
        const yamlPath = path.join(dest, '..', 'mta.yaml');
        if (await FsHelper.pathExists(yamlPath)) {
            this._addCommand.reportProgress(i18n.t(i18n.init_creating_mta_file, { yamlPath }), options.verbose);
            await MTAHelper.update(
                dest,
                yamlPath,
                Constants.MODULE_TYPE_DB,
                options
            );
        }

        await this._extendPackageJson(dest, options);
        await this._extendCdsrcJson(dest, options);
    }

    async _extendPackageJson(dest, options) {
        const packageJsonPath = path.join(dest, '..', 'package.json');
        if (await FsHelper.pathExists(packageJsonPath)) {
            const packageJson = await FsHelper.readJSON(packageJsonPath);

            const moduleFolder = path.basename(dest);

            if (options.dbTechnology === Constants.DB_TECHNOLOGY_HANA) {
                packageJson.cds = packageJson.cds || {};
                packageJson.cds.requires = packageJson.cds.requires || {};

                packageJson.cds.requires[Constants.PRIMARY_DB] = packageJson.cds.requires[Constants.PRIMARY_DB] || {};
                packageJson.cds.requires[Constants.PRIMARY_DB].kind = Constants.DB_TECHNOLOGY_HANA;
                packageJson.cds.requires[Constants.PRIMARY_DB].model = moduleFolder;

                packageJson.dependencies = packageJson.dependencies || {};
                packageJson.dependencies.hdb = NpmDependenciesHelper.REPLACE_TOKEN;

                const newDependencies = await NpmDependenciesHelper.updateDependencies(packageJson.dependencies, options.debug);
                packageJson.dependencies = newDependencies;
            }

            packageJson.files = packageJson.files || [];
            if (!packageJson.files.includes(moduleFolder)) {
                packageJson.files.push(moduleFolder);
            }

            await FsHelper.writeJSON(packageJsonPath, packageJson, {
                spaces: 4
            });
        }
    }

    async _extendCdsrcJson(dest, options) {

        const cdsrcJsonPath = path.join(dest, '..', '.cdsrc.json');
        if (await FsHelper.pathExists(cdsrcJsonPath)) {
            const cdsrcJson = await FsHelper.readJSON(cdsrcJsonPath);
            cdsrcJson.build = cdsrcJson.build || {};
            cdsrcJson.build.tasks = cdsrcJson.build.tasks || [];

            const folderName = path.basename(dest);
            const newTasks = cdsrcJson.build.tasks.filter((task) => {
                return task.src !== folderName;
            });


            const buildTaskType = Constants.TASKS[Constants.MODULE_TYPE_DB][options.dbTechnology];
            if (buildTaskType) {
                newTasks.push({
                    for: buildTaskType,
                    src: folderName,
                    options: {
                        model: options.modules // replace with folder names
                    }
                });
            }

            cdsrcJson.build.tasks = newTasks;

            await FsHelper.writeJSON(cdsrcJsonPath, cdsrcJson, {
                spaces: 4
            });
        }
    }
}

module.exports = AddDbHandler;
