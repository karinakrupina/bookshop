// Compiler phase "resolve": resolve all references

// The resolve phase tries to find the artifacs (and elements) for all
// references in the augmented CSN.  If there are unresolved references, this
// compiler phase fails with an error containing a vector of corresponding
// messages (alternatively, we could just store this vector in the CSN).

// References are resolved according to the scoping rules of CDS specification.
// That means, the first name of a reference path is not only searched in the
// current environments, but also in the parent environments, with the source
// as second-last, and the environment for builtins as the last search
// environment.

// For all type references, we set the property `type._artifact`, the latter is
// the actual type definition.

// If the referred type definition has a `parameters` property, we use it to
// transform the `typeArguments` property (sibling to the `type` property`) to
// named properties.  See function `resolveTypeExpr` below for details.

// Example 'file.cds' (see './definer.js' for the CSN before "resolve"):
//   type C { elem: String(4); }
//
// The corresponding definition of element "elem" looks as follows:
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: ... }
//     type: { absolute: 'cds.String', _artifact: {...}, path: ...},
//     length: { val: 4, location: <of the number literal> },
//     location: ..., _parent: ...
//   }

'use strict';

const { queryOps, setProp, forEachDefinition, forEachMember, forEachGeneric, forEachInOrder }
      = require('../base/model');
var { addToDict, addToDictWithIndexNo, clearDict, dictLocation }
    = require('../base/dictionaries');
const { getMessageFunction, searchName, weakLocation } = require('../base/messages');

var detectCycles = require('./cycle-detector');
const layers = require('./moduleLayers');

var { kindProperties, fns, setLink, linkToOrigin, setMemberParent, withAssociation, storeExtension }
    = require('./shared');

const annotationPriorities = { define: 1, extend: 2, annotate: 2, edmx: 3 };


// Export function of this file.  Resolve type references in augmented CSN
// `model`.  If the model has a property argument `messages`, do not throw
// exception in case of an error, but push the corresponding error object to
// that property (should be a vector).
function resolve( model, options = model.options || {} ) {
  // Get shared "resolve" functionality and the message function:
  const { resolvePath, defineAnnotations }
        = fns( model, environment );
  const message = getMessageFunction( model );
  return main();

  function main() {
    // Phase 1: check paths in usings:
    forEachGeneric( model, 'sources', resolveUsings );
    // Phase 2: calculate/init view elements & collect views in order:
    forEachDefinition( model, populateView );
    // Phase 3: calculate keys along simple queries in collected views:
    model._entities.forEach( propagateKeyProps );
    // Phase 4: resolve all artifacts:
    forEachDefinition( model, resolveRefs );
    // Phase 5: rewrite associations:
    if (options.assocOnRewrite) {
      forEachDefinition( model, rewriteSimple );
      // TODO: sequence not good enough with derived type of structure with
      // includes: first "direct" structures, then _entities, then the rest
      model._entities.forEach( rewriteView );
    }
    // Phase 6: report cyclic dependencies:
    detectCycles( model.definitions, function( art, location, user ) {
      if (location) {
        message( 'ref-cyclic', location, user, { art }, 'Error', {
          std:     'Illegal circular reference to $(ART)',
          element: 'Illegal circular reference to element $(MEMBER) of $(ART)'
        });
      }
    });
    // Phase 7: apply ANNOTATE on unknown artifacts:
    if (model.extensions)
      model.extensions.map( annotateUnknown );
    return model;
  }

  // Resolve the using declarations in `using`.  If not compiled with lint-mode
  // or if it is a reference for a builtin (path starts with `cds`), issue
  // error message if the referenced artifact does not exist.
  function resolveUsings( src ) {
    if (!src.usings)
      return;
    for (let def of src.usings) {
      if (def.usings)           // using {...}
        resolveUsings( def );
      if (!def.name)            // using {...} or parse error
        continue;
      let art = model.definitions[ def.name.absolute ];
      if (art instanceof Array)
        continue;
      let ref = def.extern;
      if (ref.dcPath) {
        let head = ref.path[0];
        let id = ref.dcPath.map( id => id.id ).join('.') + '::' + head.id;
        let location = {
          filename: head.location.filename,
          start: ref.location.start,
          end: head.location.end
        }
        ref = { path: [ { id, location }, ...ref.path.slice(1) ], location: ref.location };
      }
      resolvePath( ref, 'global', def ); // TODO: consider FROM for validNames
    }
  }


  //--------------------------------------------------------------------------
  // The central functions for path resolution - must work on-demand
  //--------------------------------------------------------------------------
  // Phase 2: call populateView(), which also works on-demand

  // Return effective search environment provided by artifact `art`, i.e. the
  // `artifacts` or `elements` dictionary.  For the latter, follow the `type`
  // chain and resolve the association `target`.  View elements are calculated
  // on demand.
  function environment( art ) {
    if (!art)
      return Object.create(null);
    if (art.artifacts)
      return art.artifacts;
    let type = finalType(art) || art;
    if (type.target)            // TODO: implicit redirection in derived type
      type = resolvePath( type.target, 'target', type ) || {};
    populateView( type );
    return type.elements || Object.create(null);
  }

  // Follow the `type` chain, i.e. derived types and TYPE OF, stop just before
  // built-in types (otherwise, we would loose type parameters).  Return that
  // type and set it as property `_finalType` on all artifacts on the chain.
  // TODO: clarify for (query) elements without type: self, not undefined - also for entities!
  // TODO: directly "propagate" (with implicit redirection the targets), also
  // "proxy-copy" elements
  function finalType( art ) {
    if ('_finalType' in art)
      return art._finalType;

    // console.log(message( null, art.location, art, {}, 'Info','FT').toString())
    var chain = [];
    while (art && !('_finalType' in art) &&
           (art.type || art.origin || art.value && art.value.path) && // TODO: items
           !art.target && !art.enum) {
      chain.push( art );
      setProp( art, '_finalType', 0 ); // initial setting in case of cycles
      art = directType( art );
    }
    if (art) {
      if (art.builtin && chain.length) {
        let builtin = art;
        art = chain.pop();
        if (art.length || art.precision || art.scale || art.typeArguments)
          setProp( art, '_finalType', art );
        else {
          setProp( art, '_finalType', builtin );
          art = builtin;
        }
      }
      else if ('_finalType' in art) {
        art = art._finalType;
      }
      else {
        setProp( art, '_finalType', art );
      }
    }
    chain.reverse();
    for (let a of chain) {
        // TODO: we had (git tag 'nr-hana') an auto expansion of referred
      // structure types if there existed an annotation assignment for elements
      // of that referred type.  This is not such a good idea since later
      // annotation would not have this effect.  It is better to provide an
      // compiler option --expand-structures which would always expand referred
      // structure types.
      if (art && art.target && options.newRedirectImpl && redirectImplicitly( a, art ))
        art = a;
      setProp( a, '_finalType', art );
    }
    return art;
  }

  function directType( art ) {
    // Be careful when using it with art.target or art.enum or art.elements
    if (art.origin)             // TODO: _origin
      return art.origin._artifact;
    if (art.type)
      return resolveType( art.type, art );
    // console.log( 'EXPR-IN', art.kind, refString(art.name) )
    let query = art._parent && art._parent._leadingQuery || art._parent; // TODO: re-check leading
    // console.log( 'EXPR-QUERY', query.kind, refString(query.name) )
    if (!query || query.kind !== 'query' || !art.value.path)
      return undefined;
    // Reached an element in a query which is a simple ref -> return referred artifact
    // TODO: remember that we still have to resolve path arguments and filters
    return resolvePath( art.value, 'expr', art, query.$combined );
    // console.log( 'EXPR-OUT', art.value._artifact.kind, refString(art.value._artifact.name) );
  }

  // TODO (when --hana-flavor dies): remove this function
  function resolveType( ref, user ) {
    if ('_artifact' in ref)
      return ref._artifact;
    if (!ref.resolveSemantics)
      return resolvePath( ref, 'type', user );
    // currently just `typeOf`
    if (options.hanaFlavor && ref.path.length > 1)
      return resolvePath( ref, 'type', user );
    let parent = user._parent || user;
    if (parent.elements)
      return resolvePath( ref, 'typeOf', user, parent.elements );
    else if (ref.path && ref.path[0])
      message( 'ref-undefined-element', ref.location, user,
               { art: searchName( parent, ref.path[0].id ) } );
    setProp( ref, '_artifact', null );
    return undefined;
  }

  // Make a view to have elements (remember: wildcard), and prepare that their
  // final type can be resolved, i.e. we know how to resolve select item refs.
  // We do so by first populate views in the FROM clause, then the view query.
  function populateView( art ) {
    if (!art.$from || art._status === '_query')
      return;
    let resolveChain = [];
    let fromChain = [art];
    while (fromChain.length) {
      let view = fromChain.pop();
      if (view._status === '_query') // already fully resolved (status at def)
        continue;
      resolveChain.push( view );
      for (let from of view.$from) {
        if (from._status)       // status at the ref -> illegal recursion -> stop
          continue;
        setProp( from, '_status', '_query' );
        // setProp before resolvePath - Cycle: view V as select from V.toV
        let source = resolvePath( from, 'from', view ); // filter and args in resolveQuery
        // console.log('ST:',msgName(source),from._status)
        if (source && source._main) { // element -> should be assoc
          let type = finalType( source );
          source = type && type.target;
        }
        if (source && source.$from && source._status !== '_query') {
          fromChain.push( source );
        }
      }
    }
    // console.log( resolveChain.map( v => msgName(v)+v._status ) );
    for (let view of resolveChain.reverse()) {
      if (view._status !== '_query' ) { // not already resolved
        setProp( view, '_status', '_query' );
        traverseQueryPost( view.query, false, populateQuery );
        inheritActions( view );
        model._entities.push( view );
      }
    }
  }

  function populateQuery( query ) {
    if (query.$combined)        // already done
      return;
    query.$combined = Object.create(null);
    forEachGeneric( query, '$tableAliases', resolveTabRef );
    if (!query.from)
      return;                   // just "query" for JOIN ... ON

    initFromColumns( query, query._main._leadingQuery === query && query._main.elements );
    if (query.exclude) {
      for (let name in query.exclude)
        resolveExcluding( name );
    }
    forEachGeneric( query, 'elements', initElem );
    return;

    function resolveTabRef( alias ) {
      if (alias.kind === 'element' || alias.self) // mixin element or $projection
        return;
      if (!alias.$navigation) { // TODO: should always be true
        // if (main._block.$frontend!=='json') console.log('TABREF:',alias.name,main,main._block)
        let tab = resolvePath( alias.type, 'from', query );
        let elements = environment( alias ); // works for table ref (incl assoc) and sub query
        forEachGeneric( { elements }, 'elements', function( origin, name ) {
          let elem = linkToOrigin( origin, name, alias, '$navigation',
                                   (tab||origin).name.location );
          elem.kind = '$navElement';
          // setProp( elem, '_fromAlias', alias );  same as _parent
          setProp( elem, '_finalType', finalType(origin) );
          // elem.name.query = query.name.query; 
          if (origin.masked)
            elem.masked = Object.assign( { $inferred: 'nav' }, origin.masked );
        });
      }
      forEachGeneric( { elements: alias.$navigation }, 'elements', function( elem, name ) {
        addToDict( query.$combined, name, elem, null );
      });
    }

    function resolveExcluding( name ) {
      if (query.$combined[name])
        return;
      message( 'ref-undefined-excluding', query.exclude[name].location, query, { name },
               'Info', 'Element $(NAME) has not been found' )
        .validNames = query.$combined;
      if (options.testMode)
        message( null, query.exclude[name].location, null, {}, 'Info',
                 'Valid: ' + Object.keys( query.$combined ).sort().join(', ') );
    }

    function initElem( elem ) {
      //if (elem.type) console.log(msgName(elem),elem)
      // TODO: make sure that EXTEND ENTITY cannot be used on view (only ad-hoc mixin)
      if (elem.type && !elem.type.$inferred && !elem.viaAll)
        return;                 // explicit type -> enough or directType()
      if (elem.viaAll) {
        // redirectImplicitly( elem, elem.origin._artifact );
        return;
      }
      if (!elem.value || !elem.value.path) // TODO: test $inferred
        return;                 // no value ref or $inferred
      // TODO: what about SELECT from E { $projection.a as a1, a } !!!!!!

      //console.log(msgName(query),query.name.query,query.$tableAliases,msgName(elem))
      let origin = resolvePath( elem.value, 'expr', elem, query.$combined );
      // TODO: make this resolvePath() also part of directType() ?!
      if (!origin)
        return;
      elem.origin = elem.value; // TODO: remove origin, make it a _origin = origin._artifact
      // now set things which are necessary for later sub phases:
      let nav = pathNavigation( elem.value );
      if (nav.navigation && nav.item === elem.value.path[ elem.value.path.length-1 ]) {
        addProjection( elem, nav.navigation ); // for rewrite (from source or mixin), TODO: introduce a pushLink function
        // redirectImplicitly( elem, origin );
      }
    }
  }

  function redirectImplicitly( elem, assoc ) {
    // PRE: elem has no target, assoc has target prop
    let service = (elem._main||elem)._service;
    let target = resolvePath( assoc.target, 'target', assoc );
    // console.log(message( null, elem.location, elem, {target,art:assoc,name:''+assoc.target}, 'Info','RED').toString())
    if (!target)
      return false;             // error in target ref
    let location = (elem.value||elem.type||elem.name).location;
    let exposed = service &&
        target._service !== service &&
        (assoc._main||assoc)._service !== service &&
        target._descendants &&
        target._descendants[ service.name.absolute ];
    if (exposed && exposed.length) {
      if (exposed.length === 1) {
        target = exposed[0];
      }
      else {
        let names = exposed.map( e => e.name.absolute ).sort();
        message( 'redirected-implicitly-ambiguous', (elem.value||elem.name).location, elem,
                 { target, art: service, names }, 'Warning',
                 'Target $(TARGET) is exposed in service $(ART) by multiple projections $(NAMES) - no implicit redirection'
               );
      }
    }
    elem.target = {
      path: [ { id: target.name.absolute, location } ],
      scope: 'global',
      location,
      $inferred: (target !== assoc.target._artifact ? 'IMPLICIT' : 'rewrite' )
    };
    setLink( elem.target, target );
    // console.log(message( null, elem.location, elem, {target}, 'Info',elem.target.$inferred).toString())
    return true
  }

  function addProjection( proj, nav ) {
    if (nav._projections)
      nav._projections.push( proj )
    else
      setProp( nav, '_projections', [proj] );
  }

  // TODO: make this function shorter
  function initFromColumns( query, specifiedElements ) {
    let elements = specifiedElements || Object.create(null);
    if (specifiedElements)
      query.elements = specifiedElements;
    else {
      clearDict( query, 'elements' );
      if (query._main._leadingQuery === query)
        query._main.elements = query.elements;
    }
    let wildcard = false;
    for (let col of query.columns || [{ val: '*' }]) {
      if (col.val === '*') {
        wildcard = col.location || query.from[0] && query.from[0].location || query.location;
        continue;
      }
      col.kind = 'element';
      if (!col.value)
        continue;             // error should have been reported by parser
      if (!col.name) {
        let path = col.value.path;
        if (!path) {
          message( 'query-req-name', col.value.location || col.location, query, {},
                   'Error', 'Alias name is required for this select item' );
        }
        else if (path.length && !path.broken) {
          let last = path[ path.length-1 ];
          if (last)
            col.name = { id: last.id, location: last.location, $inferred: 'as' };
        }
        if (!col.name) {
          // invent a name for code completion in expression
          col.name = { id: '', location: col.value.location, $inferred: 'none' };
        }
      }
      let id = col.name.id;
      let elem = specifiedElements && specifiedElements[id];
      if (elem) {
        elem.value = col.value;
        elem.$replacement = true;
        // `on` and `keys` rewrite not finished yet:
        delete elem.onCond;
        delete elem.foreignKeys;
        if (elem.target)
          delete elem.type;
        else if (elem.type && !col.type)
          elem.type.$inferred = 'elements';
        delete elem.target;
        if (col.target) {     // TODO: get rid of redirected property
          elem.redirected = { val: true, location: col.target.location };
          elem.target = col.target;
        }
        if (elem.key && !col.key)
          elem.key.$inferred = 'elements';
        setProp( elem, '_parent', query );
        elem.name.query = query.name.query;
        continue;
      }
      if (specifiedElements && id) {
        message( 'query-missing-element', col.name.location, query, { id },
                 'Warning', 'Element $(ID) is missing in specified elements' );
      }
      addToDict( elements, id, col, function( name, location ) {
        message( 'duplicate-definition', location, query, { name, '#': 'element' },
                 'Error', { element: 'Duplicate definition of element $(NAME)' } );
      });
      setMemberParent( col, id, query );
      if (!wildcard) {
        addToDictWithIndexNo( query, 'elements', id, col );
        col.$replacement = true;
      }
    }
    if (wildcard)
      expandWildcard( elements, wildcard, specifiedElements );
    if (specifiedElements) {
      for (let name in specifiedElements) {
        let elem = specifiedElements[name];
        if (!elem.$replacement && elem.name) // no name with redefs
          message( 'query-unspecified-element', elem.name.location, query, { id: name },
                   'Error', 'Element $(ID) is not properly specified' );
      }
    }
    return;

    // TODO: make this function shorter, probably outside initFromColumns
    function expandWildcard( elements, location, specifiedElements ) {
      let exclude = query.exclude || Object.create(null);
      // TODO: paths in exclude? - Did I mention it? EXCLUDING is ill-defined...
      for (let name in query.$combined) {
        let navElem = query.$combined[name];
        if (exclude[name] || navElem.masked && navElem.masked.val)
          continue;
        let selElem = elements[name];
        if (selElem && (!specifiedElements || selElem.$replacement)) {
          if (!selElem.name)    // no name with parse error or repeated def
            continue;
          let path = selElem.value && selElem.value.path;
          // TODO: to bring the message below for ParentElem.Assoc, we should move this
          // check to resolveElem for elems with $replacement, by comparing the
          // name with the name.element of the _origin.
          // We cannot check path.length === 1, as we want to allow Alias.Elem.
          // TODO: bring this less often (only if shadowed elem does not appear in expr and if not projected as other name)
          if (!selElem.redirected && selElem.$replacement !== 'silent' ||
              path && path[ path.length-1 ].id !== selElem.name.id) {
            if (navElem instanceof Array)
              message( 'wildcard-excluding-many', selElem.name.location, query, { id: name },
                       'Info', 'This select item replaces $(ID) from two or more sources' );
            else
              message( 'wildcard-excluding-one', selElem.name.location, query,
                       { id: name, alias: navElem._parent.name.id },
                       'Info', 'This select item replaces $(ID) from table alias $(ALIAS)' );
          }
          if (!selElem.$replacement || selElem.$replacement === 'silent') {
            selElem.$replacement = true;
            addToDictWithIndexNo( query, 'elements', name, selElem );
          }
          selElem.$inferred = 'query';
        }
        else if (navElem instanceof Array) {
          let names = navElem.filter( e => !e.$duplicate)
              .map( e => e.name.alias + '.' + e.name.element );
          if (names.length)
            message( 'wildcard-ambiguous', location, query, { id: name, names },
                     'Error', 'Ambiguous wildcard, select $(ID) explicitly with $(NAMES)' );
        }
        else if (selElem) {     // from specified elements of leading query
          // TODO: use location of specified element
          let origin = navElem.origin._artifact;
          selElem.origin = { location };
          delete selElem.origin.id;
          delete selElem.origin.quoted;
          let elem = selElem;
          setProp( selElem.origin, '_artifact', origin );
          setElementOrigin( elem, navElem, name, location );
          if (elem.key)
            elem.key.$inferred = '*'; // not entirely correct
          selElem.$replacement = true;
          // `on` and `keys` rewrite not finished yet:
          delete selElem.onCond;
          delete selElem.foreignKeys;
          if (selElem.target)
            delete selElem.type;
          else if (selElem.type)
            selElem.type.$inferred = '*';
          delete selElem.target;
          selElem.$inferred = 'query';
          // if (selElem.key)
          //   selElem.key.$inferred = '*'; // part of setElementOrigin
          // TODO: we could check whether all properties on the column has been
          // properly propageted: annotation assignments, type properties
        }
        else {
          if (specifiedElements) {
            message( 'query-missing-element', location, query, { id: name },
                     'Warning', 'Element $(ID) is missing in specified elements' );
          }
          location = weakLocation( location );
          let origin = navElem.origin._artifact;
          let elem = linkToOrigin( origin, name, query, 'elements', location );
          elem.$inferred = '*';
          elem.name.$inferred = '*';
          elem.name.calculated = true;
          elem.viaAll = true;
          setElementOrigin( elem, navElem, name, location );
        }
      }
      forEachInOrder( { elements }, 'elements', function (elem, name) {
        if (!elem.$replacement)
          addToDictWithIndexNo( query, 'elements', name, elem );
      });
    }
  }

  function setElementOrigin( queryElem, navElem, name, location ) {
    let sourceElem = navElem.origin._artifact;
    let alias      = navElem._parent;
    let path       = [ { id: alias.name.id, location }, { id: name, location } ];
    queryElem.value = queryElem.origin;
    // always expand * to path with table alias (reason: columns current_date etc)
    queryElem.value.path = path;
    let real = alias.origin || alias.type; // is undefined for sub query
    setProp( path[0], '_artifact', real && real._artifact || alias );
    setProp( path[0], '_navigation', alias );
    setProp( path[1], '_artifact', sourceElem );
    addProjection( queryElem, navElem );
    // TODO: _finalType?
  }

  function inheritActions( view ) {
    let primary = view.$from[0] && view.$from[0]._artifact;
    if (!primary || !primary.actions)
      return;
    let location = view.$from[0].location;
    let actions = view.actions || Object.create(null);
    clearDict( view, 'actions' );
    forEachGeneric( primary, 'actions', function( origin, id ) {
      let own = actions[id];
      if (!own) {
        let action = linkToOrigin( origin, id, view, 'actions', location );
        action.$inferred = 'proxy';
      }
      else if (!own.$inferred) {
        // TODO: or in-place if shadowed?  But the order is unimportant anyway...
        message( 'shadowed-action', own.name.location, view, { id, art: primary },
                 'Info', 'This definition shadows action $(ID) of $(ART)' );
      }
    });
    forEachGeneric( {actions}, 'actions', function( action, name ) {
      addToDictWithIndexNo( view, 'actions', name, action );
    });
  }


  //--------------------------------------------------------------------------
  // Phase 3: calculate propagated KEYs
  //--------------------------------------------------------------------------

  function propagateKeyProps( view ) {
    // console.log(message( null, view.location, {art:view}, 'Info','$(ART)').toString())
    traverseQueryPost( view.query, true, function propagate( query ) {
      if (!withExplicitKeys( query ) && inheritKeyProp( query ) &&
          withKeyPropagation( query )) // now the part with messages
        inheritKeyProp( query, true );
    } );
  }

  function withExplicitKeys( query ) {
    for (let name in query.elements) {
      let es = query.elements[name];
      for (let elem of (es instanceof Array) ? es : [es]) {
        if (elem.key)           // also those from includes
          return true;
      }
    }
    return false;
  }

  function inheritKeyProp( query, doIt ) {
    for (let name in query.elements) {
      let elem = query.elements[name];
      if (elem instanceof Array)
        continue;
      let nav = pathNavigation( elem.value );
      if (!nav.navigation)
        continue;            // undefined, expr, $magic, :const, $self (!), $self.elem
      let item = nav.item;
      if (item !== elem.value.path[ elem.value.path.length-1 ])
        continue;         // having selected a sub elem / navigated along assoc
      let key = item._artifact.key;
      if (key) {
        if (!doIt)
          return true;
        elem.key = { location: elem.value.location, val: key.val, $inferred: 'query' };
      }
    }
    return false;
  }

  function withKeyPropagation( query ) {
    let from = query.from[0];
    while (from instanceof Array)
      from = from[0];
    if (!from)                  // parse error SELECT FROM <EOF>
      return false;

    let propagateKeys = true;   // used instead early RETURN to get more messages
    let toMany = withAssociation( from, targetMaxNotOne, true );
    if (toMany) {
      propagateKeys = false;
      message( 'query-from-many', toMany.location, query, { art: toMany },
               'Info', {
                 std: 'Selecting from to-many association $(ART) - key properties are not propagated',
                 element: 'Selecting from to-many association $(MEMBER) of $(ART) - key properties are not propagated'
               } );
    }
    // Check that all keys from the source are projected:
    let notProjected = [];
    let navElems = query._firstAliasInFrom && query._firstAliasInFrom.$navigation;
    for (let name in navElems) {
      let nav = navElems[name];
      if (nav instanceof Array)
        continue;
      let key = nav.origin._artifact.key;
      if (key && key.val && !(nav._projections && nav._projections.length))
        notProjected.push( nav.name.id );
    }
    if (notProjected.length) {
      propagateKeys = false;
      message( 'query-missing-keys', from.location, query, { names: notProjected },
               'Info', {
                 std: 'Keys $(NAMES) have not been projected - key properties are not propagated',
                 one: 'Key $(NAMES) has not been projected - key properties are not propagated'
               } );
    }
    // Check that there is no to-many assoc used in select item:
    for (let name in query.elements) {
      let elem = query.elements[name];
      if (!elem.$inferred && elem.value &&
          testExpr( elem.value, selectTest, ()=>false ))
        propagateKeys = false;
    }
    return propagateKeys;

    function selectTest( expr ) {
      let art = withAssociation( expr, targetMaxNotOne );
      if (art) {
        message( 'query-navigate-many', art.location, query, { art },
                 'Info', {
                   std: 'Navigating along to-many association $(ART) - key properties are not propagated',
                   element: 'Navigating along to-many association $(MEMBER) of $(ART) - key properties are not propagated',
                   alias: 'Navigating along to-many mixin association $(MEMBER) - key properties are not propagated'
                 } );
      }
      return art;
    }
  }

  //--------------------------------------------------------------------------
  // Phase 4:
  //--------------------------------------------------------------------------

  // TODO: have $applied/$extension/$status on extension with the following values
  //  - 'unknown': artifact to extend/annotate is not defined or contains unknown member
  //  - 'referred': contains annotation for element of referred type (not yet supported)
  //  - 'inferred': only contains extension for known member, but some inferred ones
  //    (inferred = elements from structure includes, query elements)
  //  - 'original': only contains extensions on non-inferred members

  // Resolve all references in artifact or element `art`.  Do so recursively in
  // all sub elements.
  // TODO: make this function smaller
  function resolveRefs( art ) {
    finalType( art );           // make sure implicitly redirected target exists
    // console.log(message( null, art.location, art, {target:art.target}, 'Info','RR').toString())
    if (!art._deps)
      setProp( art, '_deps', [] );
    if (art.key && !art.key.$inferred && art._parent &&
        !['entity', 'view', 'query'].includes( art._parent.kind ))
      message( 'unexpected-key', art.key.location, art, {},
               'Warning', 'KEY is only supported for elements in an entity or view' );

    let thing = art.returns || art;
    let obj = thing.items || thing; // the object which has type properties
    //console.log(art.name, art._block, obj)
    if (obj.type)
      resolveTypeExpr( obj, art );
    if (obj.target) {
      if (!obj.target.$inferred)
        resolveTarget( art, obj );
      else if (obj.target.$inferred === 'IMPLICIT')
        resolveRedirected( art, obj.target._artifact );
    }
    if (art.targetElement) {    // in foreign keys
      let target = art._parent && art._parent.target;
      if (target && target._artifact) {
        // we just look in target for the path
        // TODO: also check that we do not follow associations? no args, no filter
        resolvePath( art.targetElement, 'element', art,
                     environment( target._artifact ), target._artifact );
      }
    }
    // Resolve projections/views
    if (art.$from)              // use $from to avoid queries by old augmentor
      traverseQueryPost( art.query, false, resolveQuery );
    if (obj.type || obj.origin || obj.value && obj.value.path || obj.elements) // typed artifacts
      finalType(obj);  // set _finalType if appropriate, (future?): copy elems if extended
    if (thing.items)
      setProp( thing, '_finalType', thing );

    if (obj.elements)           // silent dependencies
      forEachGeneric( obj, 'elements', elem => { art._deps.push( { art: elem } ) } );
    if (obj.foreignKeys)        // silent dependencies
      forEachGeneric( obj, 'foreignKeys', elem => { art._deps.push( { art: elem } ) } );

    resolveExpr( art.default, 'const', art );
    resolveExpr( art.value, 'expr', art );
    if (art.kind === 'element')
      finalType( art );

    resolveTechnicalConfig( art );

    annotateMembers( art );     // TODO recheck - recursively, but also forEachMember below
    for (let prop in art) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, art );
    }

    if (!art.source)            // don't run for old augmentor - locations missing - TODO: remove
      forEachMember( art, resolveRefs );
  }

  // resolve all paths inside a technical configuration
  function resolveTechnicalConfig( art ) {
    // user required? works only with extDict = art.elements is that so?
    let tc = art.technicalConfig;
    if (!tc)
      return;
    if (!options.hanaFlavor && !options.betaMode && tc.location) {
      message( null, tc.location, art, {}, 'Error',
               'TECHNICAL CONFIGURATION is not supported yet' );
    }

    // secondary and fulltext indexes
    forEachGeneric( tc, 'indexes', (index) => {
      index.columns.forEach( col => {
        resolvePath( col, 'element', art, art.elements );
      });
      if (index.language)
        resolvePath( index.language.column, 'element', art, art.elements );
      resolvePath( index.mimeTypeColumn, 'element', art, art.elements );
    });
    // fuzzy indexes
    if (tc.fzindexes)
      tc.fzindexes.forEach( i => {
        i.columns.forEach(c => {
          resolvePath( c, 'element', art, art.elements )
        });
      });
    // partition expressions
    if (tc.partition) {
      tc.partition.specs.forEach( s => {
        s.columns && s.columns.forEach( p => {
          resolvePath( p, 'element', art, art.elements)
        })
      })
    }
  }

  // Phase 4 - annotations ---------------------------------------------------

  function annotateUnknown ( ext ) {
    if (ext.$extension)         // extension for known artifact -> already applied
      return;
    annotateMembers( ext );
    for (let prop in ext) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, ext );
    }
  }

  function annotateMembers( art, extensions = [], prop, name, parent, kind ) {
    let showMsg = !art && parent && parent.kind !== 'annotate';
    if (!art && extensions.length) {
      let parentExt = extensionFor(parent);
      art = parentExt[prop] && parentExt[prop][name];
      if (!art) {
        art = {
          kind,                 // for setMemberParent()
          name: { id: name, location: extensions[0].name.location },
          location: extensions[0].location
        };
        setMemberParent( art, name, extensionFor(parent), prop );
        art.kind = 'annotate';  // after setMemberParent()!
      }
    }

    for (let ext of extensions) {
      if ('_artifact' in ext.name) // already applied
        continue;
      setProp( ext.name, '_artifact', art );

      if (art) {
        defineAnnotations( ext, art, ext._block, ext.kind );
        forEachMember( ext, function init( elem, name, prop ) {
          storeExtension ( elem, name, prop, art, ext._block );
        });
      }
      if (showMsg) {
        // somehow similar to checkDefinitions():
        let feature = kindProperties[ parent.kind ][prop];
        if (prop === 'elements' || prop === 'enum') {
          if (!feature)
            message( 'anno-unexpected-elements', ext.name.location, art, {}, 'Warning',
                     'Elements only exist in entities, types or typed constructs' );
          else
            message( 'anno-undefined-element', ext.name.location, art,
                     { art: searchName( parent, name, parent.enum && 'enum' ) } );
        }
        else if (prop === 'actions') {
          if (!feature)
            message( 'anno-unexpected-actions', ext.name.location, art, {}, 'Warning',
                     'Actions and functions only exist top-level and for entities' );
          else
            message( 'anno-undefined-action', ext.name.location, art,
                     { art: searchName( parent, name, 'action' ) } );
        }
        else {
          if (!feature)
            message( 'anno-unexpected-params', ext.name.location, art, {}, 'Warning',
                     'Parameters only exist for actions or functions' ); // TODO: entities betaMod
          else
            message( 'anno-undefined-param', ext.name.location, art,
                     { art: searchName( parent, name, 'param' ) } );
        }
      }
    }
    if (art) {
      let obj = art.returns || art; // why the extra `returns` for actions?
      obj = obj.items || obj;
      annotate( obj, 'element', 'elements', 'enum', art );
      annotate( art, 'action', 'actions' );
      annotate( art, 'param', 'params' );
    }
    return;

    function annotate( obj, kind, prop, altProp, parent = obj ) {
      let dict = art._annotate && art._annotate[prop];
      let env = obj[prop] || altProp && obj[altProp] || null;
      for (let name in dict) {
        annotateMembers( env && env[name], dict[name], prop, name, parent, kind );
      }
    }
  }

  function extensionFor( art ) {
    if (art.kind === 'annotate')
      return art;
    if (art._extension)
      return art._extension;

    // $extension means: already applied
    let ext = {
      kind: art.kind,           // set kind for setMemberParent()
      $extension: 'exists',
      location: art.location    // location( extension to existing art ) = location(art)
    };
    let location = art.name.location;
    if (!art._main) {
      ext.name = {
        path: [ { id: art.name.absolute, location } ],
        location,
        absolute: art.name.absolute
      }
      model.extensions ? model.extensions.push(ext) : model.extensions = [ext];
    }
    else {
      ext.name = { id: art.name.id, location };
      let parent = extensionFor( art._parent );
      let kind = kindProperties[ art.kind ].normalized || art.kind;
      if ( parent[ kindProperties[ kind ].dict ] &&
           parent[ kindProperties[ kind ].dict ][art.name.id] )
        throw new Error(art.name.id);
      setMemberParent( ext, art.name.id, parent, kindProperties[ kind ].dict );
    }
    ext.kind = 'annotate';    // after setMemberParent()!
    setProp( art, '_extension', ext );
    setProp( ext.name, '_artifact', art );
    return ext;
  }

  function chooseAssignment( annoName, art ) {
    // TODO: getPath an all names
    let anno = art[annoName];
    if (!(anno instanceof Array)) // just one assignment -> use it
      return;
    // sort assignment according to layer
    let layerAnnos = Object.create(null);
    for (let a of anno) {
      let layer = layers.layer( a._block );
      let name = (layer) ? layer.realname : '';
      let done = layerAnnos[name];
      if (done)
        done.annos.push( a );
      else
        layerAnnos[name] = { layer, annos: [a] };
    }
    // collect assignments of upper layers (are in no _layerExtends)
    let exts = Object.keys( layerAnnos ).map( layerExtends );
    let allExtends = Object.assign( Object.create(null), ...exts );
    let collected = [];
    for (let name in layerAnnos) {
      if (!(name in allExtends))
        collected.push( prioritizedAnnos( layerAnnos[name].annos ) );
    }
    // inspect collected assignments - choose the one or signal error
    let justOnePerLayer = collected.every( annos => annos.length === 1);
    if (!justOnePerLayer || collected.length > 1) {
      for (let annos of collected) {
        for (let a of annos ) {
          message( 'anno-duplicate', a.name.location, art,
                   { anno: annoName, '#': justOnePerLayer && 'unrelated' },
                   ['Error'], {
                     std:       'Duplicate assignment with $(ANNO)',
                     // we could add USING...FROM between the unrelated layers:
                     unrelated: 'Duplicate assignment with $(ANNO) in unrelated layers'
                   });
        }
      }}
    art[annoName] = collected[0][0]; // just choose any one with error
    return;

    function layerExtends( name ) {
      let layer = layerAnnos[name].layer;
      return layer && layer._layerExtends;
    }
  }

  function prioritizedAnnos( annos ) {
    let prio = 0;
    let r = [];
    for (let a of annos) {
      let p = annotationPriorities[ a.priority ] || annotationPriorities[ 'define' ] ;
      if (p === prio)
        r.push(a);
      else if (p > prio)
        r = [a], prio = p;
    }
    return r;
  }

  // Phase 4 - queries and associations --------------------------------------

  function resolveQuery( query ) {
    populateQuery( query );
    forEachGeneric( query, '$tableAliases', function resolveAlias( alias ) {
      //console.log(message( null, alias.location, {art:alias}, 'Info','$(ART)').message)
      if (alias.kind === 'element')
        resolveRefs( alias );   // mixin element
      else if (!alias.self)    // not $projection/$self
        // pure path has been resolved, resolve args and filter now:
        resolveExpr( alias.type, 'from', query._parent, null, 'expr' );
    } );
    if (query !== query._main._leadingQuery) // will be done later
      // TODO: rethink elements(view) === elements(view._leadingQuery)
      forEachGeneric( query, 'elements', resolveRefs );
    if (query.on)
      resolveExpr( query.on, 'expr', query, query.$combined );
    if (query.where)
      resolveExpr( query.where, 'expr', query, query.$combined );
    if (query.groupBy)
      resolveBy( query.groupBy, 'expr' );
    resolveExpr( query.having, 'expr', query, query.$combined );
    if (query.$orderBy)       // ORDER BY from UNION:
      // TODO clarify: can I access the tab alias of outer queries?  If not:
      // 4th arg query._main instead query._parent.
      resolveBy( query.$orderBy, 'order-by-union', query.elements, query._parent );
    if (query.orderBy)         // ORDER BY
      // If we would allow VIEW extensions, re-think the Object.assign
      resolveBy( query.orderBy, 'expr',
                 Object.assign( Object.create(null), query.$combined, query.elements ) );
    return;

    // Note the strange name resolution (dynamic part) for ORDER BY: the same
    // as for select items if it is an expression, but first look at select
    // item alias (i.e. like `$projection.NAME` if it is a path.  If it is an
    // ORDER BY of an UNION, do not allow any dynamic path in an expression,
    // and only allow the elements of the leading query if it is a path.
    //
    // This seem to be similar, but different in SQLite 3.22.0: ORDER BY seems
    // to bind stronger than UNION (see <SQLite>/src/parse.y), and the name
    // resolution seems to use select item aliases from all SELECTs of the
    // UNION (see <SQLite>/test/tkt2822.test).
    function resolveBy( array, mode, pathDict, q ) {
      for (let item of array ) {
        let value = pathDict ? item.value : item; // XSN TODO: no extra value?
        if (value)
          resolveExpr( value, mode, q || query, value.path && pathDict );
      }
    }
  }

  function resolveTarget( art, obj ) {
    if (art !== obj) {
      message( 'assoc-in-array', obj.onCond.location, art, {},
               // TODO: also check parameter parent, two messages?
               ['Error'], 'An association cannot used for arrays or parameters' );
      setProp( obj.target, '_artifact', undefined );
      return;
    }
    let target = resolvePath( obj.target, 'target', art );
    if (obj.onCond) {
      if (!art._main || !art._parent.elements) {
        message( 'assoc-as-type', obj.onCond.location, art, {},
                 ['Error'], 'An unmanaged association cannot be defined as type' );
        // TODO: also warning if inside structure
      }
      else if (!obj.onCond.$inferred) {
        // TODO: provide "expected" special for on condition of association
        resolveExpr( obj.onCond, 'expr', art );
      }
    }
    else if (art.name.$mixin) {
      message( 'assoc-in-mixin', obj.target.location, art, {},
               'Error', 'Managed associations are not allowed for MIXIN elements' );
    }
    else if (target && !obj.foreignKeys) {
      if (!obj.type || obj.type.$inferred || obj.target.$inferred === 'IMPLICIT') // REDIRECTED
        resolveRedirected( art, target );
      else if (obj.type._artifact && obj.type._artifact.internal) { // cds.Association, ...
        addImplicitForeignKeys( art, target );
      }
    }
  }

  function addImplicitForeignKeys( art, target ) {
    forEachInOrder( target, 'elements', function( elem, name ) {
      if (elem.key && elem.key.val) {
        let location = art.target.location;
        let key = {
          name: { location, id: elem.name.id, $inferred: 'keys' }, // more by setMemberParent()
          kind: 'key',
          targetElement: { path: [{ id: elem.name.id, location }], location },
          location,
          calculated: true,
          $inferred: 'keys'
        };
        setMemberParent( key, name, art, 'foreignKeys' );
        setProp( key.targetElement, '_artifact', elem );
        setProp( key.targetElement.path[0], '_artifact', elem );
        setProp( key, '_finalType', finalType(elem) );
        setProp( key, '_deps', [{ art: elem, location }] );
        art._deps.push( { art: key } );
      }
    });
    art.implicitForeignKeys = true;
  }

  function resolveRedirected( elem, target ) {
    // console.log(message( null, elem.location, elem, {target}, 'Info','RE').toString())
    setProp( elem, '_redirected', null ); // null = do not touch path steps after assoc
    let assoc = directType( elem );
    let origType = assoc && finalType( assoc );
    if (!origType || !origType.target) {
      message( 'redirected-no-assoc', elem.target.location, elem, {},
               'Error', 'Only an association can be redirected' );
      return;
    }
    let nav = elem._main && elem._main.query && pathNavigation( elem.value );
    if (nav && nav.item !== elem.value.path[ elem.value.path.length-1 ]) {
      message( 'redirected-no-assoc', elem.target.location, elem, {},
               // TODO: Better text ?
               'Error', 'Only an association can be redirected' );
      return;
    }
    let origTarget = origType.target._artifact;
    if (!origTarget || !target)
      return;

    let chain = [];
    if (target === origTarget) {
      message( 'redirected-to-same', elem.target.location, elem, { art: target },
               'Info', 'The redirected target is the original $(ART)' );
      setProp( elem, '_redirected', chain ); // store the chain
      return;
    }
    // now check whether target and origTarget are "related"
    while (target.query) {
      let from = (target.query.args) ? [1,2] : target.query.from;
      if (!from || !from.length) // parse error
        return;
      if (from.length > 1 || !from[0].path) {
        message( 'redirected-to-complex', elem.target.location, elem,
                 { art: target, '#': target === elem.target._artifact ? 'target' : 'std' },
                 'Warning', {
                   std: 'Redirection involves the complex view $(ART)',
                   target: 'The redirected target $(ART) is a complex view'
                 });
        break;
      }
      target = from[0]._artifact;
      if (!target)
        return;
      chain.push( from[0]._tableAlias );
      if (target === origTarget) {
        chain.reverse();
        setProp( elem, '_redirected', chain );
        return;
      }
    }
    let redirected = null;
    let news = [{ chain: chain.reverse(), sources: [target] }];
    let dict = Object.create(null);
    while (news.length) {
      let outer = news;
      news = [];
      for (let o of outer) {
        for (let s of o.sources) {
          let art = (s.kind === '$tableAlias') ? s.type._artifact : s;
          if (art !== origTarget) {
            if (findOrig( o.chain, s, art ) && !redirected)
              redirected = false;   // do not report futher error
          }
          else if (redirected) {
            message( 'redirected-to-ambiguous', elem.target.location, elem, { art: origTarget },
                     ['Error'], 'The redirected target originates repeatedly from $(ART)' );
            return;
          }
          else {
            redirected = (s.kind === '$tableAlias') ? [s, ...o.chain] : o.chain;
          }
        }
      }
    }
    if (redirected)
      setProp( elem, '_redirected', redirected );
    else if (redirected == null)
      message( 'redirected-to-unrelated', elem.target.location, elem, { art: origTarget },
               ['Error'], 'The redirected target does not originate from $(ART)' );
    return;

    // B = proj on A, C = A x B, X = { a: assoc to A on a.Q1 = ...}, Y = X.{ a: redirected to C }
    // what does a: redirected to C means?
    // -> collect all elements Qi used in ON (corr: foreign keys)
    // -> only use an tableAlias which has propagation for all elements
    // no - error if the original target can be reached twice
    // even better: disallow complex view (try as error first)
    function findOrig( chain, alias, art ) {
      if (!art || dict[art.name.absolute])
        // some include ref or query source cannot be found, or cyclic ref
        return true;
      dict[art.name.absolute] = true;

      if (art.includes)
        news.push( { chain: [art, ...chain], sources: art.includes.map( r => r._artifact ) } );
      let query = art._leadingQuery;
      if (!query)
        return false;           // non-query entity
      if (!query.$tableAliases) // previous error in query definition
        return true;
      let sources = [];
      for (let n in query.$tableAliases) {
        let a = query.$tableAliases[n];
        if (a.type && !a.self && !a.name.$mixin)
          sources.push( a );
      }
      if (alias.kind === '$tablealias')
        news.push( { chain: [alias, ...chain], sources } );
      else
        news.push( { chain, sources } );
      return false;
    }
  }

  //--------------------------------------------------------------------------
  // Phase 5: rewrite associations
  //--------------------------------------------------------------------------
  // Only top-level queries and sub queries in FROM

  function rewriteSimple( art ) {
    if (!art.includes && !art.query) {
      // console.log(message( null, art.location, art, {target:art._target}, 'Info','RAS').toString())
      rewriteAssociation( art );
      forEachGeneric( art, 'elements', rewriteAssociation );
    }
  }

  function rewriteView( view ) {
    traverseQueryPost( view.query, false, function rewrite( query ) {
      forEachGeneric( query, 'elements', rewriteAssociation );
    } );
    if (view.includes)          // entities with structure includes:
      forEachGeneric( view, 'elements', rewriteAssociation );
  }

  function rewriteAssociation( elem ) {
    let assoc = directType( elem );
    let ftype = assoc && finalType( assoc );
    if (!ftype)
      return;
    let target = ftype.target && ftype.target._artifact;
    if (!target)
      return;
    // console.log(message( null, elem.location, elem, {art:assoc,target}, 'Info','RA').toString())
    let chain = [];
    while (!elem.onCond && !elem.foreignKeys) {
      chain.push( elem );
      elem = directType( elem );
      if (!elem || elem.builtin) // safety
        return;
    }
    chain.reverse();
    for (let art of chain) {
      if (elem.onCond)
        rewriteCondition( art, elem );
      else if (elem.foreignKeys)
        rewriteKeys( art, elem );
      elem = art;
    }
  }

  function rewriteKeys( elem, assoc ) {
    // console.log(message( null, elem.location, elem, {art:assoc,target:assoc.target}, 'Info','FK').toString())
    forEachInOrder( assoc, 'foreignKeys', function( orig, name ) {
      let fk = linkToOrigin( orig, name, elem, 'foreignKeys', elem.location );
      fk.$inferred = 'rewrite'; // TODO: other $inferred value?
      // TODO: re-check for case that foreign key is managed association
      if ('_finalType' in orig)
        setProp( fk, '_finalType', orig._finalType);
      let te = copyExpr( orig.targetElement, elem.location );
      if (elem._redirected) {
        let i = te.path[0];   // TODO: or also follow path like for ON?
        let state = rewriteItem( elem, i, i.id, elem );
        if (state && state !== true && te.path.length === 1)
          setLink( te, state );
      }
      fk.targetElement = te;
    });
  }

  function rewriteCondition( elem, assoc ) {
    let nav = (elem._main.query) ? pathNavigation( elem.value ) : { navigation: assoc };
    let cond = copyExpr( assoc.onCond,
                         // replace location in ON except if from mixin element
                         nav.tableAlias && elem.origin.location );
    cond.$inferred = 'copy';
    elem.onCond = cond;
    // console.log(message( null, elem.location, elem, {art:assoc,target:assoc.target}, 'Info','ON').toString())
    let navigation = nav.navigation;
    if (!navigation) // TODO: what about $projection.assoc as myAssoc ?
      return;                 // should not happen: $projection, $magic, or ref to const
    // console.log(message( null, elem.location, elem, {art:assoc}, 'Info','D').toString())
    // Currently, having an unmanaged association inside a struct is not
    // supported by this function:
    if (navigation !== assoc && navigation.origin && navigation.origin._artifact !== assoc) { // TODO: re-check
      // Currently no warning, as this is also true for "assoc1.assoc2",
      // warning only for "otherelem1.assoc2"
      // message( warning`Rewriting associations in a structure is not supported`, elem.value.location );
      return;
    }
    if (!nav.tableAlias || nav.tableAlias.type)
      resolveExpr( cond, rewriteExpr, elem, nav.tableAlias );
    else {
      // TODO: support that
      message( null, elem.value.location, elem,
               `Selecting unmanaged associations from a sub query is not supported` );
    }
    cond.$inferred = 'rewrite';
  }

  function rewriteExpr( expr, assoc, tableAlias ) {
    // Rewrite ON condition (resulting in outside perspective) for association
    // 'assoc' in query or including entity from ON cond of mixin element /
    // element in included structure / element in source ref/d by table alias.

    // TODO: re-check args in references, forbid parameter use for the moment
    // TODO: complain about $self (unclear semantics)
    // console.log( message(null, assoc.name.location, assoc, { names: expr.path.map(i=>i.id) }, 'Info', 'A'))
    
    if (!expr.path || !expr._artifact)
      return;
    if (tableAlias) { // from ON cond of element in source ref/d by table alias
       // TODO: check with assoc in FROM
      let source = tableAlias.type._artifact; // TODO: check with assoc in FROM
      let root = expr.path[0]._navigation || expr.path[0]._artifact;
      // if (root._main !== source) console.log('NO',assoc.name,(root._main ? root._main.name: root.name),source&&source.name)
      if (!root || root._main !== source)
        return;                 // not $self or source element
      let item = expr.path[ root.self ? 1 : 0 ];
      // console.log('YE', assoc.name, item, root.name, expr.path)
      rewritePath( expr, item, assoc,
                   navProjection( item && tableAlias.$navigation[ item.id ], assoc ),
                   assoc.value.location );
    }
    else if (assoc._main.query) { // from ON cond of mixin element in query
      let nav = pathNavigation( expr );
      if (nav.navigation || nav.tableAlias) // rewrite src elem, mixin, $self[.elem]
        rewritePath( expr, nav.item, assoc,
                     navProjection( nav.navigation, assoc ),
                     nav.item ? nav.item.location : expr.path[0].location );
    }
    else {                     // from ON cond of element in included structure
      let root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (root.builtin || !root.self && root.kind !== 'element')
        return;
      let item = expr.path[ root.self ? 1 : 0 ];
      if (!item)
        return;                                   // just $self
      let elem = assoc._main.elements[ item.id ]; // corresponding elem in including structure
      if (!(elem instanceof Array ||              // no msg for redefs
            elem.origin && elem.origin._artifact === item._artifact)) {
        message( 'rewrite-shadowed', elem.name.location, elem,
               { art: finalType( assoc.origin && assoc.origin._artifact ) },
                 'Warning', {
                   std: 'This element is not originally referred to in the ON condition of association $(ART)',
                   element: 'This element is not originally referred to in the ON condition of association $(MEMBER) of $(ART)'
                 } );
      }
      rewritePath( expr, item, assoc, (elem instanceof Array ? false : elem), null );
    }
  }

  function rewritePath( ref, item, assoc, elem, location ) {
    let path = ref.path;
    let root = path[0];
    if (!elem) {
      if (location)
        message( 'rewrite-not-projected', location, assoc,
                 { name: assoc.name.id, art: item._artifact }, 'Error', {
                   std: 'Projected association $(NAME) uses non-projected element $(ART)',
                   element: 'Projected association $(NAME) uses non-projected element $(MEMBER) of $(ART)'
                 } );
      delete root._navigation;
      setProp( root, '_artifact', elem );
      setProp( ref, '_artifact', elem );
      return;
    }
    if (item !== root) {
      root.id = '$self';
      setLink( root, assoc._parent.$tableAliases.$self, '_navigation' );
      setLink( root, assoc._parent );
    }
    else if (elem.name.id.charAt() === '$') {
      root = { id: '$self', location: item.location };
      path.unshift( root );
      setLink( root, assoc._parent.$tableAliases.$self, '_navigation' );
      setLink( root, assoc._parent );
    }
    if (!elem.name)      // nothing to do for own $projection, $projection.elem
      return;            // (except having it renamed to $self)
    item.id = elem.name.id;
    let state = null;
    for (let i of path) {
      if (!state) {
        if (i === item)
          state = setLink( i, elem );
      }
      else if (i) {
        state = rewriteItem( state, i, i.id, assoc );
        if (!state || state === true)
          break;
      }
      else
        return;
    }
    if (state !== true)
      setLink( ref, state );
  }

  function rewriteItem( elem, item, name, assoc ) {
    if (!elem._redirected)
      return true;
    for (let alias of elem._redirected) {
      // TODO: a message for the same situation as msg 'rewrite-shadowed'?
      if (alias.$navigation) {
        // TODO: if there is a "multi-step" redirection, we should probably
        // consider intermediate "preferred" elements - not just `assoc`,
        // but its origins, too.
        let proj = navProjection( alias.$navigation[name], assoc );
        name = proj && proj.name && proj.name.id;
        if (!name)
          break;
        item.id = name;
      }
    }
    let env = name && environment(elem);
    elem = setLink( item, env && env[name] );
    if (elem && !(elem instanceof Array))
      return elem;
    // TODO: better (extra message)
    message( 'query-undefined-element', item.location, assoc, { id: name || item.id }, 'Info',
             'Element $(ID) has not been found in the elements of the query' );
    return (elem) ? false : null;
  }

  // Resolve the type arguments provided with a type referenced for artifact or
  // element `art`.  This function does nothing if the referred type `typeArt`
  // does not have a `parameters` property (currently, only builtin-types have
  // it, see ./builtins.js).
  //
  // For each property name `<prop>` in `typeArt.parameters`, we move a number
  // in art.typeArguments (a vector of numbers with locations) to `art.<prop>`.
  // TODO: error if no parameters applicable
  // TODO: also check for number
  function resolveTypeExpr( art, user ) {
    let typeArt = resolveType( art.type, user );
    if (!typeArt)
      return;
    var args = art.typeArguments || [];
    let parameters = typeArt.parameters || [];
    var parLength = parameters.length;

    for (let i = 0; i < parLength; ++i) {
      let par = parameters[i];
      if (!(par instanceof Object))
        par = { name: par };
      if (!art[ par.name ] && (i < args.length || par.literal)) {
        let location = art.type.location;
        art[ par.name ] = args[i] ||
          { literal: par.literal, val: par.val, location, $inferred: 'type-param' };
      }
    }
    if (args.length > parLength) {
      art.typeArguments = art.typeArguments.slice(parLength);
      message( 'unexpected-type-arg', art.typeArguments[0].location, user, { art: typeArt },
               'Warning', 'Too many arguments for type $(ART)' );
    }
    else if (art.typeArguments)
      delete art.typeArguments;
  }

  function resolveExpr( expr, expected, user, extDict, itemMode) {
    if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
      return;
    if (expr instanceof Array)
      expr.forEach( e => resolveExpr( e, expected, user, extDict ) );
    else if (expr.path) {
      if (expected instanceof Function) {
        expected( expr, user, extDict );
        return;
      }
      resolvePath( expr, expected, user, extDict );

      for (let step of expr.path) {
        if (!step._artifact || step._artifact instanceof Array)
          break;
        if (step.namedArgs)
          // TODO: also check for just assoc
          resolveParams( step.namedArgs, step._artifact, itemMode || expected, user, extDict );
        if (step.where) {   // TODO: support for $projection, $parameters, ...?
          let assoc = finalType( step._artifact );
          if (assoc && !assoc.target && assoc.kind !== 'entity' && assoc.kind !== 'view')
            message( 'expr-no-filter', step.where.location, user, {},
                     ['Error'],
                     'A filter can only be provided when navigating along associations' );
          else
            resolveExpr( step.where, 'filter', user, environment( step._artifact ) );
        }
      }
    }
    else if (expr.op && queryOps[ expr.op.val ]) {
      if (expr.kind || expr._leadingQuery) // UNION has _leadingQuery
        traverseQueryPost( expr, false, resolveQuery );
      else
        message( 'expr-no-subquery', expr.location, user, {},
                 'Error', 'Subqueries are not supported here' );
    }
    else if (expr.op && expr.args) {
      let func = expr.func && expr.func.path && expr.func.path[0].id;
      if (func && func.toUpperCase() === 'ROUND') // TODO: temp?
        resolveExpr( expr.args[0], expected, user, extDict )
      else
        expr.args.forEach( e => resolveExpr( e, expected, user, extDict ) );
    }
  }

  function resolveParams( dict, art, expected, user, extDict ) {
    let type = finalType( art );
    if (type.target) {
      art = type.target._artifact;
      if (!art)                 // association with undefined target
        return;
    }
    if (!art.params) {
      let first = dict[ Object.keys(dict)[0] ];
      if (first instanceof Array)
        first = first[0];
      message( 'args-no-params',
               dictLocation( dict, first && first.name && first.name.location ), user, { art },
               ['Error'], 'Entity $(ART) has no parameters' );
      return;
    }
    for (let name in dict) {
      let param = art.params[name];
      let arg = dict[name];
      for (let a of (arg instanceof Array) ? arg : [arg]) {
        setProp( a.name, '_artifact', param );
        if (!param)
          message( 'args-undefined-param', a.name.location, user, { art, id: name },
                   ['Error'], 'Entity $(ART) has no parameter $(ID)' );
        resolveExpr( a, expected, user, extDict );
      }
    }
  }
}

function copyExpr( expr, location ) {
  if (!expr || typeof expr !== 'object')
    return expr;
  else if (expr instanceof Array)
    return expr.map( e => copyExpr( e, location ) );

  let proto = Object.getPrototypeOf( expr );
  if (proto && proto !== Object.prototype) // do not copy object from special classes
    return expr;
  let r = Object.create( proto );
  if (proto && expr.op && queryOps[ expr.op.val ])
    return [];                  // copy/rewrite with sub query is not supported

  for (let prop of Object.getOwnPropertyNames( expr )) {
    let pd = Object.getOwnPropertyDescriptor( expr, prop );
    if (!pd.enumerable || !pd.value) // should include all properties starting with _
      Object.defineProperty( r, prop, pd );
    else if (!proto)
      r[prop] = copyExpr( pd.value, location );
    else if (prop === 'location')
      r[prop] = location || pd.value;
    else if (prop.charAt() !== '$')
      r[prop] = copyExpr( pd.value, location );
    else
      Object.defineProperty( r, prop, pd );
  }
  return r;
}

function testExpr( expr, pathTest, queryTest ) {
  // TODO: also check path arguments/filters
  if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
    return false;
  else if (expr instanceof Array)
    return expr.some( e => testExpr( e, pathTest, queryTest ) );
  else if (expr.path)
    return pathTest( expr );
  else if (expr.op && queryOps[ expr.op.val ])
    return queryTest( expr );
  else if (expr.op && expr.args)
    return expr.args.some( e => testExpr( e, pathTest, queryTest ) );
  else
    return false;
}

// Return true if the path `item` with a final type `assoc` has a max target
// cardinality greater than one - either specified on the path item or assoc type.
function targetMaxNotOne( assoc, item ) {
  // Semantics of associations without provided cardinality: [*,0..1]
  let cardinality = item.cardinality || assoc.cardinality;
  return cardinality && cardinality.targetMax && cardinality.targetMax.val !== 1;
}

// Return condensed info about reference in select item
// - tableAlias.elem       -> { navigation: navElem, item: path[1], tableAlias }
// - sourceElem (in query) -> { navigation: navElem, item: path[0], tableAlias }
// - mixinElem             -> { navigation: mixinElement, item: path[0] }
// - $projection.elem      -> also $self.item -> { item: path[1], tableAlias: $self }
// - $self                 -> { item: undefined, tableAlias: $self }
// - $parameters.P, :P     -> {}
// - $now, current_date    -> {}
// - undef, redef          -> {}
// With 'navigation': store that navigation._artifact is projected
// With 'navigation': rewrite its ON condition
// With navigation: Do KEY propagation
function pathNavigation( ref ) {
  // currently, indirectly projectable elements are not included - we might
  // keep it this way!  If we want them to be included - be aware: cycles
  if (!ref._artifact)
    return {};
  let item = ref.path && ref.path[0];
  let root = item && item._navigation;
  if (!root)
    return {};
  if (root.kind === '$navElement')
    return { navigation: root, item, tableAlias: root._parent };
  if (root.name.$mixin)
    return { navigation: root, item };
  item = ref.path[1];
  if (root.self)
    return { item, tableAlias: root };
  if (root.kind !== '$tableAlias' || ref.path.length < 2)
    return {};                // should not happen
  return { navigation: root.$navigation[ item.id ], item, tableAlias: root };
}

function navProjection( navigation, preferred ) {
  // TODO: Info if more than one possibility?
  // console.log(navigation,navigation._projections)
  if (!navigation)
    return {};
  else if (!navigation._projections)
    return null;
  return (preferred && navigation._projections.includes( preferred ))
    ? preferred
    : navigation._projections[0] || null;
}

// Query tree post-order traversal - called for everything which makes a query
// except "real ones": operands of UNION etc, JOIN with ON, and sub queries in FROM
function traverseQueryPost( query, simpleOnly, callback ) {
  // console.log( msgName(query), query.name.query );
  while (query instanceof Array) // query in parentheses
    query = query[0];
  if (!query || !query.op)      // parser error or just path
    return;
  if (simpleOnly) {
    if (query.op.val !== 'query' || query.from.length != 1)
      return;
    let from = query.from[0];
    while (from instanceof Array)
      from = from[0];
    if (!from || from.join)     // parse error or join
      return;
  }
  if (query.op.val === 'query') { // SELECT -> simple with simple FROM
    for (let q of query.from)
      traverseQueryPost( q, simpleOnly, callback );
    callback( query );
  }
  else if (query.args) {             // JOIN, UNION, INTERSECT -> not simple
    for (let q of query.args)
      traverseQueryPost( q, simpleOnly, callback );
    if (query.on)
      callback( query );
  }
  // else: with parse error (`select from <EOF>`)
}

module.exports = resolve;
