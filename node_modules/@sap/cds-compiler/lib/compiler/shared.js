// Compiler functions and utilities shared across all phases


'use strict';

const { searchName, getMessageFunction } = require('../base/messages');
const { addToDict, addToDictWithIndexNo, pushToDict } = require('../base/dictionaries');

const dictKinds = {
  definitions: 'absolute',
  elements: 'element',
  enum: 'enum',
  foreignKeys: 'key',
  actions: 'action',
  params: 'param',
}

const kindProperties = {
  // TODO: also foreignKeys ?
  namespace: { artifacts: true }, // on-the-fly context
  context: { artifacts: true, normalized: 'namespace' },
  service: { artifacts: true, normalized: 'namespace' }, // actions: true with "service-bound" actions
  entity: { elements: true, actions: true, params: () => false },
  view: { elements: true, actions: true, params: () => false },
  query: { elements: true },
  $tableAlias: { normalized: 'alias', $navigation: true }, // table alias in select
  $navElement: { normalized: 'element', $navigation: true },
  type:  { elements: propExists, enum: propExists },
  annotation: { elements: propExists, enum: propExists },
  const: {},
  enum: { normalized: 'element' },
  element: { elements: propExists, enum: propExists, dict: 'elements' },
  action: { params: () => false, elements: () => false, enum: () => false, dict: 'actions' }, // no extend params, only annotate
  function: { params: () => false, elements: () => false, enum: () => false, normalized: 'action' }, // no extend params, only annotate
  key: { normalized: 'element' },
  param: { elements: () => false, enum: () => false, dict: 'params' },
  source: { artifacts: true },
  block: { artifacts: true },
  using: {},
  extend: { isExtension: true },
  annotate: { isExtension: true, elements: true, enum: true, actions: true, params: true },
  builtin: {},                  // = CURRENT_DATE, TODO: improve
  $parameters: {},              // $parameters in query entitis
}

function propExists( prop, parent ) {
  let obj = parent.returns || parent;
  return (obj.items || obj)[prop];
}


// Main export function of this file.  Return "resolve" functions shared for phase
// "define" and "resolve".  Argument `model` is the augmented CSN.  Optional
// argument `environment` is a function which returns the search environment
// defined by its argument - it defaults to the dictionary of subartifacts of
// the argument.
function fns( model, environment = (o => o.artifacts || Object.create(null) ) ) {
  var options = model.options || {};
  const message = getMessageFunction( model );
  const specExpected = {
    annotation: { useDefinitions: true, noMessage: true },
    extend: { useDefinitions: true }, // ref in top-level EXTEND
    annotate: { useDefinitions: true, undefinedDef: 'anno-undefined-def', undefinedArt: 'anno-undefined-art' },
    type: { reject: rejectNonType }, // TODO: more detailed later (e.g. for enum base type?)
    typeOf: { next: '_$next' },
    include: { reject: rejectNonStruct },
    context: { reject: rejectNonContext },
    target: { reject: rejectNonEntity, noDep: true }, // TODO: dep for (explicit+implicit!) foreign keys
    element: { next: '__none_' },
    filter: { next: '_$next', lexical: 'main' },
    from: { reject: rejectNonSource },
    const: { next: '_$next', reject: rejectNonConst },
    expr: { next: '_$next', escape: 'param', noDep: true },
    rewrite: { next: '_$next', escape: 'param', noDep: true, rewrite: true }, // TODO: assertion that there is no next/escape used
    'order-by-union':  { next: '_$next', escape: 'param', noDep: true, noExt: true },
    // expr TODO: better - on condition for assoc, other on 
    // expr TODO: write dependency, but care for $self
    param: { reject: rejectNonConst },
    global: { useDefinitions: true, global: true }, // for using declaration
  }

  return {
    resolveUncheckedPath,
    resolvePath,
    defineAnnotations,
  };

  function rejectNonConst( art ) {
    return ['builtin','param','const'].includes( art.kind ) ? undefined : 'expected-const';
  }

  function rejectNonStruct( art ) {
    return (['type', 'entity'].includes( art.kind ) && art.elements && !art.query && !art.params)
      ? undefined
      : 'expected-struct';
  }

  function rejectNonContext( art ) {
    return (['context', 'service'].includes( art.kind ))
      ? undefined
      : 'expected-context'
  }

  function rejectNonType( art ) {
    return (['type', 'entity', 'view'].includes( art.kind ) ||
            // art.kind === 'type' || // too strong for positive/BoundFunctions
            // art._main && art._main.kind === 'type')  // currently too strong
            art._main && ['type', 'entity', 'view'].includes( art._main.kind ))
      ? undefined
      : 'expected-type';
  }

  function rejectNonEntity( art ) {
    return (['view', 'entity'].includes( art.kind ))
      ? undefined
      : 'expected-entity';
  }

  function rejectNonSource( art, path ) {
    if (['view', 'entity'].includes( art.kind ))
      return undefined;
    let main = [...path].reverse().find( item => !item._artifact._main );
    if (!['view', 'entity'].includes( main._artifact.kind ))
      return 'expected-source';  // orig: 'A source must start at an entity, projection or view';
    environment( art );           // sets _finalType on art
    return (!art._finalType || art._finalType.target)
      ? undefined
      : 'expected-source';      // orig: 'The path must end with an association'
  }

  // Return absolute name for unchecked path `ref`.  We first try searching for
  // the path root starting from `env`.  If it exists, return its absolute name
  // appended with the name of the rest of the path and set `ref.absolute` to
  // the return value.  Otherwise, complain if `unchecked` is false, and set
  // `ref.absolute` to the path name of `ref`.
  // Used for collecting artifact extension, and annotation assignments.
  function resolveUncheckedPath( ref, expected, user ) {
    if (!ref.path || ref.path.broken) // incomplete type AST
      return undefined;
    let spec = specExpected[expected];
    let art = (ref.scope === 'global' || spec.global)
            ? getPathRoot( ref.path, spec, user, {}, model.definitions )
            : getPathRoot( ref.path, spec, user, user._block, null, true );
    if (art === false)          // redefinitions
      art = ref.path[0]._artifact[0]; // array stored in head's _artifact
    else if (!art)
      return (spec.useDefinitions) ? pathName( ref.path ) : null;
    // art can be using proxy...
    if (ref.path.length > 1)
      return art.name.absolute + '.' + pathName( ref.path.slice(1) );
    else
      return art.name.absolute;
  }

  // Return artifact or element referred by the path in `ref`.  The first
  // environment we search in is `env`.  If no such artifact or element exist,
  // complain with message and return `undefined`.  Record a dependency from
  // `user` to the found artifact if `user` is provided.
  function resolvePath( ref, expected, user, extDict, msgArt ) {
    if (ref == null)       // no references -> nothing to do
      return undefined;
    if ('_artifact' in ref)     // also true for _artifact: undefined
      return ref._artifact;
    if (!ref.path || ref.path.broken || !ref.path.length) // incomplete type AST or empty env (already reported)
      return undefined;

    let spec = specExpected[expected];
    let path = ref.path;
    let head = path[0];
    //message(null,head.location,{art:user,expected, id: head.id},'Info','User $(ART), $(EXPECTED) $(ID)')
    let env  = user._block;     // artifact references: block

    if (ref.scope === 'param') {
      if (!spec.escape) {
        let variant = (env.$frontend && env.$frontend !== 'cdl') ? 'std' : 'cdl';
        message( 'ref-unexpected-scope', head.location, user, { name: head.id, '#': variant },
                 'Error', {
                   std: 'Unexpected parameter scope for name $(NAME)',
                   cdl: 'Unexpected `:` before name $(NAME)'
                 } );
        return setLink( ref, null );
      }
      spec = specExpected[ spec.escape ];
      // In queries and query entities, the first lexical search environment
      // are the parameters, otherwise the block.  It is currently ensured that
      // _block in queries is the same as _block of the query entity:
      let lexical = (user._main||user).$tableAliases; // queries (but also query entities)
      env = lexical && lexical.$parameters || user._block;
      extDict = null;           // let getPathRoot() choose it
    }
    else if (spec.next === '__none_')
      env = {};
    else if (spec.next) {       // TODO: combine spec.next / spec.lexical to spec.lexical
      let query = (spec.lexical === 'main')
                ? user._main      // in path filter, just $magic (and $parameters)
                : (user.kind === 'query')
                ? user
                : user._parent && user._parent.kind === 'query' && user._parent;
      env = (spec.lexical === 'from') ? query._parent : query || user._main || user;
      // queries: first tabaliases, then $magic - value refs: first $self, then $magic
      if (!extDict && !spec.noExt)
        extDict = query && query.$combined ||
                  environment( user._main ? user._parent : user );
    }

    // 'global' for CSN later in value paths, CDL for Association/Composition:
    let art = (ref.scope === 'global' || spec.global)
              ? getPathRoot( path, spec, user, {}, model.definitions )
              : getPathRoot( path, spec, user, env, extDict, msgArt || 0 );
    if (!art)
      return setLink( ref, art );
    else if (art.kind === 'using') {
      art = model.definitions[ art.name.absolute ];
      if (!art)
        return setLink( ref, art );
      else if (art instanceof Array) // redefined art referenced by using proxy
        return setLink( ref, false );
      setLink( head, art );     // we do not want to see the using
    }
    else if (art.name.$mixin) { // TODO: art.kind === 'mixin'
      setLink( head, art, '_navigation' );
    }
    else if (art.kind === '$navElement') {
      setLink( head, art, '_navigation' );
      setLink( head, art.origin._artifact );
    }
    else if (art.kind === '$tableAlias') {
      setLink( head, art, '_navigation' );
      if (art.type) {           // FROM reference
        let assoc = art._finalType && art._finalType.target;
        art = setLink( head, assoc ? assoc._artifact : art.type._artifact );
        if (!art)
          return setLink( ref, art );
      }
      else {                    // FROM subquery, $projection, $self
        setLink( head, art._finalType ); // the query (sub or self)
      }
    }

    art = getPathItem( path, spec, user );
    if (!art)
      return setLink( ref, art );

    if (art.$autoElement) {
      let location = path[ path.length-1 ].location;
      let step = { id: art.$autoElement, $inferred: '$autoElement', location };
      art = art.elements[ step.id ];
      setLink( step, art );
      path.push( step );
    }
    if (spec.reject) {
      let msg = spec.reject( art, path );
      if (msg) {
        signalNotFound( msg, ref.location, user );
        return setLink( ref, false );
      }
    }
    if (user && !spec.noDep) {
      let location = ref.location; // || combinedLocation( head, path[tail.length] );
      if (!user._deps)
        setProp( user, '_deps', [] );
      user._deps.push( { art, location } );
      // Without on-demand resolve, we can simply signal 'undefined "x"'
      // instead of 'illegal cycle' in the following case:
      //    element elem: type of elem.x;
    }
    return setLink( ref, art );
  }

  function transformMagicName( name ) {
    // TODO: store magic variable in lower case (nicer for code completion)
    return (name === 'self' || name.charAt() === '$') ? name : name.toUpperCase();
  }

  // Return artifact or element referred by name `head`.  The first environment
  // we search in is `env`.  If `unchecked` is equal to `true`, do not report an error
  // if the artifact does not exist.  Return a "fresh" artifact for
  // non-existing external using references if `unchecked` is truthy.
  function getPathRoot( path, spec, user, env, extDict, msgArt ) {
    let head = path[0];
    if (!head || !head.id)
      return undefined;         // parse error
    if ('_artifact' in head)
      return (head._artifact instanceof Array) ? false : head._artifact;
    // console.log(pathName(path), !spec.next && !extDict && (spec.useDefinitions || env.$frontend === 'json' || env))
    if (!spec.next && !extDict) {
      extDict = (spec.useDefinitions || env.$frontend && env.$frontend !== 'cdl')
                ? model.definitions
                : model.$builtins;
    }
    // TODO: remove resolveSemanics, just have typeOf for type refs
    let nextProp = spec.next || '_block';
    for (let art = env; art; art = art[nextProp]) {
      let e = art.artifacts || art.$tableAliases || Object.create(null);
      let r = (art.kind !== '$magicVariables')
              ? e[ head.id ]
              // do not find magic variables if quoted:
              : (!head.quoted) && e[ transformMagicName( head.id ) ];
      if (r) {
        if (r instanceof Array) { // redefinitions
          setLink( head, r );
          return false;
        }
        else if (r.kind === 'block')
          return setLink( head, r.name._artifact );
        else if (r.kind === '$parameters') {
          if (!head.quoted && path.length > 1) {
            message( 'ref-obsolete-parameters', head.location, user,
                     { code: '$parameters.' + path[1].id, newcode: ':' + path[1].id },
                     ['Error'], 'Obsolete $(CODE) - replace by $(NEWCODE)' );
            // TODO: replace it in to-csn correspondingly
            return setLink( head, r );
          }
        }
        else if (r.kind !== '$tableAlias' ||
                 (r.self ? !head.quoted : path.length > 1))
          // except $self if quoted, or "real" table aliases (not $self) with path len 1
          // TODO: $projection only if not quoted _and_ length > 1
          return setLink( head, r );
      }
    }
    if (extDict) {
      let r = extDict[head.id];
      if (r instanceof Array) {
        if (r[0].kind === '$navElement') {
          let names = r.filter( e => !e.$duplicate)
                       .map( e => e.name.alias + '.' + e.name.element );
          if (names.length)
            message( 'ref-ambiguous', head.location, user, { id: head.id, names },
                     'Error', 'Ambiguous $(ID), replace by $(NAMES)' );
        }
        setLink( head, r );
        return false;
      }
      else if (r)
        return setLink( head, r );
    }
    if (spec.noMessage || msgArt === true && extDict === model.definitions)
      return setLink( head, null );

    let valid = [];
    for (let art = env; art; art = art[nextProp]) {
      let e = art.artifacts || art.$tableAliases || Object.create(null);
      valid.push( e );
    }
    if (extDict) {
      let e = Object.create(null);
      // the names of the external dictionary are valid, too, except duplicate
      // navigation elements (for which you should use a table alias)
      if (extDict !== model.definitions) {
        for (let name in extDict) {
          let def = extDict[name];
          if (!(def instanceof Array && def[0].kind === '$navElement'))
            e[name] = def;
        }
      }
      else {
        for (let name in extDict) {
          if (!name.includes('.'))
            e[name] = extDict[name];
        }
      }
      valid.push( e );
    }

    if (spec.next) {            // value ref
      // TODO: if not in query, specify where we search for elements and delete env.$msg
      // TODO: also something special if it starts with '$'
      if (msgArt)
        signalNotFound( 'ref-undefined-element', head.location, user, valid,
                        { art: searchName( msgArt, head.id, 'element' ) } );
      else
        signalNotFound( 'ref-undefined-var', head.location, user, valid, { id: head.id },
                        'Error', 'Element or variable $(ID) has not been found' );
    }
    else if (env.$frontend && env.$frontend !== 'cdl' || spec.global)
      // IDE can inspect <model>.definitions - provide null for valid
      signalNotFound( spec.undefinedDef || 'ref-undefined-def', head.location, user, valid,
                      { art: head.id } );
    else
      signalNotFound( spec.undefinedArt || 'ref-undefined-art', head.location, user, valid,
                      { name: head.id } );
    return setLink( head, null );
  }

  // Return artifact or element referred by path (array of ids) `tail`.  The
  // search environment (for the first path item) is `arg`.  For messages about
  // missing artifacts (as opposed to elements), provide the `head`(first
  // element item in the path)
  function getPathItem( path, spec, user ) {
    var art;
    for (let item of path) {
      if (!item || !item.id)    // incomplete AST due to parse error
        return undefined;
      if (item._artifact) {     // should be there on first path element
        art = item._artifact;
        if (art instanceof Array)
          return false;
      }
      else {
        let env = environment(art);
        let sub = setLink( item, env && env[item.id] );
        if (!sub)
          return error( item, env );
        else if (sub instanceof Array) // redefinitions
          return false;
        art = sub;
      }
    }
    return art;

    function error( item, env ) {
      if (!spec.next) {         // artifact ref
        // TODO: better for TYPE OF, FROM e.Assoc (even disallow for other refs)
        signalNotFound( spec.undefinedDef || 'ref-undefined-def', item.location, user,
                        [env], { art: searchName( art, item.id ) } );
      }
      else if (art.name.query != null) {
        // TODO: probably not extra messageId, but text variant
        signalNotFound( 'query-undefined-element', item.location, user,
                        [env], { id: item.id }, 'Error',
                        'Element $(ID) has not been found in the elements of the query' );
        // TODO: 'The current query has no element $(MEMBER)' with name.self
        // and 'The sub query $(NAME) has no element $(MEMBER)'
      }
      else if (art.kind === '$parameters') {
        signalNotFound( 'ref-undefined-param', item.location, user,
                        [env], { art: searchName( art._main, item.id, 'param' ) },
                        'Error', { param: 'Entity $(ART) has no parameter $(MEMBER)' } );
      }
      else {
        signalNotFound( 'ref-undefined-element', item.location, user,
                        [env], { art: searchName( art, item.id ) } );
      }
      return null;
    }
  }

  function signalNotFound( msgId, location, home, valid, ...args ) {
    // if (!location) console.log(msgId, valid, ...args)
    if (location.$notFound)
      return;
    location.$notFound = true;
    let err = message( msgId, location, home, ...args );
    // console.log( Object.keys( Object.assign( Object.create(null), ...valid.reverse() ) ) )
    if (valid && (options.attachValidNames || options.testMode))
      err.validNames = Object.assign( Object.create(null), ...valid.reverse() );
    if (options.testMode && valid) {
      let names = Object.keys( err.validNames );
      message( null, location, null,
               names.length ? 'Valid: ' + names.sort().join(', ') : 'No valid names',
               'Info' );
    }
  }

  // Resolve all annotation assignments for the node `art`.  Set `art.@` to all
  // flattened assignments.  This function might issue error message for
  // duplicate assignments.
  // TODOs:
  // * do something for extensions by CSN or Properties parsers
  // * make sure that we do not issue repeated warnings due to flattening if an
  //   annotation definition is missing
  function defineAnnotations( construct, art, block, priority ) {
    // TODO: block should be construct._block
    if (!construct.annotationAssignments || !construct.annotationAssignments.length) {
      if (construct === art)
        return;
      for (let annoProp in construct) {
        if (annoProp.charAt(0) === '@') {
          let annos = construct[annoProp];
          if (!(annos instanceof Array))
            annos = [annos];
          for (let a of annos) {
            setProp( a, '_block', block );
            addToDict( art, annoProp, a );
          }
        }
      }
      return;
    }
    for (let anno of construct.annotationAssignments) {
      let ref = anno.name;
      let name = resolveUncheckedPath( ref, 'annotation', { _block: block } );
      let annoProp = (anno.name.variant)
          ? '@' + name + '#' + anno.name.variant.id
          : '@' + name;
      flatten( ref.path, annoProp, anno.value || {}, anno.name.variant, anno.name.location );
    }
    return;

    function flatten( path, annoProp, value, iHaveVariant, location ) {
      // Be robust if struct value has duplicate element names
      if (value instanceof Array) // TODO: do that differently in CDL parser
        return;                 // discard duplicates in flattened form

      if (value.literal === 'struct') {
        for (let item of value._struct || []) {
          let prop = pathName(item.name.path);
          if (item.name.variant) {
            if (iHaveVariant)
              message( 'anno-duplicate-variant', item.name.variant.location, construct, {}, // TODO: params
                       'Error', 'Annotation variant has been already provided' );
            prop = prop + '#' + item.name.variant.id; // TODO: check for double variants
          }
          flatten( [...path, ...item.name.path], annoProp + '.' + prop, item, iHaveVariant || item.name.variant);
        }
        for (let prop in value.struct) {
          let item = value.struct[prop];
          flatten( [...path, item.name], annoProp + '.' + prop, item, iHaveVariant );
        }
        return;
      }
      let anno = Object.assign( {}, value ); // shallow copy
      anno.name = { path, location: location || value.name && value.name.location || value.path && value.path.location };
      if (priority)
        anno.priority = priority;
      setProp( anno, '_block', block );
      // TODO: _parent, _main is set later (if we have ElementRef), or do we
      // set _artifact?
      setAnnotation( art, annoProp, anno, priority );
    }
  }

  function setAnnotation( art, annoProp, anno, priority = 'define') {
    anno.priority = priority;
    addToDict( art, annoProp, anno );
  }
}

// Create a location with location properties `filename` and `start` from
// argument `start`, and location property `end` from argument `end`.
function combinedLocation( start, end ) {
  return {
    filename: start.location.filename,
    start: start.location.start,
    end: end.location.end
  };
}

// Return string 'A.B.C' for parsed source `A.B.C` (is vector of ids with
// locations):
function pathName (path) {
  return (path.broken) ? '' : path.map( id => id.id ).join('.');
}

// Like `obj.prop = value`, but not contained in JSON / CSN
function setProp ( obj, prop, value ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}

// The link (_artifact,_finalType,...) usually has the artifact as value.
// Falsy values are:
// - undefined: not computed yet, parse error, no ref
// - null: no valid reference, param:true if that is not allowed
// - false (only complete ref): multiple definitions, rejected
// - 0 (for _finalType only): circular reference
function setLink ( obj, value = null, prop = '_artifact' ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}

function linkToOrigin( origin, name, parent, prop, location ) {
  let elem = {
    name: { location: location || origin.name.location, id: origin.name.id },
    kind: origin.kind,
    origin: { location },
    location: location || origin.location
  };
  if (origin.name.$inferred)
    elem.name.$inferred = origin.name.$inferred;
  if (parent)
    setMemberParent( elem, name, parent, prop ); // TODO: redef in template
  setProp( elem.origin, '_artifact', origin );
  // TODO: make this just elem._origin, remove elem.origin
  return elem;
}

function setMemberParent( elem, name, parent, prop ) {
  if (prop) {              // extension or structure include
    // TODO: consider ARRAY OF and RETURNS
    if (!(prop in parent))
      parent[prop] = Object.create(null);
    addToDictWithIndexNo( parent, prop, name, elem )
  }
  if (parent._outer)
    parent = parent._outer;
  setProp( elem, '_parent', parent );
  setProp( elem, '_main', parent._main || parent );
  elem.name.absolute = elem._main.name.absolute;
  [ 'element', 'alias', 'query', 'param', 'action' ].forEach( function( kind ) {
    // console.log(elem.kind || elem)
    let normalized = kindProperties[ elem.kind ].normalized || elem.kind;
    if (normalized === kind) {
      elem.name[kind] = (parent.name[kind] != null) ? parent.name[kind] + '.' + name : name;
    }
    else if (parent.name[kind] != null) {
      elem.name[kind] = parent.name[kind];
    }
    else
      delete elem.name[kind];
  });
  // try { throw new Error('Foo') } catch (e) { elem.name.stack = e; };
}

function storeExtension( elem, name, prop, parent, block ) {
  if (prop === 'enum')
    prop = 'elements';
  setProp( elem, '_block', block );
  let kind = '_' + elem.kind; // _extend or _annotate
  if (!parent[kind])
    setProp( parent, kind, {} );
  if (!parent[kind][prop])
    parent[kind][prop] = Object.create(null)
  pushToDict( parent[kind][prop], name, elem );
}

// Return path step if the path navigates along an association whose final type
// satisfies function `test`; "navigates along" = last path item not considered
// without truthy optional argument `alsoTestLast`.
function withAssociation( ref, test = ()=>true, alsoTestLast ) {
  for (let item of ref.path || []) {
    let art = item && item._artifact; // item can be null with parse error
    if (art && art._finalType && art._finalType.target && test( art._finalType, item ))
      return (alsoTestLast || item !== ref.path[ ref.path.length-1 ]) && item;
  }
  return false;
}

module.exports = {
  dictKinds,
  kindProperties,
  fns,
  setLink,
  linkToOrigin, setMemberParent,
  storeExtension,
  withAssociation,
  combinedLocation
};
