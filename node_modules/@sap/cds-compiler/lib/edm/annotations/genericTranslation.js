'use strict';

const Edm = require('../edm.js');
const glue = require('../glue.js');
const preprocessAnnotations = require('./preprocessAnnotations.js');
const oDataDictionary = require('./Dictionary.json');
const alerts = require('../../base/alerts');

const knownVocabularies = ['Aggregation', 'Analytics', 'Core', 'Common', 'UI', 'Communication', 'Capabilities', 'Measures', 'Validation', 'PersonalData'];

/**************************************************************************************************
 * csn2annotationEdm
 *
 * options:
 *   v - array with two boolean entries, first is for v2, second is for v4
 *   tntFlavor
 *   dictReplacement: for test purposes, replaces the standard oDataDictionary
 */
function csn2annotationEdm(csn, options=undefined) {

  // annotation preprocessing, partially tnt specific
  //   the only option used in preprocessAnnotations is tntFlavor
  preprocessAnnotations.preprocessAnnotations(csn, options);

  if(!options)
    throw "Please debug me: csn2annotationsEdm must be invoked with options"

  let usedVocabs = {};

  // use closure to avoid making "dict" and "experimental" global variables
  let { getDictTerm, getDictType } = function(){
    let dict = options.dictReplacement || oDataDictionary; // tests can set different dictionary via options
    let experimental = {}; // take note of all experimental annos that have been used

    return {
      // called to look-up a term in the dictionary
      //   in addition, note usage of the respective vocabulary and issue a warning if the term
      //   is flagged as "experimental"
      getDictTerm: function(termName, context) {
        let dictTerm = dict.terms[termName]
        if (dictTerm) {
          // register usage of vocabulary
          usedVocabs[termName.slice(0, termName.indexOf('.'))] = true;
          // issue warning for usage of experimental Terms, but only once per Term
          if (dictTerm["$experimental"] && !experimental[termName] && !options.betaMode) {
            warningMessage(context, termName + " is experimental and can be changed or removed at any time, do not use productively!");
            experimental[termName] = true;
          }
        }
        return dictTerm;
      },
      // called to look-up a type in the dictionary
      //   in addition, note usage of the respective vocabulary
      getDictType: function (typeName) {
        let dictType = dict.types[typeName];
        if (dictType) {
          // register usage of vocabulary
          usedVocabs[typeName.slice(0, typeName.indexOf('.'))] = true;
        }
        return dictType;
      }
    }
  }();

  let g_annosArray = [];

  let v = options.v;

  const { warning, signal } = alerts(csn);

  // Note: only works for single service
  // Note: we assume that all objects ly flat in the service, i.e. objName always
  //       looks like <service name, can contain dots>.<id>
  // Note: it is NOT safe to assume that the service itself is the first definition in the csn
  //       -> in general "serviceName" is NOT correctly set during processing of other objects
  let serviceName = null;
  for (let objName in csn.definitions) {
    let object = csn.definitions[objName];
    if (object.kind == "service") {
      serviceName = objName;
    }

    if (object.kind == "action" || object.kind == "function") {
      handleAction(objName, object, null);
    }
    else { // service, entity, anything else?
      // handle the annotations directly tied to the object
      handleAnnotations(objName, object);
      // handle the annotations of the object's elements
      handleElements(objName, object);
      // handle the annotations of the object's actions
      handleBoundActions(objName, object);
    }
  }

  // filter out empty <Annotations...> elements
  g_annosArray = g_annosArray.filter(x => x._children.length > 0 || x.kind !== 'Annotations');

  let schema = new Edm.Schema(v, serviceName, serviceName, g_annosArray, false);
  let service = new Edm.DataServices(v, schema);
  let edm = new Edm(v, service);
  return edm;

  // helper to determine the OData version
  //   tnt is always v2
  // TODO: improve option handling and revoke this hack for tnt
  function isV2() {
    return options.tntFlavor || (v && v[0]);
  }

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------



  //
  // this function is called in the translation code to issue a warning message
  //    messages are reported via the alerts attribute of csn
  //
  function warningMessage(context, message) {
    let fullMessage = "in annotation translation: " + message;
    if (context) {
      let loc = "target: " + context.target + ", annotation: " + context.term;
      if (context.stack.length > 0) {
        loc += context.stack.join('');
      }
      fullMessage += ", " + loc;
    }
    signal(warning`${fullMessage}`);
  }



  // there are 4 possible kinds of targets for annotations
  // csn: annotation at entity
  //      depending on the term, the target in edm is the corresponding
  //      -  entity type 
  //       - or entity set
  // csn: annotation at element of entity
  //      target in edm is the corresponding element of the entity type
  // csn: annotation at parameter of action of entity
  //      target in edm is the action parameter in the EntityContainer



  // handle the annotations of the elements of an object
  // in: objname : name of the object
  //     object : the object itself
  function handleElements(objname, object) {
    if (!object.elements) return;
    for (let elemName in object.elements) {
      let element = object.elements[elemName];

      // determine the name of the target in the resulting edm
      //   for non-assoc element, this simply is "<objectName>/<elementName>"
      let edmTargetName = objname + "/" + elemName;
      handleAnnotations(edmTargetName, element);

      // handle sub elements
      if (element.elements) {
        handleNestedElements(objname, elemName, element.elements);
      }
    }
  }

  // handling annotations at nested elements is not yet supported
  // => issue a warning, but only if there actually are annotations
  function handleNestedElements(objname, baseElemName, elementsObj) {
    for (let elemName in elementsObj) {
      let element = elementsObj[elemName];

      if (Object.keys(element).filter( x => x.substr(0,1) == "@" ).filter(filterKnownVocabularies).length > 0) {
        warningMessage(null, "annotations at nested elements are not yet supported, object " + objname + ", element " + baseElemName + "." + elemName);
      }

      if (element.elements) {
        handleNestedElements(objname, baseElemName + "." + elemName, element.elements);
      }
    }
  }


  // annotations for actions and functions (and their parameters)
  // v2, unbound:          Target = <service>.EntityContainer/<action/function>
  // v2, bound:            Target = <service>.EntityContainer/<entity>_<action/function>
  // v4, unbound action:   Target = <service>.<action>()
  // v4, bound action:     Target = <service>.<action>(<service>.<entity>)
  // v4, unbound function: Target = <service>.<function>(<1st param type>, <2nd param type>, ...)
  // v4, bound function:   Target = <service>.<function>(<service>.<entity>, <1st param type>, <2nd param type>, ...)

  // handle the annotations of cObject's (an entity) bound actions/functions and their parameters
  // in: cObjectname : qualified name of the object that holds the actions
  //     cObject     : the object itself
  function handleBoundActions(cObjectname, cObject) {
    // service name -> remove last part of the object name
    // only works if all objects ly flat in the service
    let nameParts = cObjectname.split(".")
    let entityName = nameParts.pop();
    let serviceName = nameParts.join(".");

    for (let n in cObject.actions) {
      let action = cObject.actions[n];
      let actionName = serviceName + "." + (isV2() ? entityName + '_' : '') + n;
      handleAction(actionName, action, cObjectname);
    }
  }

  // handle the annotations of an action and its parameters
  //   called by handleBoundActions and directly for unbound actions/functions
  // in: cActionName       : qualified name of the action
  //     cAction           : the action object
  //     entityNameIfBound : qualified name of entity if bound action/function
  function handleAction(cActionName, cAction, entityNameIfBound) {
    let actionName = cActionName;
    if (isV2()) { // insert before last "."
      actionName = actionName.replace(/\.(?=[^.]*$)/, '.EntityContainer/')
    }
    else { // add parameter type list
      actionName += relParList(cAction, entityNameIfBound);
    }

    handleAnnotations(actionName, cAction);
    for (let n in cAction.params) { // handle parameters
      let edmTargetName = actionName + "/" + n;
      handleAnnotations(edmTargetName, cAction.params[n]);
    }
  }

  function relParList(action, bindingParam) {
    // we rely on the order of params in the csn being the correct one
    let params = [];
    if (bindingParam) params.push(bindingParam);
    if (action.kind === 'function') {
      for (let n in action.params) {
        let p = action.params[n];
        let otype = p.type.startsWith('cds.') ? glue.mapCdsToEdmType(p.type, false /*is only called for v4*/) : p.type;
        params.push(otype);
      }
    }
    return '(' + params.join(',') + ')';
  }


  // note: in csn, all annotations are flattened out
  // => values can be
  //    - primitive values (string, number)
  //    - pseudo-records with "#" or "="
  //    - arrays


  // handle the annotations for a specific object or element or action parameter,
  //   here called carrier
  //   edmCarrierName : string, name of the annotated object in edm,
  //                    element path is separated from object name by "/"
  //            TODO: handling of nested elements?
  //   carrier: object, the annotated object, contains all the annotations
  //                    as properties with names starting with @
  function handleAnnotations(edmCarrierName, carrier) {
    // collect the names of the carrier's annotation properties
    // keep only those annotations that - start with a known vocabulary name
    //                                  - have a value other than null
    let annoNames = Object.keys(carrier).filter( x => x.substr(0,1) == "@" );
    let knownAnnos = annoNames.filter(filterKnownVocabularies).filter(x => carrier[x] !== null);
    if (knownAnnos.length == 0) return;

    // build prefix tree for the annotations attached to the carrier
    let prefixTree = {};
    for (let a of knownAnnos) {
      // remove leading @ and split at "."
      //   stop splitting at ".@" (used for nested annotations)
      let sa = a.split(".@");
      let steps = sa[0].slice(1).split(".");
      if (sa[1]) {
        steps.push('@' + sa[1]);
      }
      mergePathStepsIntoPrefixTree(prefixTree, steps, 0, carrier);
    }

    // addAnnotation() is used to actually add an <Annotation ...> to the
    //   respective <Annotations ...> element
    let addAnnotation = function() {
      let appliesTest = null; // used in closure
      let stdName = edmCarrierName;
      let altName = null; // used in closure
      if (carrier.kind === 'entity' || carrier.kind === 'view') {
        // if annotated object is an entity, annotation goes to the EntityType,
        //   except if AppliesTo contains EntitySet but not EntityType, then annotation goes to EntitySet
        appliesTest = (x => x.match(/EntitySet/) && !x.match(/EntityType/));
        // find last . in name and insert "EntityContainer/"
        altName = edmCarrierName.replace(/\.(?=[^.]*$)/, '.EntityContainer/');
      }
      else if (carrier.kind === 'service') {
        // if annotated object is a service, annotation goes to EntityContainer,
        //   except if AppliesTo contains Schema but not EntityContainer, then annotation goes to Schema
        appliesTest = (x => x.match(/Schema/) && !x.match(/EntityContainer/));
        stdName = edmCarrierName + '.EntityContainer';
        altName = edmCarrierName;
      }

      // result objects that holds all the annotation objects to be created
      let newAnnosStd = new Edm.Annotations(v, stdName); // used in closure
      g_annosArray.push(newAnnosStd);
      let newAnnosAlt = null; // used in closure

      return function(annotation, appliesTo) {
        if (appliesTest && appliesTo && appliesTest(appliesTo)) {
          if (carrier.kind === 'service') {
            if (isV2()) {
              // there is no enclosing <Annotations ...>, so for v2 the namespace needs to be mentioned here
              annotation.setXml( { xmlns: "http://docs.oasis-open.org/odata/ns/edm" } );
            }
            g_annosArray.push(annotation); // for target Schema: no <Annotations> element
          }
          else {
            if (!newAnnosAlt) { // only create upon insertion of first anno
              newAnnosAlt = new Edm.Annotations(v, altName);
              g_annosArray.push(newAnnosAlt);
            }
            newAnnosAlt.append(annotation);
          }
        }
        else {
          newAnnosStd.append(annotation);
        }
      }
    }();

    // now create annotation objects for all the annotations of carrier
    //   and put them into the elements property of the result object
    handleAnno2(addAnnotation, edmCarrierName /*used for messages*/, prefixTree);
  }


  // tree: object where to put the next level of names
  // path: the parts of the annotation name
  // index: index into that array pointing to the next name to be processed
  //   0  : vocabulary
  //   1  : term
  //   2+ : record properties
  //
  // example:
  //   @v.t1
  //   @v.t2.p1
  //   @v.t2.p2
  //   @v.t3#x.q1
  //   @v.t3#x.q2
  //   @v.t3#y.q1
  //   @v.t3#y.q2
  // 
  //   { v : { t1 : ...,
  //           t2 : { p1 : ...,
  //                  p2 : ...   },
  //           t3#x : { q1 : ..., 
  //                    q2 : ... }
  //           t3#y : { q1 : ...,
  //                    q2 : ... } } }
  function mergePathStepsIntoPrefixTree(tree, pathSteps, index, carrier) {
    // TODO check nesting level > 3
    let name = pathSteps[index];
    if (index+1 < pathSteps.length ) {
      if (!tree[name]) {
        tree[name] = {};
      }
      mergePathStepsIntoPrefixTree(tree[name], pathSteps, index+1, carrier);
    }
    else {
      tree[name] = carrier["@" + pathSteps.join('.')];
    }
  }


  function handleAnno2(addAnnotationFunc, edmCarrierName, prefixTree) {
    // first level names of prefix tree are the vocabulary names
    // second level names are the term names
    // create an annotation object for each term
    for (let voc of Object.keys(prefixTree)) {
      for (let term of Object.keys(prefixTree[voc])) {
        let fullTermName = voc + "." + term;

        // anno is the full <Annotation Term=...>
        let context = { target: edmCarrierName,  term: fullTermName, stack: [] };
        let anno = handleTerm(fullTermName, prefixTree[voc][term], context);

        // addAnnotationFunc needs AppliesTo info from dictionary to decide where to put the anno
        fullTermName = fullTermName.replace(/#(\w+)$/g, "");
        let dictTerm = getDictTerm(fullTermName, context); // message for unknown term issued in handleTerm
        addAnnotationFunc(anno, dictTerm && dictTerm.AppliesTo);
      }
    }
  }


  // annoValue : the annotation value from the csn
  //             if the csn contains flattened out elements of a structured annotation,
  //             they are regrouped here
  // context :   for messages
  // return :    object that represents the annotation in the result edmx
  function handleTerm(termName, annoValue, context) {
    let newAnno = new Edm.Annotation(v, termName);

    // termName may contain a qualifier: @UI.FieldGroup#shippingStatus
    // -> remove qualifier from termName and set Qualifier attribute in newAnno
    let p = termName.split('#');
    let termNameWithoutQualifiers = p[0];
    if (p.length>1) {
      newAnno.Term = termNameWithoutQualifiers;
      newAnno.Qualifier = p[1];
    }
    if (p.length>2) {
      warningMessage(context, "multiple qualifiers (" + p[1] + "," + p[2] +  (p.length>3?',...':'') + ")")
    }

    // get the type of the term from the dictionary
    let termTypeName = null;
    let dictTerm = getDictTerm(termNameWithoutQualifiers, context);
    if (dictTerm) {
      termTypeName = dictTerm.Type;
    }
    else {
      warningMessage(context, "unknown term " + termNameWithoutQualifiers);
    }

    handleValue(annoValue, newAnno, termNameWithoutQualifiers, termTypeName, context);
    return newAnno;
  }

  // found an enum value ("#"), check whether this fits
  //  the expected type "expectedTypeName"
  function checkEnumValue(enumValue, expectedTypeName, context) {
    let expectedType = getDictType(expectedTypeName);
    if (!expectedType && !isPrimitiveType(expectedTypeName)) {
      warningMessage(context, "internal error: dictionary inconsistency: type '" + expectedTypeName + "' not found");
    }
    else if (isComplexType(expectedTypeName)) {
      warningMessage(context, "found enum value, but expected complex type " + expectedTypeName);
    }
    else if (isPrimitiveType(expectedTypeName) || expectedType["$kind"] != "EnumType") {
      warningMessage(context, "found enum value, but expected non-enum type " + expectedTypeName);
    }
    else if (!expectedType["Members"].includes(enumValue)) {
      warningMessage(context, "enumeration type " + expectedTypeName + " has no value " + enumValue);
    }
    return;
  }

  // found an expression value ("=") "expr"
  //   expected type is dTypeName
  // note: expr can also be provided if an enum/complex type/collection is expected
  function handleExpression(expr, dTypeName, context) {
    let typeName = "Path";
    if( ['Edm.AnnotationPath', 'Edm.ModelElementPath', 'Edm.NavigationPropertyPath', 'Edm.PropertyPath', 'Edm.Path' ].includes(dTypeName) )
      typeName = dTypeName.split('.')[1];

    let val = expr;
    if (!expr) {
      warningMessage(context, "empty expression value");
    }
    else {
      // replace all occurrences of '.' by '/' up to first '@'
      val = expr.split('@').map((o,i) => (i==0 ? o.replace(/\./g, '/') : o)).join('@');
    }

    return {
      name : typeName,
      value : val
    }
  }


  // found a simple value "val"
  //  expected type is dTypeName
  //  mappping rule for values:
  //    if expected type is ... the expression to be generated is ...
  //      floating point type except Edm.Decimal -> Float
  //      Edm.Decimal -> Decimal
  //      integer tpye -> Int
  function handleSimpleValue(val, dTypeName, context) {
    // caller already made sure that val is neither object nor array
    dTypeName = resolveType(dTypeName);

    let typeName = "String";

    if(dTypeName == 'Edm.PrimitiveType')
      dTypeName = undefined;

    if (typeof val === 'string') {
      // https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L923
      let isBool = ['true', 'false'].includes(val);
      let isNum =  /^((\+|-)?\d+(.\d+)?(e(\+|-)?\d+)?[fFmMdD]?|NaN|-?INF)$/.test(val);

      switch(dTypeName) {
        case 'Edm.Boolean':
          typeName = 'Bool';
          if(!isBool) {
            warningMessage(context, "found String, but expected type " + dTypeName);
          }
          break;
        case 'Edm.Double':
        case 'Edm.Single':
          typeName = 'Float';
          if(!isNum) {
            warningMessage(context, "found non-numeric string, but expected type " + dTypeName);
          }
          break;
        case 'Edm.Decimal':
          typeName = 'Decimal';
          if(!isNum) {
            warningMessage(context, "found non-numeric string, but expected type " + dTypeName);
          }
          break;
        default:
          if(dTypeName) {
            if(isComplexType(dTypeName)) {
              warningMessage(context, "found String, but expected complex type " + dTypeName);
            }
            else if(isEnumType(dTypeName)) {
              warningMessage(context, "found String, but expected enum type " + dTypeName);
              typeName = "EnumMember";
            }
            else if(dTypeName.startsWith('Edm.')) {
              typeName = dTypeName.substring(4);
            }
            else {
              // TODO
              //warningMessage(context, "type is not yet handled: found String, expected type: " + dTypeName);
            }
          }
          else { // no dTypeName, best guessing
            if(isBool) {
              typeName = 'Bool';
              dTypeName = 'Edm.Boolean';
            }
            else if(isNum) {
              typeName = 'Int';
              if(/^(\+|-)?\d{1,19}$/.test(val)) {
                let n = parseInt(val);
                if (n >= -32768 && n <= 32767) {
                  dTypeName = 'Edm.Int16';
                } else if(n >= -2147483648 && n <= 2147483647) {
                  dTypeName = 'Edm.Int32';
                } else {
                  dTypeName = 'Edm.Int64';
                }
              }
              else {
                typeName = 'Decimal';
                dTypeName = 'Edm.Decimal';
              }
            }
            else {
              //8HEXDIG "-" 4HEXDIG "-" 4HEXDIG "-" 4HEXDIG "-" 12HEXDIG 
              if(/^[a-fA-F\d]{8}-[a-fA-F\d]{4}-[a-fA-F\d]{4}-[a-fA-F\d]{4}-[a-fA-F\d]{12}$/.test(val)) {
                typeName = 'Guid';
                dTypeName = 'Edm.Guid';
              } 
              else if(/^(\+|-)?P(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d+)?S)?)?$/.test(val)) {
                typeName = 'Duration';
                dTypeName = 'Edm.Duration';
              }
              // Date Matchgroup 1 ^((\d{1,4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))
              // TimeOffset Matchgroup 5 (T([0-1]\d|2[[0-3])(:|%3[aA])[05]\d(:|%3[aA])[05]\d(\.\d{1,12})?(Z|-?([0-1]\d|2[[0-3])(:|%3[aA])[05]\d)?)?)$
              else {
                let m = val.match(/^((\d{1,4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))(T([0-1]\d|2[[0-3])(:|%3[aA])[05]\d(:|%3[aA])[05]\d(\.\d{1,12})?(Z|-?([0-1]\d|2[[0-3])(:|%3[aA])[05]\d)?)?)$/);
                if(m) {
                  if(m[5]) {
                    typeName = 'DateTimeOffset';
                    dTypeName = 'Edm.DateTimeOffset';
                  }
                  else {
                    typeName = 'Date';
                    dTypeName = 'Edm.Date'
                  }
                }
                else {
                  typeName = 'String';
                  dTypeName = 'Edm.String';
                }
              }
            }
          }
      }
    }
    else if (typeof val === 'boolean') {
      if(dTypeName == undefined)
        dTypeName = 'Edm.Boolean';
      switch(dTypeName) {
        case 'Edm.Boolean':
          typeName = 'Bool';
          break;
        case 'Edm.String':
          val = val.toString();
          break;
        default:
          warningMessage(context, "found Boolean, but expected type " + dTypeName);
          break;
      }
    }
    else if (typeof val === 'number') {
      if(dTypeName == undefined) {
        if(Number.isInteger(val)) {
          if (val >= -32768 && val <= 32767) {
            dTypeName = 'Edm.Int16';
          } else if(val >= -2147483648 && val <= 2147483647) {
            dTypeName = 'Edm.Int32';
          } else {
            dTypeName = 'Edm.Int64';
          }
        }
        else {
          dTypeName = 'Edm.Decimal';
        }
      }
      switch(dTypeName) {
        case 'Edm.String':
          typeName = 'String';
          break;
        case 'Edm.Single':
        case 'Edm.Double':
          typeName = 'Float';
          break;
        case 'Edm.Decimal':
          typeName = 'Decimal';
          break;
        case 'Edm.Int16':
        case 'Edm.Int32':
        case 'Edm.Int64':
        case 'Edm.Byte':
        case 'Edm.SByte':
          typeName = 'Int';
          break;
        default:
          if(isComplexType(dTypeName)) {
            warningMessage(context, "found number, but expected complex type " + dTypeName);
          }
          else {
            // all others (Paths, Enums)
            warningMessage(context, "found number, but expected type " + dTypeName);
          }
      }
    }
    else {
      warningMessage(context, "expected simple value, but found value '" + val + "' with type '" + typeof val + "'");
    }

    if(typeName == undefined)
      throw Error('Please debug me: typeName unset for value: ' + val);
    if(dTypeName == undefined)
      throw Error('Please debug me: dtypeName unset for value: ' + val);

    if( ['Edm.AnnotationPath', 'Edm.ModelElementPath', 'Edm.NavigationPropertyPath', 'Edm.PropertyPath', 'Edm.Path' ].includes(dTypeName) )
      dTypeName = dTypeName.split('.')[1];

    return {
      name : typeName,
      jsonName: dTypeName,
      value : val
    };
  }



  // handle the actual value cAnnoValue
  //   oTarget: the result object
  //   oTermName: current term
  //   dTypeName: expected type of cAnnoValue according to dictionary, may be null
  function handleValue(cAnnoValue, oTarget, oTermName, dTypeName, context) {
    // value can be: array, expression, enum, pseudo-record, record, simple value

    if (Array.isArray(cAnnoValue))
    {
      if (isEnumType(dTypeName))
      {
        // if we find an array although we expect an enum, this may be a "flag enum"
        checkMultiEnumValue(cAnnoValue, dTypeName, context);
        oTarget.setJSON({ "EnumMember": generateMultiEnumValue(cAnnoValue, dTypeName, false), "EnumMember@odata.type" : '#'+dTypeName });
        oTarget.setXml( { "EnumMember": generateMultiEnumValue(cAnnoValue, dTypeName, true) });
      }
      else
      {
        oTarget.append(generateCollection(cAnnoValue, oTermName, dTypeName, context));
      }
    }
    else if (cAnnoValue && typeof cAnnoValue === 'object') {
      if (Object.keys(cAnnoValue).length == 0) {
        warningMessage(context, "empty record");
      }
      else if ("=" in cAnnoValue) {
        let res = handleExpression(cAnnoValue["="], dTypeName, context);
        oTarget.setXml( { [res.name] : res.value });
        oTarget.setJSON( { [res.name] : res.value });
      }
      else if (cAnnoValue["#"] !== undefined)
      {
        if (dTypeName)
        {
          checkEnumValue(cAnnoValue["#"], dTypeName, context);
          oTarget.setJSON({ "EnumMember": cAnnoValue["#"], "EnumMember@odata.type" : '#'+dTypeName,  });
          oTarget.setXml( { "EnumMember": dTypeName + "/" + cAnnoValue["#"] });
        }
        else
        {
          oTarget.setJSON({ "EnumMember": cAnnoValue["#"], "EnumMember@odata.type" : '#'+oTermName + "Type/" });
          oTarget.setXml( { "EnumMember": oTermName + "Type/" + "/" + cAnnoValue["#"] });
        }
      }
      else if (cAnnoValue["$value"] !== undefined) {
        // "pseudo-structure" used for annotating scalar annotations
        handleValue(cAnnoValue["$value"], oTarget, oTermName, dTypeName, context);

        let k = Object.keys(cAnnoValue).filter( x => x.charAt(0) == "@");
        if (!k || k.length == 0) {
          warningMessage(context, "pseudo-struct without nested annotation");
        }
        for (let nestedAnnoName of k) {
          let nestedAnno = handleTerm(nestedAnnoName.slice(1), cAnnoValue[nestedAnnoName], context);
          oTarget.append(nestedAnno);
        }
      }
      else if (cAnnoValue["$edmJson"]) {
        // "pseudo-structure" used for embedding a piece of JSON that represents "OData CSDL, JSON Representation"
        oTarget.append(handleEdmJson(cAnnoValue["$edmJson"], context));
      }
      else if ( Object.keys(cAnnoValue).filter( x => x.substr(0,1) !== "@" ).length === 0) {
        warningMessage(context, "nested annotations without corresponding base annotation");
      }
      else {
        // regular record
        oTarget.append(generateRecord(cAnnoValue, oTermName, dTypeName, context));
      }
    }
    else {
      let res = handleSimpleValue(cAnnoValue, dTypeName, context);
      oTarget.setXml( { [res.name] : res.value });
      oTarget.setJSON( { [res.jsonName] : res.value });
    }
  }


  // cAnnoValue: array
  // dTypeName: expected type, already identified as enum type
  //   array is expected to contain enum values
  function checkMultiEnumValue(cAnnoValue, dTypeName, context) {
    // we know that dTypeName is not null
    let type = getDictType(dTypeName);
    if (!type || type["IsFlags"] != "true") {
      warningMessage(context, "enum type '" + dTypeName + "' doesn't allow multiple values");
    }

    let index = 0;
    for (let e of cAnnoValue) {
      context.stack.push("[" + index++ + "]");
      if (e["#"]) {
        checkEnumValue(e["#"], dTypeName, context);
      }
      else {
        // TODO improve message: but found ...
        warningMessage(context, "expected an enum value");
      }
      context.stack.pop();
    }
  }

  function generateMultiEnumValue(cAnnoValue, dTypeName, forXml)
  {
    // remove all invalid entries (warnining message has already been issued)
    // replace short enum name by the full name
    // concatenate all the enums to a string, separated by spaces
    return cAnnoValue.filter( x => x["#"] != undefined ).map( x => (forXml ? dTypeName + "/" : "") + x["#"] ).join(forXml ? ' ' : ',');
  }


  // obj:       object representing the record
  // dictRecordTypeName : name of the expected record type according to vocabulary, may be null
  // 
  // can be called for a record directly below a term, or at a deeper level
  //   if the corresponding complex type is unique, it needs not to be written into the
  //   record; if it is abstract or part of a type hierarchy, it must be written
  //   into the record as attribute "Type"
  function generateRecord(obj, termName, dictRecordTypeName, context) {
    let newRecord = new Edm.Record(v);
    let actualTypeName = null;

    if (dictRecordTypeName && !isComplexType(dictRecordTypeName)) {
      if (!getDictType(dictRecordTypeName) && !isPrimitiveType(dictRecordTypeName) && !isCollection(dictRecordTypeName))
        warningMessage(context, "internal error: dictionary inconsistency: type '" + dictRecordTypeName + "' not found");
      else
        warningMessage(context, "found complex type, but expected type '" + dictRecordTypeName + "'");
      return newRecord;
    }

    if (obj["$Type"]) { // type is explicitly specified
      actualTypeName = obj["$Type"];
      if (!getDictType(actualTypeName)) {
        // this type doesn't exist
        warningMessage(context, "explicitly specified type '" + actualTypeName + "' not found in vocabulary");
      }
      else if (dictRecordTypeName && !isDerivedFrom(actualTypeName, dictRecordTypeName)) {
        // this type doesn't fit the expected one
        warningMessage(context, "explicitly specified type '" + actualTypeName
                            + "' is not derived from expected type '" + dictRecordTypeName + "'");
        actualTypeName = dictRecordTypeName;
      }
      else if (isAbstractType(actualTypeName)) {
        // this type is abstract
        warningMessage(context, "explicitly specified type '" + actualTypeName + "' is abstract, specify a concrete type");
        actualTypeName = dictRecordTypeName;
      }
      else {
        // ok
      }
      newRecord.Type = actualTypeName;
    }
    else if (dictRecordTypeName) { // there is an expected type name according to dictionary
      // convenience for common situation:
      //   if DataFieldAbstract is expected and no explicit type is provided, automatically choose DataField
      if (dictRecordTypeName == "UI.DataFieldAbstract") {
        actualTypeName = "UI.DataField";
      }
      else {
        actualTypeName = dictRecordTypeName;
      }

      if (isAbstractType(actualTypeName)) {
        warningMessage(context, "type '" + dictRecordTypeName + "' is abstract, use '$Type' to specify a concrete type");
      }

      newRecord.Type = actualTypeName;
    }
    else {
      // no expected type set -> do not set newRecord.Type
    }

    let dictProperties = getAllProperties(actualTypeName);

    // loop over elements
    for (let i in obj) {
      context.stack.push("." + i);

      if (i == "$Type") {
        // nop
      }
      else if (i.charAt(0) == "@") {
        let newAnno = handleTerm(i.substring(1, i.length), obj[i], context);
        newRecord.append(newAnno);
      }
      else {
        let dictPropertyTypeName = null;
        if (dictProperties) {
          dictPropertyTypeName = dictProperties[i];
          if (!dictPropertyTypeName){
            warningMessage(context, "record type '" + actualTypeName + "' doesn't have a property '" + i + "'");
          }
        }

        let newPropertyValue = new Edm.PropertyValue(v, i);
        handleValue(obj[i], newPropertyValue, termName, dictPropertyTypeName, context);
        newRecord.append(newPropertyValue);
      }

      context.stack.pop();
    }

    return newRecord;
  }


  // annoValue is an array
  // dTypeName : Collection(...) according to dictionary
  //
  function generateCollection(annoValue, termName, dTypeName, context) {
    let newCollection = new Edm.Collection(v);

    let innerTypeName = null;
    if (dTypeName) {
      var match = dTypeName.match(/^Collection\((.+)\)/);
      if (match) {
        innerTypeName = match[1];
      }
      else {
        warningMessage(context, "found collection value, but expected non-collection type " + dTypeName);
      }
    }

    let index = 0;
    for (let value of annoValue) {
      context.stack.push("[" + index++ + "]");

      if (Array.isArray(value)) {
        warningMessage(context, "nested collections are not supported");
      }
      else if (value && typeof value === 'object') {
        if (value["="]) {
          let res = handleExpression(value["="], innerTypeName, context);
          let newPropertyPath = new Edm.ValueThing(v, res.name, res.value );
          newPropertyPath.setJSON( { [res.name] : res.value } );
          newCollection.append(newPropertyPath);
        }
        else if (value["#"]) {
          warningMessage(context, "enum inside collection is not yet supported");
        }
        else {
          let rec = generateRecord(value, termName, innerTypeName, context);
          newCollection.append(rec);
        }
      }
      else {
        let res = handleSimpleValue(value, innerTypeName, context);
        let newThing = new Edm.ValueThing(v, res.name, value );
        newThing.setJSON( { [res.jsonName] : res.value });
        newCollection.append(newThing);
      }

      context.stack.pop();
    }

    return newCollection;
  }

  function handleEdmJson(obj, context)
  {
    let specialProperties = [ '$Apply', '$LabeledElement' ];
    let subset = glue.intersect(specialProperties, Object.keys(obj));
    
    if(subset.length > 1) { // doesn't work for three or more...
      warningMessage(context, "edmJson code contains more than one special property: " + subset);
      return null;
    }
    if(subset.length == 0) {
      // only one property (that is not a special property)
      if (Object.keys(obj) != undefined && Object.keys(obj).length==1) {
        let k = Object.keys(obj)[0];
        return new Edm.ValueThing(v, k.slice(1), obj[k] );
      }
      warningMessage(context, "edmJson code contains no special property out of: " + specialProperties);
      return null;
    }

    // name of special property determines element kind
    let newElem = new Edm.Thing(v, subset[0].slice(1));
    let mainAttribute = null;

    for (let p in obj) {
      // copy all '$' attributes that are not $Apply or $LabeledElement to Thing
      if(specialProperties.every(v => 
        { return p != v })) 
      {
        if (p.charAt(0) == "$") {
          // simple attribute
          newElem[p.slice(1)] = obj[p];
        }
        else {
          warningMessage(context, "unexpected element without $: " + p);
        }
      } 
      else { // we are either $Apply or $LabeledElement
        // handle value of special property
        let val = obj[p];
        if (Array.isArray(val)) {
          for (let a of val) {
            if (a && typeof a === 'object' && !Array.isArray(a)) {
              newElem.append(handleEdmJson(a, context));
            }
            else if (Array.isArray(a)) {
              warningMessage(context, "verbatim code contains nested array");
            }
            else {
              if (typeof a === 'string') {
                a = a.replace(/&/g, '&amp;')
              }
              newElem.append(new Edm.ValueThing(v, getTypeName(a),  a));
            }
          }
        }
        else if (val && typeof val === 'object') {
          if (Object.keys(val) != undefined && Object.keys(val).length==1) {
            let k = Object.keys(val)[0];
            mainAttribute = { name: k.slice(1), val: val[k] };
          }
          else {
            let el = handleEdmJson(val, context);
            if (el) {
              newElem.append(el);
            }
          }
        }
        else {
          mainAttribute = { name: getTypeName(val), val: val };
        }
      }
    }

    // special property has a simple value:
    //   value is added as attribute to the element; we add it
    //   only after the other attributes in order to reproduce order
    //   (which is semantically insignificant, but it's nicer this way)
    if (mainAttribute) {
      newElem[mainAttribute.name] = mainAttribute.val;
    }

    return newElem;

    function getTypeName(val) {
      let typeName = "String";
      if (typeof val === 'boolean') {
        typeName = "Bool";
      }
      else if (typeof val === 'number') {
        typeName = Number.isInteger(val) ? 'Int' : 'Decimal';
      }
      return typeName;
    }
  }

  // filter function, assumed to be used for array of string
  //   accepts those strings that start with a known vocabulary name
  function filterKnownVocabularies(name) {
    var match = name.match(/^(@)(\w+)/);
    if (match == null) return false;
    return knownVocabularies.includes(match[2]);  // second match group
  }



  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------

  // resolve "derived types"
  // -> if dTypeName is a TypeDefinition, replace by
  //    underlying type
  function resolveType(dTypeName) {
    let type = getDictType(dTypeName);
    if (type && type.UnderlyingType && type["$kind"] == "TypeDefinition") {
      return type.UnderlyingType;
    }
    return dTypeName;
  }

  function isPrimitiveType(typeName) {
    return typeName.split('.')[0] == "Edm";
  }

  function isCollection(typeName) {
    return typeName.match(/^Collection\((.+)\)/) !== null;
  }

  function isEnumType(dTypeName) {
    let type = getDictType(dTypeName);
    return type && type["$kind"] == "EnumType";
  }

  function isComplexType(dTypeName) {
    let type = getDictType(dTypeName);
    return type && type["$kind"] == "ComplexType";
  }

  function isAbstractType(dTypeName) {
    let type = getDictType(dTypeName);
    return type && type["Abstract"] === "true";
  }

  // return true if derived has baseCandidate as direct or indirect base type
  function isDerivedFrom(derived, baseCandidate) {
    while (derived) {
      if (derived == baseCandidate) return true;
      derived = getDictType(derived).BaseType;
    }
    return false;
  }


  // return dictionary of all properties of typeName, including those of base types
  function getAllProperties(typeName) {
    if (!typeName || !getDictType(typeName)) return null;
    return getDictType(typeName).Properties;
  }

}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

module.exports = { knownVocabularies, csn2annotationEdm };
