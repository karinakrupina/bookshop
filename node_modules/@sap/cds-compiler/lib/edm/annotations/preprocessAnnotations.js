'use strict';

const glue = require('../glue');
const alerts = require('../../base/alerts');


/**************************************************************************************************
 * preprocessAnnotations
 *
 * options:
 *   tntFlavor
 *
 * This module never produces errors. In case of "unexpected" situations we issue a warning and
 * try to proceed with the processing as good as possible.
 *
 */
function preprocessAnnotations(csn, options) {
  const { warning, signal } = alerts(csn);
  let fkSeparator = (options && options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : '_';

  if (options && options.tntFlavor) {
    addCommonTextAndCommonValueListToAssociations();
    moveAnnotationsFromAssocToForeignKeys();
  }
  // for resolveShortcuts... the check for tntFlavor is done inside the function,
  //   because not all transformations are TnT specific
  resolveShortcutsAndTNTspecificModifications();


  // ----------------------------------------------------------------------------------------------
  // helper functions
  // ----------------------------------------------------------------------------------------------

  // helper to determine the OData version
  //   tnt is always v2
  // TODO: improve option handling and revoke this hack for tnt
  function isV2() {
    return options.tntFlavor || (options.v && options.v[0]);
  }

  function getTargetOfAssoc(assoc) {
    // assoc.target can be the name of the target or the object itself
    return (typeof assoc.target === 'object') ? assoc.target      : csn.definitions[assoc.target];
  }

  // return value can be null is target has no key
  function getKeyOfTargetOfManagedAssoc(assoc) {
    // assoc.target can be the name of the target or the object itself
    let targetName = (typeof assoc.target === 'object') ? assoc.target.name : assoc.target;
    let target     = (typeof assoc.target === 'object') ? assoc.target      : csn.definitions[assoc.target];

    let keyNames = Object.keys(target.elements).filter(x => target.elements[x].key);
    if (keyNames.length == 0) {
      keyNames.push['MISSING'];
      signal(warning`in annotation preprocessing: target ${targetName} has no key`);
    }
    else if (keyNames.length > 1)
      signal(warning`in annotation preprocessing: target ${targetName} has multiple key elements`);

    // TODO: what happens if key of target is itself a managed association?
    return keyNames[0];
  }

  // ----------------------------------------------------------------------------------------------
  // main annotation processors
  // ----------------------------------------------------------------------------------------------

  function addCommonTextAndCommonValueListToAssociations() {

    // TNT - TextAndCommonValueListToAssociations
    if (!(options && options.tntFlavor && options.tntFlavor.skipAnnosTextAndValueListForAssocs)) {
      glue.forAll(csn.definitions, (art) => {
        glue.forAll(art.elements, (elt, eltName) => {
          handleAnnotations(eltName, elt, art);
        })
      });
    }

    function handleAnnotations(elemName, elem, object) {
      if(!((object.kind == 'entity' || object.kind == 'view') &&
          (elem.type == "cds.Association" || elem.type == "Association") && elem.on == undefined && elem.onCond == undefined))
        return;

      let assoc = elem;

      if (assoc["@odata.navigable"] != undefined && assoc["@odata.navigable"] == false) {
        return;
      }

      let targetName = assoc.target.name;
      let targetNameShort = targetName.split(".").pop();
      let fkName = getKeyOfTargetOfManagedAssoc(assoc);

      let targetEntity = assoc.target; // csn.definitions[targetName];

      // ValueList.Label
      // 1) Common.Label of assoc
      // 2) Common.Label of target entity
      // 3) name of target entity
      let label = "UNKNOWN1";
      if (assoc["@Common.Label"] != undefined) {
        label = assoc["@Common.Label"];
      }
      else if (targetEntity["@Common.Label"] != undefined) {
        label = targetEntity["@Common.Label"];
      }
      else {
        label = targetNameShort;
      }

      // for Common.Text and DisplayOnly
      let uiId = null;
      let tEId = targetEntity["@UI.Identification"];
      if (tEId && tEId[0])
      {
        if (tEId[0]["="]) {
          uiId = tEId[0]["="];
        }
        else if (tEId[0]["Value"] && tEId[0]["Value"]["="]) {
          uiId = tEId[0]["Value"]["="];
        }
      }

      // @Common.Text
      if (uiId != null) {
        assoc["@Common.Text"] = {
          "$value": { "=": elemName + "/" + uiId },
          "@UI.TextArrangement": { "#": "TextOnly" }
        };
      }

      assoc["@Common.ValueList.Label"] = label;
      assoc["@Common.ValueList.CollectionPath"] = targetNameShort;
      assoc["@Common.ValueList.Parameters"] = [
        {
          "$Type": "Common.ValueListParameterInOut",
          "LocalDataProperty": { "=": elemName + fkSeparator + fkName },
          "ValueListProperty": fkName
        }
      ];

      if (uiId != null) {
        assoc["@Common.ValueList.Parameters"].push(
          {
            "$Type": "Common.ValueListParameterDisplayOnly",
            "ValueListProperty": uiId
          }
        );
      }
    }
  }


  /*
  Forward all annotations from the association element to its generated foreign key elements
  and remove the annotations from the association afterwards (move)
  Input: OData preprocessed CSN with entity definitions
  */
  function moveAnnotationsFromAssocToForeignKeys() {
    // managed association
    // (not at compositions, because we think they never are managed ... ???)
    glue.foreach(csn.definitions, obj => (obj.kind == 'entity' || obj.kind == 'view'), entity => {
      glue.foreach(entity.elements, e => glue.isManagedAssociation(e), (element, elementName) =>
      {
        // copy annotations from assoc to all generated foreign key fields
        // FIXME: This should actually be done always, regardless of TNT (the ODATA preprocesor has already
        // done it for all existing annotations, but all creation/modification magic happening during this
        // post-processing needs to go to the foreign key fields as well). Alternatively, one could make
        // sure that all magic happening here is directly applied to foreign key fields, too.
        if (element.foreignKeys) {
          glue.forAll(element.foreignKeys, fk => {
            addAnnos(fk.generatedFieldName)
          });
        }
        else if (element.keys) {
          for (let x of element.keys) {
            addAnnos(elementName + fkSeparator + x.ref[0])
          }
        }
        function addAnnos(fk_generatedFieldName) {
          glue.forAll(element, (attr, attrName) => {
            if(attrName[0] == '@')
              entity.elements[fk_generatedFieldName][attrName] = attr;
          });

        }
        // remove annotations from assoc (separated from copy because there might be multiple foreign keys)
        if (!(options && options.tntFlavor && options.tntFlavor.skipAnnosRemoveManagedAssociationAnnos)) {
          for (let a in element) {
            if (a[0] == "@") {
              delete element[a];
            }
          }
        }
      });
    });
  }




  // resolve shortcuts and do some TNT specific modifications
  function resolveShortcutsAndTNTspecificModifications() {
    let art = null;

    glue.forAll(csn.definitions, (artifact, artifactName) =>{
      art = artifactName;
      handleAnnotations(artifactName, artifact);
      glue.forAll(artifact.elements, (element, elementName) => {
        handleAnnotations(elementName, element);
      });
      glue.forAll(artifact.actions, (action) => {
        glue.forAll(action.params, (param, paramName) => {
          handleAnnotations(paramName, param);
        });
      });
    });

    function handleAnnotations(carrierName, carrier) {

      function replaceManagedAssocByFK(ae) {
        let path = ae["="];
        let steps = path.split('.');
        let ent = carrier;
        for (let i in steps) {
          if (!ent || ent.kind != 'entity') return;
          let el = ent.elements[steps[i]];
          if (el && glue.isAssociation(el)) {
            if (i < steps.length-1) {
              ent = getTargetOfAssoc(el);
            }
            else { //last step
              if (!el.onCond && !el.on) { // only for managed
                ae["="] += fkSeparator + getKeyOfTargetOfManagedAssoc(el);
              }
            }
          }
        }
      }

      // collect the names of the carrier's annotation properties
      let annoNames = Object.keys(carrier).filter( x => x.substr(0,1) == "@")

      for (let aName of annoNames) {
        let aNameWithoutQualifier = aName.split("#")[0];
        let a = carrier[aName];

        //for warning messages
        let ctx = "target: " + art + "/" + carrierName;

        // Always - draft annotations, value is action name
        //   - v2: prefix with entity name
        //   - prefix with service name
        if ((carrier.kind === 'entity' || carrier.kind === 'view') &&
            (aNameWithoutQualifier == "@Common.DraftRoot.PreparationAction" ||
             aNameWithoutQualifier == "@Common.DraftRoot.ActivationAction" ||
             aNameWithoutQualifier == "@Common.DraftRoot.EditAction" ||
             aNameWithoutQualifier == "@Common.DraftNode.PreparationAction")
           ) {
          let value = carrier[aName];
          // prefix with service name, if not already done
          if (value == "draftPrepare"  || value == "draftActivate" || value == "draftEdit") {
            let serviceName = carrierName.replace(/.[^.]+$/, '');
            value = carrier[aName] = serviceName + '.' + value;
          }
          // for v2: function imports live inside EntityContainer -> path needs to contain "EntityContainer/"
          //         we decided to prefix names of bound action/functions with entity name -> needs to be reflected in path, too
          if (isV2()) {
            let entityNameShort = carrierName.split('.').pop();
            carrier[aName] = value.replace(/(draft(Prepare|Activate|Edit))$/, (match, p1) => 'EntityContainer/' + entityNameShort + '_' + p1)
          }
        }

        // Always - FixedValueListShortcut
        //   expand shortcut form of ValueList annotation
        if (aNameWithoutQualifier == "@Common.ValueList.entity" ||
            aNameWithoutQualifier == "@Common.ValueList.viaAssociation") {
          try {
            // note: we loop over all annotations that were originally present, even if they are
            //       removed from the carrier via this handler
            //       we don't remove anything from the array "annoNames"

            if (aNameWithoutQualifier == "@Common.ValueList.viaAssociation" && !options.betaMode) {
              signal(warning`annotation preprocessing: shortcut annotation ${aNameWithoutQualifier} is only available in beta-mode, ${ctx}`);
              throw 'leave';
            }

            // if CollectionPath is explicitly given, no shortcut expansion is made
            if (carrier["@Common.ValueList.CollectionPath"]) {
              throw "leave";
            }

            if (carrier.kind === 'entity' || carrier.kind === 'view') {
              signal(warning`annotation preprocessing/${aNameWithoutQualifier}: annotation must not be used for an entity, ${ctx}`);
              throw 'leave';
            }

            // check on "type"? e.g. if present, it must be #fixed ... ?

            // value list entity
            let enameShort = null;  // (string) name of value list entity, short (i.e. name within service)
            let enameFull = null;   // (string) name of value list entity, fully qualified name

            if (aNameWithoutQualifier == "@Common.ValueList.viaAssociation") {
              // value is expected to be an expression, namely the path to an association of the carrier entity
              let assocName = carrier["@Common.ValueList.viaAssociation"]['='];
              if (!assocName) {
                signal(warning`in annotation preprocessing/${aNameWithoutQualifier}: value of 'viaAssociation' must be a path, ${ctx}`);
                throw 'leave';
              }
              let assoc = csn.definitions[art].elements[assocName];
              if (!assoc || !(assoc.type === 'cds.Association' || assoc.type === 'cds.Composition')) {
                signal(warning`in annotation preprocessing/${aNameWithoutQualifier}: there is no association "${assocName}", ${ctx}`);
                throw 'leave';
              }

              enameFull = assoc.target.name || assoc.target; // full name
              enameShort = enameFull.split('.').pop();
            }
            else if (aNameWithoutQualifier == "@Common.ValueList.entity") {
              // if both annotations are present, ignore 'entity' and raise a message
              if (annoNames.map(x=>x.split("#")[0]).find(x=>(x=="@Common.ValueList.viaAssociation"))) {
                signal(warning`in annotation preprocessing/@Common.ValueList: 'entity' is ignored, as 'viaAssociation' is present, ${ctx}`);
                throw "leave";
              }

              let annoVal = carrier["@Common.ValueList.entity"]; // name of value list entity
              if (annoVal["="]) {
                signal(warning`in annotation preprocessing/${aNameWithoutQualifier}: annotation value must be a string, ${ctx}`);
              }

              let nameprefix = art.replace(/.[^.]+$/, ''); // better way of getting the service name?

              enameShort = annoVal["="] || annoVal;
              enameFull = nameprefix + '.' + enameShort;
            }

            let vlEntity = csn.definitions[enameFull]; // (object) value list entity
            if (!vlEntity) {
              signal(warning`in annotation preprocessing/${aNameWithoutQualifier}: entity "${enameFull}" does not exist, ${ctx}`);
              throw "leave";
            }

            // label
            //   explicitly provided label wins
            //   TODO: once TnT exception for nonexisting vlEntity is removed, simplify condition
            let label = carrier["@Common.ValueList.Label"] ||
                        carrier["@Common.Label"] || (vlEntity && vlEntity["@Common.Label"]) || enameShort;

            // localDataProp
            //   name of the element carrying the value help annotation
            //   if this is a managed assoc, use fk field instead (if there is a single one)
            let localDataProp = carrierName.split("/").pop();
            if (glue.isManagedAssociation(carrier)) {
              localDataProp = localDataProp + fkSeparator + getKeyOfTargetOfManagedAssoc(carrier);
            }

            // valueListProp: the (single) key field of the value list entity
            //   if no key or multiple keys -> warning
            let valueListProp = null;
            let keys = Object.keys(vlEntity.elements).filter( x => vlEntity.elements[x].key );
            if (keys.length == 0) {
              signal(warning`in annotation preprocessing/value help shortcut: entity "${enameFull}" has no key, ${ctx}`);
              throw "leave";
            }
            else if (keys.length > 1)
              signal(warning`in annotation preprocessing/value help shortcut: entity "${enameFull}" has more than one key, ${ctx}`);
            valueListProp = keys[0];

            // textField:
            //   first entry of @UI.Identification
            //     can be an expression (tnt shortcut before expansion)
            //     can be a record with property 'Value' and expression as its value
            // OR
            //   the (single) non-key string field, if there is one
            let textField = null;
            let Identification = vlEntity['@UI.Identification'];
            if (Identification && Identification[0] && Identification[0]['=']) {
              textField = Identification[0]['='];
            } else if (Identification && Identification[0] && Identification[0]["Value"] && Identification[0]["Value"]['=']) {
              textField = Identification[0]["Value"]['='];
            }
            else {
              let stringFields = Object.keys(vlEntity.elements).filter(
                x => !vlEntity.elements[x].key && vlEntity.elements[x].type == "cds.String")
              if (stringFields.length == 1)
                textField = stringFields[0];
            }

            // explicitly provided parameters win
            let parameters = carrier["@Common.ValueList.Parameters"];
            if (!parameters) {
              parameters = [{
                "$Type": "Common.ValueListParameterInOut",
                "LocalDataProperty" : { "=" : localDataProp },
                "ValueListProperty" : valueListProp
              }];
              if (textField) {
                parameters[1] = {
                  "$Type": "Common.ValueListParameterDisplayOnly",
                  "ValueListProperty" : textField
                };
              }
            }

            let newObj = Object.create( Object.getPrototypeOf(carrier) );
            for (let e in carrier) {
              if (e == "@Common.ValueList.entity" || e == "@Common.ValueList.viaAssociation") {
                newObj["@Common.ValueList.Label"] = label;
                newObj["@Common.ValueList.CollectionPath"] = enameShort;
                newObj["@Common.ValueList.Parameters"] = parameters;
                if (textField && options && options.tntFlavor) {
                  newObj["@Common.Text"] = {
                    // here we rely on ValueListMagic: an association has been created based on @Common.ValueList.fixed
                    "$value": { "=": "to_" + carrierName + "/" + textField },
                    "@UI.TextArrangement": { "#": "TextOnly" }
                  };
                }
              }
              else if (e == "@Common.ValueList.type" ||
                      e == "@Common.ValueList.Label" ||
                      e == "@Common.ValueList.Parameters") {
                // nop
              }
              else {
                newObj[e] = carrier[e];
              }
              delete carrier[e];
            }
            Object.assign(carrier, newObj);
          }
          catch (e) {
            // avoid subsequent warnings
            delete carrier[aNameWithoutQualifier];
            delete carrier["@Common.ValueList.type"];
          }
        }

        // Always - TextArrangementReordering
        //   convert @Common.TextArrangement annotation that is on same level as Text annotation into a nested annotation
        //   TnT only: also accept @UI.TextArrangement
        let tntTextArrangement = options && options.tntFlavor && !options.tntFlavor.skipAnnosTextArrangementReordering;
        if (aNameWithoutQualifier == "@Common.TextArrangement" ||
            (tntTextArrangement && aNameWithoutQualifier == "@UI.TextArrangement")) {
          let value = carrier[aName];
          let textAnno = carrier["@Common.Text"];
          // can only occur if there is a @Common.Text annotation at the same target
          if (!textAnno) {
            signal(warning`in annotation preprocessing: TextArrangement shortcut without Text annotation, ${ctx}`);
          }

          // TNT: this fixes a bug in the TNT model where a string is given instead of an enum
          if (tntTextArrangement) {
            if (value === "TextFirst") {
              value = { "#": value };
            }
          }

          //change the scalar anno into a "pseudo-structured" one
          // TODO should be flattened, but then alphabetical order is destroyed
          let newTextAnno = { "$value": textAnno, "@UI.TextArrangement": value };
          carrier["@Common.Text"] = newTextAnno;
          delete carrier[aName];
        }

        // TNT - SubstitutingFKeysForAssocs
        if (options && options.tntFlavor && !options.tntFlavor.skipAnnosSubstitutingFKeysForAssocs) {
          // replace association by fk field, mind nested annotatinos
          if (aNameWithoutQualifier == "@UI.LineItem"       || aNameWithoutQualifier == "@UI.LineItem.$value" ||
              aNameWithoutQualifier == "@UI.Identification" || aNameWithoutQualifier == "@UI.Identification.$value" ||
              aNameWithoutQualifier == "@UI.FieldGroup"     || aNameWithoutQualifier == "@UI.FieldGroup.$value") {
            for (let ae of a) {
              if (ae["Value"] && ae["Value"]["="]) {
                replaceManagedAssocByFK(ae["Value"]);
              }
            }
          }

          // replace association by fk field
          if (aNameWithoutQualifier == "@UI.SelectionFields") {
            for (let ae of a) {
              if ("=" in ae) {
                replaceManagedAssocByFK(ae);
              }
            }
          }
        }
      }
    }
  }


}

module.exports = {
  preprocessAnnotations,
};
