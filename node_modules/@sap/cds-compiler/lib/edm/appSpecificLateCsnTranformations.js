'use strict';

const glue = require('./glue.js')

/*
 *  In lack of a better name (transformModel.js is already used)
 *  this file (should) contain all application specific model transformations
 *  that should NOT become persistent in the published CSN model but only
 *  be presented in the resulting EDM files. These late tweaks or mods can
 *  be dependent to EDM version.
 * 
 *  At present there are two transformation targets: Structure and Element
 *  
 *  These transformations are available today:
 *
 *  Analytical Scenario:
 *    If a structure is annotated with @Aggregation.ApplySupported.PropertyRestrictions
 *    then a number of annotation rewrites are done to this structure and to the
 *    elements of this structure
 *    Also the key properties of all structure elements are removed and a new
 *    artificial key element 'key _ID : String' is inserted at first position of
 *    the elements dictionary
 * 
 * PDM (Personal Data Management)
 *    Planned but not yet implemented annotation rewriting (pending to finalization)
 * /
 
/* eslint max-statements-per-line:off */

function mapAnnotationAssignment(artifact, parent, mappingDictionary)
{
  let props = glue.intersect(Object.keys(mappingDictionary), Object.keys(artifact));
  // now start the substituation
  props.forEach(prop => {
    let [ mapping, value, remove_original ] = mappingDictionary[prop];
    if(mapping instanceof Function)
    {
      mapping(artifact, parent, prop);
    }
    else
    {
      artifact[mapping] = value || artifact[prop]['='] || artifact[prop];
    }

    if(remove_original)
      delete artifact[prop];
  });
}

function atElement(options, element, struct)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      mapAnnotationAssignment(element, struct, AnalyticalAnnotations());
    }
    mapAnnotationAssignment(element, struct, PDMSemantics());
  }
  
  // nested functions begin
  function PDMSemantics()
  {
    let dict = Object.create(null);
    /*
    dict['@PDM.xxx1'] = [ '@sap.pdm-semantics' ];
    dict['@PDM.xxx2'] = [ '@sap.pdm-propery' ];
    dict['@PDM.xxx3'] = [ '@sap.pdm-display-sq-no' ];
    dict['@PDM.xxx4'] = [ '@sap.pdm-record-identifier' ];
    dict['@PDM.xxx5'] = [ '@sap.pdm-field-group' ];
    dict['@PDM.xxx6'] = [ '@sap.pdm-mask-find-pattern' ];
    dict['@PDM.xxx7'] = [ '@sap.pdm-mask-replacement-pattern' ];
    dict['@PDM.xxx8'] = [ '@sap.deletable' ];
    dict['@PDM.xxx8'] = [ '@sap.updatable' ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    */
    return dict;
  }

  function AnalyticalAnnotations()
  {
    function mapCommonAttributes(element, struct, prop)
    {
      let CommonAttributes = element[prop];
      if(!Array.isArray(CommonAttributes))
        throw 'This is not an array value for @Common.attributes: ' + CommonAttributes;
      let targets = glue.intersect(CommonAttributes, Object.keys(struct.elements));
      targets.forEach(tgt => {
        struct.elements[tgt]['@sap.attribute-for'] = element.name;
      });
    }

    function mapContextDefiningProperties(element, struct, prop)
    {
      let ContextDefiningProperties = element[prop];
      if(!Array.isArray(ContextDefiningProperties))
        throw 'This is not an array value for @Aggregation.ContextDefiningProperties: ' + ContextDefiningProperties;
      if(ContextDefiningProperties.length > 0)
        element['@sap.super-ordinate'] = ContextDefiningProperties[ContextDefiningProperties.length-1];
    }

    let dict = Object.create(null);
    //analytics term definition unknown, lower case
    dict['@Analytics.Measure'] = [ '@sap.aggregation-role', 'measure' ];
    dict['@Analytics.Dimension'] = [ '@sap.aggregation-role', 'dimension' ];
    dict['@Semantics.currencyCode'] = [ '@sap.semantics', 'currency-code', true ];
    dict['@Semantics.unitOfMeasure'] = [ '@sap.semantics', 'unit-of-measure', true ];

    dict['@Measures.ISOCurrency'] = [ '@sap.unit' ];
    dict['@Measures.Unit'] = [ '@sap.unit' ];

    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Common.Text'] = [ '@sap.text' ];
    dict['@Aggregation.ContextDefiningProperties'] = [ mapContextDefiningProperties ];
    dict['@Common.Attributes'] = [ mapCommonAttributes ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    return dict;
  }
}

function atStructure(options, struct)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      transformAnalyticalModel(struct);
      mapAnnotationAssignment(struct, undefined, AnalyticalAnnotations());
    }
    mapAnnotationAssignment(struct, undefined, PDMSemantics());
  }

  // nested functions begin

  // nested functions begin
  function PDMSemantics()
  {
    let dict = Object.create(null);
    /*
    dict['@PDM.xxx1'] = [ '@sap.pdm-semantics' ];
    dict['@PDM.xxx2'] = [ '@sap.pdm-business-object' ];
    dict['@PDM.xxx3'] = [ '@sap.pdm-business-node' ];
    dict['@PDM.xxx8'] = [ '@sap.deletable' ];
    dict['@PDM.xxx8'] = [ '@sap.updatable' ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    */
    return dict;
  }

  function transformAnalyticalModel(struct)
  {
    let keyName = 'ID__';
    if(struct == undefined || struct.elements == undefined || struct.elements[keyName] != undefined)
      return;
      
    // remove key prop from elemens, add new key to elements
    let elements = Object.create(null);
    elements[keyName] = { key : true, type : 'cds.String', indexNo: 1 };
    glue.forAll(struct.elements, (e,n) => 
    { 
      e.indexNo++; 
      if(e.key) delete e.key;
      elements[n] = e;
    });
    struct.elements = elements;
  }

  function AnalyticalAnnotations()
  {
    function mapFilterRestrictions(struct, parent, prop)
    {
      let stringDict = Object.create(null);
      stringDict['SingleValue'] = 'single-value';
      stringDict['MultiValue'] = 'multi-value';
      stringDict['SingleRange'] = 'interval';

      let filterRestrictions = struct[prop];
      if(!Array.isArray(filterRestrictions))
        throw 'This is not an array value for @Capabilities.FilterRestrictions.FilterExpressionRestrictions: ' + filterRestrictions;
      filterRestrictions.forEach(v => {
        let e = struct.elements[v.Property];
        if(e) 
          e['@sap.filter-restriction'] = stringDict[v.AllowedExpressions];
      });
    }

    function mapRequiredProperties(struct, parent, prop)
    {
      let requiredProperties = struct[prop];
      if(!Array.isArray(requiredProperties))
        throw 'This is not an array value for @Capabilities.FilterRestrictions.RequiredProperties: ' + requiredProperties;
      let props = glue.intersect(Object.keys(struct.elements), requiredProperties)
      props.forEach(p => {
        struct.elements[p]['@sap.required-in-filter'] = true;
      });
    }

    function mapRequiresFilter(struct, parent, prop)
    {
      let requiresFilter = struct[prop];
      if(requiresFilter)
        struct._EntitySetAttributes['@sap.requires-filter'] = requiresFilter;
    }

      // Entity Props
    let dict = Object.create(null);
    dict['@Aggregation.ApplySupported.PropertyRestrictions'] = [ '@sap.semantics', 'aggregate' ];
    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Capabilities.FilterRestrictions.RequiresFilter'] = [ mapRequiresFilter ];
    dict['@Capabilities.FilterRestrictions.RequiredProperties'] = [ mapRequiredProperties ];
    dict['@Capabilities.FilterRestrictions.FilterExpressionRestrictions'] = [ mapFilterRestrictions ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);

    return dict;
  }
}

module.exports = {
  atElement,
  atStructure
}
