'use strict';
/* eslint max-statements-per-line:off */
const { setProp } = require('../base/model');

function validateOptions(_options)
{
  if(!_options.isV2 && !_options.isV4)
  {
    // csn2edm expects "version" to be a top-level property of options
    // set to 'v4' as default, override with value from incoming options
    // (here version comes inside "toOdata")
    const options = Object.assign({ version: 'v4'}, _options);
    if (options.toOdata && options.toOdata.version)
      options.version = options.toOdata.version;

    const v2 = options.version.match(/v2/i) != undefined;
    const v4 = options.version.match(/v4/i) != undefined;

    options.v = [v2, v4];

    if(options.v.filter(v=>v).length != 1)
      throw Error(`Please debug me: EDM V2:${v2}, V4:${v4}`);

    options.isV2 = function() { return this.v[0] == true; }
    options.isV4 = function() { return this.v[1] == true; }
    return options;
  }
  else
    return _options;
}

// returns intersection of two arrays
function intersect(a,b)
{
  return [...new Set(a)].filter(x => new Set(b).has(x));
}

// Call func(art, name) for each artifact 'art' with name 'name' in 'dictionary' that returns true for 'filter(art)'
function foreach(dictionary, filter, func) {
  if (dictionary != undefined) {
    for (let name in dictionary) {
      if (dictionary[name] && filter(dictionary[name])) {
        func(dictionary[name], name);
      }
    }
  }
}

// Call func(art, name) for each artifact 'art' with name 'name' in 'dictionary'
function forAll(dictionary, func) {
  foreach(dictionary, ()=>true, func);
}

// true if _containerEntity is unequal to artifact name (non-recursive containment association)
//      or if artifact belongs to an artificial parameter entity
function isContainee(artifact) {
  // if _containerEntity is present, it is guarranteed that it has at least one entry
  return (artifact._containerEntity && (artifact._containerEntity.length > 1 || artifact._containerEntity[0] != artifact.name));
}

// Return true if 'artifact' has an association type
function isAssociation(artifact) {
  return (artifact.type == "cds.Association" || artifact.type == "Association") &&  artifact.target != undefined;
  //return artifact.target != undefined;
}

function isComposition(artifact) {
  return (artifact.type == "cds.Composition" || artifact.type == "Composition") &&
    artifact.target != undefined;
}

function isAssociationOrComposition(artifact)
{
  return isAssociation(artifact) || isComposition(artifact);
}

function isManagedAssociation(artifact)
{
  return isAssociation(artifact) && artifact.onCond == undefined && artifact.on == undefined;
}

// Return true if the association 'assoc' has cardinality 'to-many' 
function isToMany(assoc) {
  if (!assoc.cardinality) {
    return false;
  }
  // Different representations possible: array or targetMax property
  let targetMax = assoc.cardinality[1] ||assoc.cardinality.max;
  if (!targetMax) {
    return false;
  }
  return targetMax == '*' || Number(targetMax) > 1;
}

function isEntityOrView(artifact)
{
  return artifact.kind == 'entity' || artifact.kind == 'view';
}

function isParameterizedEntityOrView(artifact) {
  return isEntityOrView(artifact) && artifact.params;
}

// Return true if 'artifact' is a real structured type (not an entity)
function isStructuredType(artifact) {
  return isStructuredArtifact(artifact) && !isEntityOrView(artifact);
}

// Return true if 'artifact' is structured (i.e. has elements, like a structured type or an entity)
function isStructuredArtifact(artifact) {
  // FIXME: No derived types etc yet
  return (artifact.items && artifact.items.elements || artifact.elements);
}

function isDerivedType(artifact)
{
  return artifact.kind == 'type' && !isStructuredType(artifact);
}

function isActionOrFunction(artifact)
{
  return artifact.kind == 'action' || artifact.kind == 'function';
}

// Initialize 'model' in place for odata-preprocessing. Return a service from 'model' or undefined if there is none.
// FIXME: Should move to some more ODATA-specific location 
function initializeModel(model, options) 
{
  if(options == undefined)
    throw Error('Please debug me: initializeModel must be invoked with options');
  
  // make sure options are complete
  options = validateOptions(options);

    // First attach names to all definitions in the model
  forAll(model.definitions, (a, n) => {
    a.name = n;
  });

  foreach(model.definitions, isActionOrFunction, a => {
    forAll(a.params, (p,n) => {
      p.name = n;
    })
  });

  let service;
  // Fetch service object
  foreach(model.definitions, a => a.kind == 'service', a => { 
    service = a; });

  // Initialize entities with parameters (add Parameter entity)
  foreach(model.definitions, isParameterizedEntityOrView, initializeParameterizedEntityOrView);
  // Initialize structures
  foreach(model.definitions, isStructuredArtifact, initializeStructure);
  // Initialize associations
  foreach(model.definitions, isStructuredArtifact, initializeAssociation);
  return service;

  function initializeParameterizedEntityOrView(entityCsn, entityName) {
    const deepCopy = require('../base/deepCopy.js');

    // Naming rules for aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Results" pointing to the entity set of type <ViewName>Result
    // Result:     EntityType <ViewName>Result, EntitySet <ViewName>Results

    // Naming rules for non aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Set" pointing to the entity set of type <ViewName>Type
    // Result:     EntityType <ViewName>Type, EntitySet <ViewName>Set
    //             Backlink Navigation Property "Parameters" to <ViewName>Parameters

    // this code can be extended for aggregated views
    let parameterEntityName = entityName + 'Parameters';
    let parameterEntitySetName = entityName;
    let originalEntityName = entityName + 'Type';
    let originalEntitySetName = entityName + 'Set';
    let parameterToOriginalAssocName = 'Set';
    let backlinkAssocName = 'Parameters';
    let hasBacklink = true;

    // Construct the parameter entity
    let parameterCsn = { name: parameterEntityName, setName: parameterEntitySetName, kind: 'entity', isParamEntity:true, elements: Object.create(null) };

    // propagate containment information, if containment is recursive, use parameterCsn.name as _containerEntity
    if(entityCsn._containerEntity) {
      parameterCsn._containerEntity = [];
      for(let c of entityCsn._containerEntity) {
        parameterCsn._containerEntity.push((c==entityCsn.name)?parameterCsn.name:c);
      }
    }
    entityCsn._containerEntity = [ parameterCsn ];

    forAll(entityCsn.params, (p,n) => {
      let elt = deepCopy(p);
      elt.name = n;
      delete elt.kind;
      elt.key = true; // params become primary key in parameter entity
      parameterCsn.elements[n] = elt;
    });

    // add assoc to result set, FIXME: is the cardinality correct?
    parameterCsn.elements[parameterToOriginalAssocName] = {
      '@odata.contained': true,
      name: parameterToOriginalAssocName,
      target: entityCsn,
      type: 'cds.Association',
      cardinality: { src: 1, min: 0, max: '*' }
    };
    model.definitions[parameterCsn.name] = parameterCsn;


    // modify the original parameter entity with backlink and new name
    entityCsn.name = originalEntityName;
    entityCsn.setName = originalEntitySetName;

    // add backlink association
    if(hasBacklink) {
      entityCsn.elements[backlinkAssocName] = {
        name: backlinkAssocName,
        target: parameterCsn,
        type: 'cds.Association',
        on: [ { ref: [ 'Parameters', 'Set' ] }, '=', { ref: [ '$self' ] } ]
      };
    }
  }
  // Initialize structured artifact (type or entity) 'struct' by doing the
  // following:
  // - attach attributes 'name', 'Name' to elements (FIXME: We currently really require both 'Name' and 'name'!)
  // - create a property 'keys' with all its primary key elements
  // - optionally add the magic ValueList association
  // - call 'initializeAssociation' for each element that has an association type
  // - attach attribute 'name' to all actions and their parameters.  
  function initializeStructure(struct) {

    const appSpecificLateCsnTranformations = require('./appSpecificLateCsnTranformations');

    let keys = Object.create(null);
    // Iterate all struct elements
    forAll(struct.elements, (element, elementName) => {
      // Attach name and Name (Name is used in function ForeignKey4(assoc))
      element.name = element.Name = elementName;
      setProp(element, '_parent', struct);

      // Collect keys
      if (element.key) {
        keys[elementName] = element;
      }

      if(options.tntFlavor && !options.tntFlavor.skipValueListMagic)
        addValueListAssociation(element, struct);

      appSpecificLateCsnTranformations.atElement(options, element, struct);
    });

    setProp(struct, '_EntitySetAttributes', Object.create(null));

    appSpecificLateCsnTranformations.atStructure(options, struct);

    struct['key'] = keys;
    initializeActions(struct.actions);

  }

  function initializeActions(actions)
  {
    // Attach name to actions and their parameters
    forAll(actions, (a, n) => {
      a.name = n;
      forAll(a.params, (a, n) => {
        a.name = n;
        if(options.tntFlavor && !options.tntFlavor.skipValueListMagic)
        {
          let valueListType = a['@Common.ValueList.type'];
          if(valueListType && valueListType['#'] || valueListType === 'fixed')
            a['@sap:value.list'] = 'fixed-values';
        }
      });
    });
  }

  // Resolve the association type of 'element' in 'struct' by doing the following:
  // - collect the foreign key elements for the target into attribute 'elements'
  // - replace the String attribute 'target' by the actual target artifact
  function initializeAssociation(struct)
  {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if(typeof element.target === "string") {
        element.target = model.definitions[element.target];

        // if the target is a containee AND target has parameters, redirect
        // target to <Type>Parameters entity (see initializeParameterizedEntityOrView() above)
        // Preserve the original target for backlinks (see edm.js NavigationProperty.getReferentialConstraints()
        // for details
        if(element.target._containerEntity && element.target.params) {
          element.originalTarget = element.target;
          element.target = element.target._containerEntity[0];
        }
      }

      //forward annotations from managed association element to its foreign keys
      if(element.keys) {
        for(let fk of element.keys) {
          forAll(element, (attr, attrName) => {
            if(attrName[0] == '@')
              struct.elements[fk.$generatedFieldName][attrName] = attr;
          });
        }
      }
    });
  }

  /*
  If an element is annotated with @Common.ValueList.entity, an additional
  unmanaged association is added to the entity type named 'to_' + element.name.
  The value of @Common.ValueList.entity is the association target.
  */
  function addValueListAssociation(element, struct)
  {
    let valueListType = element['@Common.ValueList.type'];
    if(valueListType)
    {
      let valueListEntityName = element['@Common.ValueList.entity'] || element.name;
      let valueListEntity = model.definitions[service.name + '.' + valueListEntityName];

      // TODO: throw error if not found?
      if(valueListEntity)
      {
        if((valueListType['#'] || valueListType) === 'fixed')
          element['@sap.value-list'] = "fixed-values";

        let assocName = 'to_' + element.name;

        let pkn;
        // last key wins, must be only one key, error?
        foreach(valueListEntity.elements, e => e.key,
          (key, keyName) => { pkn = keyName; });

        // add the value list association as new element into struct.elements
        let assoc = {
          name: assocName,
          target: valueListEntity,
          type: 'cds.Association',
          on: [ { ref: [ element.name ] },"=", { ref: [ assocName, pkn ] } ]
        }
        setProp(assoc, '_parent', struct);
        struct.elements[assocName] = assoc;
      }
    }
  }
}

function mapCdsToEdmType(cdsType, isV2=false, isMediaType=false)
{
  let edmType = {
    'cds.String': 'Edm.String',
    'cds.LargeString': 'Edm.String',
    'cds.Boolean': 'Edm.Boolean',
    'cds.Integer': 'Edm.Int32',
    'cds.Integer16': 'Edm.Int16',
    'cds.Integer32': 'Edm.Int32',
    'cds.Integer64': 'Edm.Int64',
    'cds.Float': 'Edm.Single',
    'cds.Double': 'Edm.Double',
    'cds.Decimal': 'Edm.Decimal',
    'cds.DecimalFloat': 'Edm.Decimal',
    'cds.Date': 'Edm.Date',
    'cds.Time': 'Edm.TimeOfDay',
    'cds.DateTime':  (isV2 && false) ? 'Edm.DateTime': 'Edm.DateTimeOffset', // eslint-disable-line no-constant-condition
    'cds.Timestamp': (isV2 && false) ? 'Edm.DateTime' : 'Edm.DateTimeOffset', // eslint-disable-line no-constant-condition
    'cds.UTCTimestamp': 'Edm.DateTimeOffset',
    'cds.Binary': 'Edm.Binary',
    'cds.LargeBinary': 'Edm.Binary',
    'cds.UUID': 'Edm.Guid',
    /* unused but EDM defined
    Edm.Geography
    Edm.GeographyPoint
    Edm.GeographyLineString
    Edm.GeographyPolygon
    Edm.GeographyMultiPoint
    Edm.GeographyMultiLineString
    Edm.GeographyMultiPolygon
    Edm.GeographyCollection
    Edm.Geometry
    Edm.GeometryPoint
    Edm.GeometryLineString
    Edm.GeometryPolygon
    Edm.GeometryMultiPoint
    Edm.GeometryMultiLineString
    Edm.GeometryMultiPolygon
    Edm.GeometryCollection
    */
  }[cdsType];
  if (edmType == undefined)
    throw Error('No edm type found for ' + cdsType);
  if(isV2)
  {
    if (edmType == 'Edm.Date') 
      edmType = 'Edm.DateTime';
    if (edmType == 'Edm.TimeOfDay')
      edmType = 'Edm.Time';
  }
  else // isV4
  {
    // CDXCORE-CDXCORE-173
    if(isMediaType)
      edmType = 'Edm.Stream';
  }
  return edmType;
}

function addTypeFacets(node, csn)
{
  if (csn.length)
    node.MaxLength = csn.length;
  if (csn.scale)
    node.Scale = csn.scale;
  if (csn.precision)
    node.Precision = csn.precision;
  // Unicode/SRID unused today
  if(csn.unicode)
    node.Unicode = csn.unicode;
  if(csn.srid)
    node.SRID = csn.srid;
}

module.exports = {
  validateOptions,
  intersect,
  foreach,
  forAll,
  isContainee,
  isAssociation,
  isManagedAssociation,
  isComposition,
  isAssociationOrComposition,
  isToMany,
  isEntityOrView,
  isStructuredType,
  isStructuredArtifact,
  isDerivedType,
  isActionOrFunction,
  initializeModel,
  mapCdsToEdmType,
  addTypeFacets
}
