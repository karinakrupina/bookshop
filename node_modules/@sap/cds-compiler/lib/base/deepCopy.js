// Deep copy an object structure
// This makes a deep copy of the transitive closure of an object. It works on any objects and properties,
// enumerable or not. Be careful with functions that contain state, since there will be no clone of the
// internal state of a function.
// An example is the alert property of a model. It may be instantiated with an array of alert messages
// kept in the model itself, so after cloning the model you will have two alert message arrays, but alert still
// points to the alert messages in the original model. You have to reinstantiate alert in the clone to refer
// to the cloned messages.
// In order not to forget such functions that would still alter the original model it's advised to freeze the
// original model (see deepFreeze)

function deepCopy(obj) {
  let map = new WeakMap();
  return clone(obj);

  function clone(obj) {
    let newObj;
    if (typeof obj !== 'object' || obj === null) // return primitive type, note that typeof null === 'object'
      return obj;
    if (map.has(obj))
      return map.get(obj);
    if (Array.isArray(obj))
      newObj = [];
    else if (obj.constructor) // important for classes, else prototype chain for inheritance will not be correct
      newObj = new obj.constructor()
    else if (!Object.getPrototypeOf(obj))
      newObj = Object.create(null);  // dictionary
    else
      newObj = {};
    map.set(obj, newObj);
    let props =  Object.getOwnPropertyNames(obj);  // we clone only own properties, not inherited one's
    for (let p of props) {
      let pd = Object.getOwnPropertyDescriptor(obj, p);
      if (pd && pd.enumerable === false && pd.get === undefined && pd.set === undefined ) {
        pd.value = clone(obj[p]);
        Object.defineProperty(newObj, p, pd);
      }
      else
        newObj[p] = clone(obj[p]);
    }
    return newObj;
  }
}

module.exports = deepCopy;