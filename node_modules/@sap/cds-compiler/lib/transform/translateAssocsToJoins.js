'use strict'

var { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { setProp, forEachGeneric, forEachDefinition } = require('../base/model');
const modelUtils = require('../model/modelUtils.js');
const compactor = require('../json/compactor');
var { linkToOrigin } = require('../compiler/shared');
const alerts = require('../base/alerts');

function translateAssocsToJoins(model)
{
  // Paths that start with an artifact of protected kind are special
  // either ignore them in QAT building or in path rewriting
  const internalArtifactKinds = ['builtin'/*, '$parameters'*/, 'param'];

  const { error, signal } = alerts(model);

  var options = model.options || {};

  const fullJoinOption = options.forHana && options.forHana.associations == 'joins';

  // Note: This is called from the 'forHana' transformations, so it is controlled by its options)
  const pathDelimiter = (options.forHana && options.forHana.names == 'hdbcds') ? '.' : '_';
    
  const { compactNode } = compactor.getCompactors(options);

  forEachDefinition(model, prepareAssociations);
  forEachDefinition(model, transformQueries);

    // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError( sortMessages(model.messages), model)
  }
  return model;

  function prepareAssociations(art)
  {
    if(art.kind === 'element' && art.target)
    {
      /* Create the prefix string up to the main artifact which is
         prepended to all source side paths of the resulting ON condition
         (cut off name.id from name.element)
      */
      art.$elementPrefix = art.name.element.slice(0, art.name.element.length - art.name.id.length).replace(/\./g, pathDelimiter);

      /*
        Create path prefix tree for Foreign Keys, required to substitute
        aliases in ON cond calculation, also very useful to detect fk overlaps.
      */
      if(art.foreignKeys && !art.$fkPathPrefixTree)
      {
        art.$fkPathPrefixTree = { children: Object.create(null) };
        forEachGeneric(art, 'foreignKeys', fk => {
          let ppt = art.$fkPathPrefixTree;
          fk.targetElement.path.forEach(ps => {
            if(!ppt.children[ps.id])
              ppt = ppt.children[ps.id] = { children: Object.create(null) };
            else
              ppt = ppt.children[ps.id];
          });
          ppt._fk = fk;
        });
      }
      else
      {
        let env = {
          tableAliases: [ art.name.id ],
          art,
          location: 'onCondAssoc',
          callback: [ flyTrap ]
        };
        walk(art.onCond || art.on, env);
      }
    }
    // drill into structures
    forEachGeneric(art, 'elements', prepareAssociations);
  }

  function transformQueries(art)
  {
    let queries = art.$queries;
    let fullJoins = fullJoinOption;

    if(queries && queries.length > 0)
    {
      /*
      HANA cannot process associations with parameters, filters in FROM paths and mixin-assoc usages
      Filters and mixin usages will lead to a minimum join translation (only FROM clause and MIXIN usages)
      A full join conversion is required if an assoc path step has parameters or if parameter path step is
      not at leaf position (entity/view with parameters followed by another association in FROM clause), or
      if a filter has a cardinality ':1'.
      */
      if(!fullJoinOption) {
        let env = {
          minimum : false,
          full: false,
          walkover : { from:true, onCondFrom: false, select: true, filter: false },
          callback :
            (pathDict, env) => {
              env.minimum = env.minimum ||
                (env.location == 'from' ? pathDict.path.some(p => p.where) //!!pathDict.path.filter(p => isEntityOrView(p._artifact))[0].where
                                         : (pathDict.path[0]._navigation && pathDict.path[0]._navigation.kind == 'element' && pathDict.path.length > 1));

              env.full = env.full || pathDict.path.some((e, i, a) => {
                return !!e.namedArgs && (e._artifact.target || i < a.length-1) || e.cardinality })
            }
        }
        queries.forEach(q => walkQuery(q, env));

        if(!env.minimum && !env.full)
          return;
        fullJoins = env.full;
      }
      /*
        Setup QATs and leaf QAs (mixins, query, subqueries in from clause)
        1a) Mark all mixin assoc definitions with a pseudo QA that points to the assoc target.
        1b) For all paths in a query do flytrap checks and create the path prefix trees aka QATs.
            Paths that start with a mixin assoc are Qat'ed into the mixin definition.
            If a mixin assoc is published, its leaf Qat receives the pseudo QA(view) from the rootQat,
            which is the mixin definition itself. See 1a)
        1c) Create QAs for FROM clause subqueries, as they are not yet swept by the path walk
      */
      let env = {
        fullJoins,
        aliasCount: 0,
        walkover: { from: true, onCondFrom:true, select:true, filter: true },
        callback: [ flyTrap, mergePathIntoQAT ]
      };
      queries.forEach(q => createQAForMixinAssoc(q, env));
      queries.forEach(q => walkQuery(q, env));
      queries.forEach(q => createQAForFromClauseSubQuery(q, env));

      // 2) Walk over each from table path, transform it into a join tree
      env.walkover = { from:true, onCondFrom:false, select: false, filter: false };
      env.callback = createInnerJoins;
      queries.forEach(q => walkQuery(q, env));

      // 3) Transform toplevel FROM block into cross join
      queries.forEach(q => createCrossJoins(q));

      // 4) Transform all remaining join relevant paths into left outer joins and connect with
      //    FROM block join tree. Instead of walking paths it is sufficient to process the $qat
      //    of each $tableAlias.
      queries.forEach(q => createLeftOuterJoins(q, env));

      // 5) Rewrite ON condition paths that are part of the original FROM block
      //    (same rewrite as (injected) assoc ON cond paths but with different table alias).
      // 6) Prepend table alias to all remaining paths
      env.walkover = { from:false, onCondFrom:true, select: true, filter: false };
      env.callback = rewriteGenericPaths;
      queries.forEach(q => walkQuery(q, env));

      // 7) Attach firstFilterConds to Where Condition.
      queries.forEach(q => attachFirstFilterConditions(q));

      // TODO: support parameters
    }
  }

  
  function createCrossJoins(query)
  {
    // If the toplevel FROM block is a comma separated list and has more then one entry,
    // cross join list items and replace from array
    if(query.op.val === 'query')
    {
      if(Array.isArray(query.from) && query.from.length > 1)
        query.from.splice(0, query.from.length, { op: { val: 'join' }, join: 'cross', args: [...query.from ] });
    }
  }

  // Transform each FROM table path into a join tree and attach the tree to the path object
  function createInnerJoins(fromPathNode, env)
  {
    let fqat = env.lead.$tableAliases[fromPathNode.name.id].$fqat;
    let joinTree = createJoinTree(env, undefined, fqat, 'inner', '$fqat', undefined);

    replaceNodeContent(fromPathNode, joinTree);
  }

  // Translate all other join relevant query paths into left outer join tree and attach it to the lead query
  function createLeftOuterJoins(query, env)
  { 
    if(query.op.val === 'query')
    {
      env.lead = query;
      let joinTree = Array.isArray(query.from) ? query.from[0] : query.from;
      for(let tan in query.$tableAliases)
      {
        if(tan !== '$projection') // don't drive into $projection tableAlias (yet)
        {
          let ta = query.$tableAliases[tan];
          joinTree = createJoinTree(env, joinTree, ta.$qat, 'leftOuter', '$qat', ta.$QA);
        }
      }
      query.from = [ joinTree ];
    }
  }

  /*
    Each leaf node of a table path must end in either a direct or a target artifact.
    During mergePathIntoQat() this 'leaf' artifact is marked as a QA at the corresponding
    'leaf' QAT and to the respective $tableAlias which is used to link paths to the correct
    table alias. Subqueries are not considered in the mergePathIntoQat(), so a subquery QA
    must be created and added separately to the lead query $tableAlias'es.
    Also the name of the subquery (the alias) needs to be set to the final QA alias name.
  */
  function createQAForFromClauseSubQuery(query, env)
  {
    for (let taName in query.$tableAliases) {
      if (!['$self', '$projection'].includes(taName)) {
        let ta = query.$tableAliases[taName];
        if(!ta.$QA) {
          ta.$QA = createQA(env, ta._finalType, undefined, taName);
          incAliasCount(env, ta.$QA);
          if(ta.name && ta.name.id) {
            ta.name.id = ta.$QA.name.id;
          }
        }
      }
    }
    // Only subqueries of the FROM clause have a name (which is the alias)
    if(query.op.val === 'query' && query.name.id && query._tableAlias)
    {
      query.name.id = query._tableAlias._parent.$tableAliases[query.name.id].$QA.name.id;
    }
  }

  /*
    Add an artificial QA for each mixin definition. This QA completes the QAT
    datastructure that requires a QA at the rootQat before starting the join generation.
    This QA is marked as 'mixin' which indicates that the paths of the ON condition must
    not receive the usual source and target table alias (which is used for generic associations)
    but instead just use the rootQA of the individual ON condition paths. These paths are
    resolved against the FROM clause and must of course be connected to the respective table
    aliases.
  */
  function createQAForMixinAssoc(query, env)
  {
    if(query.op.val === 'query')
    {
      env.lead = query;
      // use view as QA origin
      forEachGeneric(query, 'mixin', art => {
        if(!art.$QA)
        {
          art.$QA = createQA(env, art.target._artifact);
          art.$QA.mixin = true;
        }
      });
    }
  }

  /*
    Prefix all paths with table alias (or replace existing alias)

    Rewrite a given path of the native ON condition to TableAlias.ColumnName
    and substitute all eventually occurring foreign key path segments against
    the respective FK aliases.
    No flattening of structured leaf types necessary, this is done in renderer
  */
  function rewriteGenericPaths(pathNode, env)
  {
    if(pathNode.$rewritten)
      return;

    let path;
    if(env.location === 'onCondFrom')
    {
      let [ tableAlias, tail ] = constructTableAliasAndTailPath(pathNode.path);
      let pathStr = translateONCondPath(tail).map(ps => ps.id).join(pathDelimiter);
      path = [ tableAlias, { id: pathStr, _artifact: pathNode._artifact } ];
    }
    else 
    {
      // Paths without _navigation in ORDER BY are select item aliases, they must
      // be rendered verbatim
      if(env.location === 'OrderBy' && !pathNode.path[0]._navigation)
        return;

      // path outside ON cond, follow QAT path backwards until QA is found
      let pl = pathNode.path.length-1;
      let ps = pathNode.path[pl--];
      let QA = ps._navigation._parent.$QA;
      while(!QA && pl >= 0)
      {
        ps = pathNode.path[pl--];
        QA = ps._navigation._parent.$QA;
      }

      if(QA)
        path = [ { id: QA.name.id, _artifact: QA._artifact },  ...pathNode.path.slice(pathNode.path.indexOf(ps)) ];
      else
        throw Error('No QA found for path ' + pathAsStr(pathNode.path, '"'));
    }
    replaceNodeContent(pathNode, constructPathNode(path));
  }

  /*
    AND filter conditions of the first path steps of the FROM clause to the WHERE condition.
    If WHERE does not exist, create a new one. This step must be done after rewriteGenericPaths()
    as the filter expressions would be traversed twice.
  */
  function attachFirstFilterConditions(query)
  {
    if(query.op.val === 'query')
    {
      if(query.$startFilters)
      {
        if(query.where)
        {
          if(query.where.op.val == 'and')
            query.where.args.push(...query.$startFilters.map(f => [ f ]));
          else
            query.where = { op: {val: 'and' }, args: [ [ query.where ],  ...query.$startFilters.map(f => [ f ]) ] };
        }
        else
          query.where = query.$startFilters.length > 1
            ? { op: {val: 'and' }, args: query.$startFilters.map(f => [ f ]) }
            : query.$startFilters;
      }
    }
  }

  /*
    Transform a QATree into a JOIN tree
    Starting from a root (parentQat) follow all QAT children and in
    case QAT.origin is an association, create a new JOIN node using
    the existing joinTree as LHS and the QAT.QA as RHS.
  */
  function createJoinTree(env, joinTree, parentQat, joinType, qatAttribName, lastAssocQA)
  {
    for(let childQatId in parentQat)
    {
      let childQat = parentQat[childQatId];
      let newAssocLHS = lastAssocQA;
      let art = childQat.origin._artifact;

      if(isEntityOrView(art))
      {
        if(!childQat.$QA)
          childQat.$QA = createQA(env, art, childQat._namedArgs);
        incAliasCount(env, childQat.$QA);
        newAssocLHS = childQat.$QA;

        if(joinTree === undefined) // This is the first artifact in the JOIN tree
        {
          joinTree = childQat.$QA;
          // Collect the toplevel filters and add them to the where condition
          if(childQat._filter)
          {
            // Filter conditions are unique for each JOIN, they don't need to be copied
            let filter = childQat._filter;
            rewritePathsInExpression(filter, function(pathNode) {
              return [ /* tableAlias=> */ { id: childQat.$QA.name.id, _artifact: childQat.$QA._artifact },
                       /* filterPath=> */ pathNode.path ]; // eslint-disable-line indent-legacy
            });

            if(!env.lead.$startFilters)
              env.lead.$startFilters = [];
            env.lead.$startFilters.push( filter ); // [ filter ] parenthesizes each filter
          }
        }
      }
      else // it's not an artifact, so it should be an assoc step
      {
        if(art.target)
        {
          if(joinTree === undefined)
            throw Error('Cannot follow Associations without starting Entity');

          //if(!(mixinJoins && env.location !== 'from')  && !childQat.QA)
          if((env.fullJoins || env.location === 'from')  && !childQat.$QA)
            childQat.$QA = createQA(env, art.target._artifact, childQat._namedArgs);

          // Do not create a JOIN for that assoc if it has no subsequent path steps
          // and only if (mixin) QA is available (except for the last path step in the from table path)
          if(childQat.$QA && (env.location == 'from' || getChildrenCount(childQat) > 0))
          {
            incAliasCount(env, childQat.$QA);
            joinTree = createJoinQA(joinType, joinTree, childQat.$QA, childQat, lastAssocQA);
            newAssocLHS = childQat.$QA;
          }
        }
      }
      // Follow the children of this QAT to append more JOIN nodes
      joinTree = createJoinTree(env, joinTree, childQat[qatAttribName], joinType, qatAttribName, newAssocLHS);
    }
    return joinTree;

    // Return the number of direct children to the given qat accross all filters
    function getChildrenCount(qat)
    {
      let count = 0;
      for(let fid in qat[qatAttribName])
      {
        count += Object.keys(qat[qatAttribName][fid]).length;
      }
      return count;
    }
  }

  function createJoinQA(joinType, lhs, rhs, assocQAT, assocSourceQA)
  {
    let node = { op: { val: 'join' }, join: joinType, args: [lhs, rhs] };

    // 'path steps' for the src/tgt table alias
    let srcTableAlias = { id: assocSourceQA.name.id, _artifact: assocSourceQA._artifact };
    let tgtTableAlias = { id: assocQAT.$QA.name.id,  _artifact: assocQAT.$QA._artifact };

    node.on = createOnCondition(assocQAT.origin._artifact, srcTableAlias, tgtTableAlias);

    if(assocQAT._filter)
    {
      // Filter conditions are unique for each JOIN, they don't need to be copied
      let filter = assocQAT._filter;
      rewritePathsInExpression(filter, function(pathNode) {
        return [ tgtTableAlias, pathNode.path ];
      });

      // If toplevel ON cond op is AND add filter condition to the args array,
      // create a new toplevel AND op otherwise
      let onCond = (Array.isArray(node.on) ? node.on[0] : node.on);

      if(onCond.op.val == 'and')
        // parenthesize filter
        onCond.args.push( [ filter ] );
      else
        // parenthesize onCond and filter
        node.on = [ { op: { val: 'and' }, args: [ [ onCond ], [ filter ] ] } ];
    }
    return node;

    // produce the ON condition for a given association
    function createOnCondition(assoc, srcAlias, tgtAlias)
    {
      let prefixes = [ assoc.name.id ];
      /* This is no art and can be removed once ON cond for published
          and renamed backlink assocs are publicly available. Example:

        entity E { ...; toE: association to E; toEb: association to E on $self = toEb.toE; };
        entity EP as projection on E { *, toEb as foo };
        This requires ON cond rewritten to: $self = foo.toE but instead its still $self = toEb.toE,
        so prefix 'foo' won't match....
      */
      if(assoc.origin && assoc.origin._artifact && !prefixes.includes(assoc.origin._artifact.name.id))
        prefixes.push(assoc.origin._artifact.name.id);

      // produce the ON condition of the managed association
      if(assoc.foreignKeys)
      {
        /*
          Get both the source and the target column names for the EQ term.
          For the src side provide a path prefix for all paths that is the assocElement name itself preceded by
          the path up to the first lead artifact (usually the entity or view) (or in QAT speak: follow the parent
          QATs until a QA has been found).
        */
        let srcPaths = flattenElement(assoc, true, assoc.name.element.replace(/\./g, pathDelimiter));
        let tgtPaths = flattenElement(assoc, false);

        if(srcPaths.length != tgtPaths.length)
          throw Error('srcPaths length ['+srcPaths.length+'] != tgtPaths length ['+tgtPaths.length+']');

        /*
          Put all src/tgt path siblings into the EQ term and create the proper path objects
          with the src/tgt table alias path steps in front.
        */
        let args = [];
        for(let i = 0; i < srcPaths.length; i++)
        {
          args.push({op: {val: '=' },
            args: [ constructPathNode( [ srcAlias, srcPaths[i] ] ),
                    constructPathNode( [ tgtAlias, tgtPaths[i] ] ) ] });   // eslint-disable-line indent-legacy
        }
        // Parenthesize each AND term
        return [ (args.length > 1 ? { op: { val: 'and' }, args: [ ...args.map(a=>[a]) ] } : args[0] ) ];
      }
      else
        return cloneOnCondition(assoc.onCond || assoc.on);

      // clone ON condition with rewritten paths and substituted backlink conditions
      function cloneOnCondition(expr)
      {
        if(expr.op && expr.op.val === 'xpr')
          return cloneOnCondExprStream(expr);
        else
          return cloneOnCondExprTree(expr);
      }

      function cloneOnCondExprStream(expr) {
        let args = expr.args;
        let result = { op: { val: expr.op.val }, args: [] };
        for(let i = 0; i < args.length; i++)
        {
          if(args[i].op && args[i].op.val === 'xpr')
          {
            result.args.push(cloneOnCondition(args[i]));
          }
          // If this is a backlink condition, produce the
          // ON cond of the forward assoc with swapped src/tgt aliases
          else if(i < args.length-2 && args[i].path && args[i+1] == '=' && args[i+2].path)
          {
            let fwdAssoc = getForwardAssociation(args[i].path, args[i+2].path);
            if(fwdAssoc)
            {
              result.args.push(createOnCondition(fwdAssoc, tgtAlias, srcAlias));
              i += 2; // skip next two tokens and continue with loop
              continue;
            }
          }
          result.args.push(rewritePathNode(args[i]));
        }
        return result;
      }

      function cloneOnCondExprTree(expr) {
        // keep parentheses intact
        if(Array.isArray(expr))
          return expr.map(cloneOnCondition);

        // If this is a backlink condition, produce the 
        // ON cond of the forward assoc with swapped src/tgt aliases
        let fwdAssoc = getForwardAssociationExpr(expr);
        if(fwdAssoc)
          return createOnCondition(fwdAssoc, tgtAlias, srcAlias);

        // If this is an ordinary expression, clone it and mangle its arguments
        // this will substitute multiple backlink conditions ($self = ... AND $self = ...AND ...)
        if(expr.op)
          return { op: { val: expr.op.val }, args: expr.args.map(cloneOnCondition) };

        // If this is a regular path, rewrite it
        return rewritePathNode(expr);
      }

      function rewritePathNode(pathNode)
      {
        let tableAlias;
        let path = pathNode.path;

        if(!path) // it's not a path return it
          return pathNode;

        let [head, ...tail] = path;

        if(internalArtifactKinds.includes(head._artifact.kind)) // don't rewrite path
          return pathNode;

        if(assocSourceQA.mixin)
        {
          if(head.id === '$projection')
            throw Error('Following mix-in association "' + assoc.name.id +
              '" in defining view is not allowed with ON condition from projection: ' +
              pathAsStr(pathNode.path, '"'));

          /*
            If all mixin assoc paths would result in the same join node (that is exactly
            one shared QAT for all mixin path steps) it would be sufficient to reuse the
            definition QA (see createQAForMixinAssoc()) for sharing the table alias.

            As mixin assoc paths may have different filter conditions, separate QATs are
            created for each distinct filter, resulting in separate JOIN trees requiring
            individual table aliases. This also requires separate QAs at the assoc QAT
            to hold the individual table aliases (that's why the definition QA is cloned
            in mergePathIntoQAT()).

            Paths in the ON condition referring to the target side are linked to the
            original mixin QA via head._navigation (done by the compiler), which in turn
            is childQat._parent (a mixin assoc path step MUST be path root, so _parent
            IS the mixin definition. Mixin QATs are created at the mixin definition).
            In order to create the correct table alias path, the definition QA must
            be replaced with the current childQat.QA (the clone with the correct alias).
            The original QA is used as template for its clones and can safely be replaced.

            Example:
            select from ... mixin { toTgt: association to Tgt on toTgt.elt = elt; }
            into { toTgt[f1].field1, toTgt[f2].field2 };

            toTgt definition has definition QA, ON cond path 'toTgt' refers to definition QA.
            assoc path 'toTgt[f1].' and 'toTgt[f2]' have separate QATs with QA clones.
            'toTgt.elt' must now be rendered for each JOIN using the correct QA clone.
          */

          if(assocQAT.$QA.mixin)
            assocQAT._parent.$QA = assocQAT.$QA;

          [ tableAlias, path ] = constructTableAliasAndTailPath(path);
        }
        else // ON condition of non-mixin association
        {
          if(prefixes.includes(head.id)) // target side
          {
            // no element prefix on target side
            path = translateONCondPath(tail);
            tableAlias = tgtAlias;
          }
          else // source side
          {
            // eventually remove $self and $projection from path
            let isAbsolutePath = head.id === '$self';
            if(isAbsolutePath || head.id === '$projection')
              path = tail;

            tableAlias = srcAlias;
            // if path is not an absolute path, prepend element prefix
            path = translateONCondPath(path, !isAbsolutePath ? assoc.$elementPrefix : undefined);
          }
        }
        let pathStr = path.map(ps => ps.id).join(pathDelimiter);
        return constructPathNode([ tableAlias, { id: pathStr, _artifact: pathNode._artifact } ]);
      }

      // Return the original association if expr is a backlink term, undefined otherwise
      function getForwardAssociationExpr(expr) {
        if(expr.op && expr.op.val == '=' && expr.args.length == 2) {
          return getForwardAssociation(expr.args[0].path, expr.args[1].path);
        }
        return undefined;
      }

      function getForwardAssociation(lhs, rhs) {
        if(lhs && rhs) {
          if(rhs.length == 1 && rhs[0].id == '$self' && lhs.length > 1 && prefixes.includes(lhs[lhs.length-2].id))
            return lhs[lhs.length-1]._artifact;
          if(lhs.length == 1 && lhs[0].id == '$self' && rhs.length > 1 && prefixes.includes(rhs[rhs.length-2].id))
            return rhs[rhs.length-1]._artifact;
        }
        return undefined;
      }
    } // createOnCondition
  } // createJoinQA

  /*
    A QA (QueryArtifact) is a representative for a table/view that must appear
    in the FROM clause either named directly or indirectly through an association.
   */
  function createQA(env, artifact, namedArgs, alias)
  {
    if(alias === undefined)
      alias = artifact.name.id;

    let node = constructPathNode([ { id: artifact.name.absolute, _artifact: artifact, namedArgs  } ], alias);
    return node;
  }

  function incAliasCount(env, QA)
  {
    if(!QA.numberedAlias)
    {
      QA.name.id += '_$' + env.aliasCount++;
      QA.numberedAlias = true;
    }
  }
  /*
    Recursively walk over expression and replace any found path with a new
    path consisting of two path steps. The first path step is the table alias
    and the second path step is the concatenated string of the original path steps.
    Leaf _artifact of pathNode is used as the leaf artifact of the new path string.

    Both the table alias and the original (remaining) path steps are to be produced
    by getTableAliasAndPathSteps().

    tableAlias = [ aliasName, _artifact ]
    path = [ { id: ..., _artifact: ... (unused) } ]
  */
  function rewritePathsInExpression(node, getTableAliasAndPathSteps)
  {
    let env = {
      walkover: {},
      callback: [
        function(pathNode) {
          let [ tableAlias, path ] = getTableAliasAndPathSteps(pathNode);
          let pathStr = path.map(ps => ps.id).join(pathDelimiter);
          replaceNodeContent(pathNode, constructPathNode([ tableAlias, { id: pathStr, _artifact: pathNode._artifact } ]));
        } ]
    };
    walk(node, env);
  }

  /*
    Return a new CSN path object constructed from an array of pathSteps
    path steps is an array of [ 'pathStep id', _artifact reference, namedArgs (optional) ]
    Alias is optional
    The final _artifact ref is set as _artifact ref to the path
  */
  function constructPathNode(pathSteps, alias)
  {
    let node = {
      $rewritten: true,
      path : pathSteps.map(p => {
        let o = {};
        Object.keys(p).forEach(k => {
          if(!['_'].includes(k[0]))
            o[k] = p[k];
        });
        setProp(o, '_artifact', p._artifact );
        return o; })
    };

    if(alias)
      node.name = { id: alias }

    // set the leaf artifact
    setProp(node, '_artifact', pathSteps[pathSteps.length-1]._artifact);
    return node;
  }

  /*
    Replace the content of the old node with the new one.
    If newNode is a join tree (rewritten FROM path), oldPath must be cleared first.
    If newNode is a path => oldNode._artifact === newNode._artifact, no need to
    exchange _artifact (as non-iterable property it is not assigned).
  */
  function replaceNodeContent(oldNode, newNode)
  {
    // If newNode is a join tree, throw away old path content
    if(newNode.op) {
      Object.keys(oldNode).forEach(k => {
        delete oldNode[k] });
      delete oldNode._artifact;
    }
    Object.assign(oldNode, newNode);
  }

  /*
    Collect all of paths to all leafs for a given element
    respecting the src or the target side of the ON condition.
    Return an array of column names and it's leaf element.
   */
  function flattenElement(element, srcSide, prefix)
  {
    // terminate if element is unstructured
    if(!element.foreignKeys && !element.elements)
      return [ { id: prefix, _artifact: element } ];

    let paths = [];
    // get paths of managed assocs (unmanaged assocs are not allowed in FK paths)
    if(element.foreignKeys)
    {
      for(let fkn in element.foreignKeys)
      {
        let fk = element.foreignKeys[fkn];
        // once a fk is to be followed, treat all sub patsh as srcSide, this will add fk.name.id only
        if(srcSide)
          paths = paths.concat(flattenElement(fk.targetElement._artifact, true,  fk.name.id));
        else
        {
          // consume path segments until the next assoc and substitute against fk alias until path is eaten up
          let [ assocStep, tail, fkPrefix ] = pathAsStringUpToAssoc(fk.targetElement.path);
          while(assocStep && tail.length)
          {
            [tail, fkPrefix] = substituteFKAliasForPath(assocStep, tail, fkPrefix);
            [assocStep, tail, fkPrefix] = pathAsStringUpToAssoc(tail, fkPrefix);
          }
          paths = paths.concat(flattenElement(fk.targetElement._artifact, true, fkPrefix));
        }
      }
    }
    // get paths of plain structured elemenents
    else if(element.elements)
    {
      for(let n in element.elements)
      {
        let elt = element.elements[n];
        paths = paths.concat(flattenElement(elt, true, elt.name.id));
      }
    }
    return paths.map(p => { 
      return { id: (prefix ? prefix + pathDelimiter : '' ) + p.id, _artifact: p._artifact } 
    } );
  }


  /*
    Construct both the TA path step and the path tail for a given AST path array
   */
  function constructTableAliasAndTailPath(path)
  {
    let [head, ...tail] = path;
    let QA = head._navigation.$QA || head._navigation._parent.$QA;

    // First path step is table alias, use and pop it off
    if(head._navigation.$QA)
      path = tail;

    return [ /* tableAlias => */ { id: QA.name.id, _artifac: QA._artifact }, path ];
  }

  /*
    Translate ON cond paths and substitute FK aliases
  */
  function translateONCondPath(path, prefix)
  {
    let [ assocStep, tail, fkPrefix ] = pathAsStringUpToAssoc(path);
    while(assocStep && tail.length)
    {
      [tail, fkPrefix] = substituteFKAliasForPath(assocStep, tail, fkPrefix);
      [assocStep, tail, fkPrefix] = pathAsStringUpToAssoc(tail, fkPrefix);
    }
    return [ { id: (prefix ? prefix + fkPrefix : fkPrefix), _artifact: path[path.length-1]._artifact } ];
  }

  /*
    Munch path steps and append them to a path string until an
    assoc step is found. The assoc path step is also appended
    to the path string. If no assoc path step has occured, all
    path steps are added to the path string and tail is empty.

    Return assocPathStep, the remaining tail path and the path string
  */
  function pathAsStringUpToAssoc(path, pathStr)
  {
    if(!pathStr)
      pathStr = '';
    let assocStep = path.find(ps => {
      if(pathStr.length > 0)
        pathStr += pathDelimiter;
      pathStr += ps.id;
      return (ps._artifact.target); // true if it has a target => is assoc => terminate find
    });
    return [ assocStep, path.slice(path.indexOf(assocStep)+1), pathStr ];
  }

  /*
    Substitute the n first path steps of a given path against a FK alias name.
    Resolve a foreign key of a managaged association by following the n first
    path steps. Longest path matches:
    Example: fk tuple { a.b, a.b.c, a.b.e },
    path: a.b.c.d.e.f: FK a.b.c is found, even if FK a.b is one level higher in the prefix tree.
    path: a.b.x.y.z: FK a.b is found, remaining tail path is x.y.z
    Add the FK alias name to the path string.

    Return remaining tail path and the path string.
  */

  function substituteFKAliasForPath(assocStep, path, pathStr='')
  {
    let ppt = assocStep._artifact.$fkPathPrefixTree.children;
    let fk = undefined; // last found FK
    let fkPs = undefined; // last path step that found FK
    path.forEach(ps => {
      if(ppt[ps.id])
      {
        if(ppt[ps.id]._fk)
        {
          fk = ppt[ps.id]._fk;
          fkPs = ps;
        }
        ppt = ppt[ps.id].children;
      }
      else if(!fk)
        // this should never happen if foreign key path could be resolved fully... Anyway, just in case
        throw Error('Could not find fkPrefixTree for ' + ps.id + ' from path ' + pathAsStr(path, '"'));
    });

    if(fk)
    {
      if(pathStr.length)
        pathStr += pathDelimiter;
      pathStr += fk.name.id;
    }

    let tail = path.slice(path.indexOf(fkPs)+1);
    // If foreign key is an association itself, apply substituteFKAliasForPath on tail
    if(fk && fk.targetElement._artifact.target && tail.length)
      return substituteFKAliasForPath(fk.targetElement, tail, pathStr);
    else
      return [ tail, pathStr ];
  }

  /* 
    Catch the most basic path constraint violations that are not yet covered elsewhere
  */
  function flyTrap(pathDict, env)
  {

    // all leaf type must be scalar in a query
    let path = pathDict.path;
    if(env.location === 'filter' || env.location === 'onCondFrom' || env.location === 'onCondAssoc')
    {
      if(path[path.length-1].id != '$self' && pathDict._artifact.elements)
        signal(error`${'Only scalar types allowed in this location of a query: ' + pathAsStr(pathDict.path, "'")}`);

      let [head, ...tail] = path;
      // pop head if it is a table alias or $projection

      if(env.tableAliases && env.tableAliases.includes(head.id) || head.id === '$projection')
        path = tail;

      path.forEach(ps => {
        if(ps._artifact.target)
        {
          if(ps._artifact.onCond || ps._artifact.on)
          {
            if(env.location !== 'onCondAssoc')
              signal(error`Unmanaged associations not allowed in path: ${pathAsStr(pathDict.path)}`);
          }
          else // must be managed
          {
            let la1 = pathDict.path[pathDict.path.indexOf(ps)+1];
            if(la1 && !ps._artifact.$fkPathPrefixTree.children[la1.id])
              signal(error`Pathstep ' + la1.id + ' is not foreign key of association ' +
                ps.id + ' in ON condition path: ' + pathAsStr(pathDict.path)`);
          }
        }
      });
    }
    if(env.location !== 'onCondFrom' && env.location !== 'onCondAssoc')
    {
      if(pathDict.path[0].id === '$projection')
        signal(error`'$projection' outside of ON conditions not supported: " +
          pathAsStr(pathDict.path)`);
    }
  }

  /*
    Create path prefix trees and merge paths into the trees depending on the path location.
    There are prefix trees for FROM table paths and all other paths. Paths of ON conditions
    (of either JOINs in FROM clause or of mixin associations) are not added to the QATree,
    as no associations can be followed in these paths. It is not the job of this transformer
    to semantically check for illegal association path steps in the various clauses of the query.

    All prefix trees are put underneath the $tableAlias structure with attribute $qat or $fqat.
    Each path step appears exactly once for a given filter condition in the prefix tree and
    has a link to it's definition (origin). The default filter is an empty string ''.

    A special note on paths in filter conditions. Filter paths are treated like postfix
    paths to an association path step, meaning, they are inserted into the assoc's $qat or $fqat
    depending on where the association was traversed.
    As HANA CDS doesn't allow to traverse assocs in filter paths, this is checked in flyTrap above.

    A node in the path prefix tree is abbreviated as QAT (which stands for Query Association Tree,
    a term originating from way back in time).
  */
  function mergePathIntoQAT(pathDict, env)
  {
    let path = pathDict.path;

    if(path.length == 0)
      return;

    let qatChildrenName = '$qat';
    if(env.location == 'from')
      qatChildrenName = '$fqat';
    if(env.location == 'onCondFrom')
      return;

    let [head, ...tail] = path;

    // qatParent is the node where the starting qat is attached to
    let qatParent = undefined;

    // FROM and filter paths do not have a _navigation, but for filter paths
    // the corresponding path step (to where the filter was attached to) is in env.pathStep
    if(!head._navigation)
    {
      // speciality for OrderBy: If path has no _navigation don't merge it.
      // Path is alias to select item expression
      if(env.location === 'OrderBy')
        return;

      // env.pathStep is set in walkPath for walk on filter conditions
      if(env.pathStep)
        qatParent = env.pathStep._navigation;
      else if(pathDict.name) // from table path with its alias
        qatParent = env.lead.$tableAliases[pathDict.name.id];
      else
        // tableAlias not found yet, last resort is head.id => published Assoc
        qatParent = env.lead.$tableAliases[head.id];
      tail = path; // start with the full path
    }
    // All other paths have a _navigation attribute
    else if(head._navigation)
    {
      /*
        Always start with QAT merge at $tableAlias, even if path doesn't start there.
        First identify $tableAlias (must be either head or head's parent) The resolver
        sets a _navigation at the very first path step that either points to $tableAlias
        or to a top level element from $combined which itself parent's to $tableAlias).
      */
      if(head._navigation.kind == '$navElement')
      {
        qatParent = head._navigation._parent;
        tail = path; // Start with the full path (no table alias prefix)
      }
      else if(head._navigation.kind == 'element') // This is a mixin assoc
      {
        qatParent = head._navigation;
        tail = path;
      }
      else // Head is a table alias already
      {
        qatParent = head._navigation;
      }
    }

    if(qatParent == undefined)
      throw Error('table alias/qathost not found for path: ' +  pathAsStr(path));

    let rootQat = qatParent;

    // Create the very first QAT if it doesn't exist
    // (filter condition for table alias prefix not allowed)
    let qatChildren = createQATChildren(qatParent);
    let qat = undefined;

    for(let pathStep of tail)
    {
      /*
        If the current path step has not yet been inserted into the list of children at
        the parent QAT, create a new QAT (linkToOrigin) and a dictionary for subsequent
        path steps (a separate one for each filter condition).
      */
      let qatName = pathStep.id;

      if(pathStep.where)
        qatName  += JSON.stringify(compactNode(pathStep.where));

      if(pathStep.namedArgs) {
        // sort named arguments
        let sortedNamedArgs = Object.create(null);
        Object.keys(pathStep.namedArgs).sort().forEach(p => {
          sortedNamedArgs[p] = pathStep.namedArgs[p];
        })
        qatName += JSON.stringify(compactNode(sortedNamedArgs));
      }


      qat = qatChildren[qatName];
      if (!qat)
      {
        qat = linkToOrigin(pathStep._artifact, pathStep.id, qatParent, undefined, pathStep.location);
        /*
          Query filter have precedence over default filters.
          Clone default filter for each usage to avoid path rewriting of the definition.
          TODO: If Filter become JOIN relevant, default filters MUST BE cloned before starting the transformation
                or the paths won't be added to the QAT and the rewriting would be done on the filter definition.
        */
        if(pathStep.where /*|| pathStep._artifact.where*/)
          qat._filter = pathStep.where /*|| clone(pathStep._artifact.where)*/;
        if(pathStep.namedArgs)
          qat._namedArgs= pathStep.namedArgs;

        /*
          If qat.origin._artifact has a QA, it must be a mixin association
          (No other QA's have been created so far). Clone new QA from this
          template to have space for table aliases (if mixin assoc is
          followed with different filter conditions).
        */
        if(qat.origin._artifact.$QA) {
          qat.$QA = clone(qat.origin._artifact.$QA);
          if(qat._namedArgs)
            qat.$QA.path[0].namedArgs = qat._namedArgs;
        }

        qat.kind = '$navElement';
        qatChildren[qatName] = qat;
      }
      qatChildren = createQATChildren(qat);
      qatParent = qat; // Current qat becomes parent to the next level of children
      setProp( pathStep, '_navigation', qat );
    }

    if(!qat)
      throw Error('No leaf qat for head: ' + head + ' tail: ' + pathAsStr(tail, '"') + ' produced');

    /*
      If path terminates on an entity or an association (from clause,
      published Ad-Hoc Assocs), attach QA to the (leaf) QAT and to the
      rootQAT (which is the tableAlias).
      This QA will later serve as the initial 'lastAssocQA' for all other
      join relevant paths that originate from this alias. Also this is the
      only place where the original FROM alias is available.
    */
    let art = qat.origin._artifact;
    if(!modelUtils.isArtifact(art))
      if(art.target)
        art = art.target._artifact;
      else
        art = undefined;

    if(art)
    {
        // If rootQat ($tableAlias) already has a QA, reuse it, create a new one otherwise.
      if(!rootQat.$QA)
      {
        // Use the original FROM alias if available!
        let alias = pathDict.name ? pathDict.name.id : undefined;
        rootQat.$QA = qat.$QA = createQA(env, art, qat._namedArgs, alias);
      }
    }

    // Return or create a new children dictionary for a given QAT
    // Children are grouped under the filter condition that precedes them.
    function createQATChildren(parentQat)
    {
      if(!parentQat[qatChildrenName])
        parentQat[qatChildrenName] = Object.create(null);
      return parentQat[qatChildrenName];
    }
  }

  // Crawl all relevant sections of the query AST for paths
  function walkQuery(query, env)
  {
    if(!query)
      return;

    if(!env.walkover)
      env.walkover = {};
    env.location = query.op;

    if(query.op.val === 'query')
    {
      env.lead = query;

      env.location = 'from';
      walkFrom(query.from);

      env.location = 'select';
      if(env.walkover[env.location])
      {
        for(let alias in query.elements)
          walk(query.elements[alias].value, env);

        env.location = 'Where';
        walk(query.where, env);
        env.location = 'GroupBy';
        walk(query.groupBy, env);
        env.location = 'Having';
        walk(query.having, env);
        env.location = 'OrderBy';
        walk(query.orderBy, env);
        // outer orderBy's of anonymous union
        walk(query.$orderBy, env);
        env.location = 'Limit';
        walk(query.limit, env);
        env.location = 'Offset';
        walk(query.offset, env);
      }
    }

    function walkFrom(query)
    {
      let aliases = [];
      if(query) 
      {
        if(Array.isArray(query))
        {
          for(let q of query)
            aliases = aliases.concat(walkFrom(q));
        }
        else if(env.walkover[env.location] && walkPath(query, env))
        {
          if(query.name)
            aliases.push(query.name.id);
        }
        else
        {
          aliases = walkFrom(query.args);

          env.location = 'onCondFrom';
          if(env.walkover[env.location])
          {
            env.tableAliases = aliases;
            walk(query.onCond || query.on, env)
            delete env.tableAliases;
          }
          env.location = 'from';
        }
      }
      return aliases;
    }
  }

  /* node: any
    env: { callback: (array of) callback methods with signature(thing, env)
            ...:      any additional payload for the callback
          }
  */
  function walk(node, env)
  {
    // In some expressions queries can occur, do not follow them as they
    // are walked as member of the queries array
    if(!env || !node || (node && node.op && node.op.val == 'query'))
      return;

    if(typeof node === 'object' && !Array.isArray(node))
      if(walkPath(node, env))
        return;

    // Ask for Array before typeof object (which would also be true for Array)
    if(Array.isArray(node)) 
      node.map(n => walk(n, env));
    // instanceof Object doesn't respect dictionaries...
    else if(typeof node === 'object')
      for(let n in node)
        walk(node[n], env);
  }

  function walkPath(node, env)
  {
    let path = node['path'];
    // Ignore paths that that have no artifact (function calls etc) or that are builtins ($now, $user)
    // or that are parameters ($parameters or escaped paths (':')
    //path.length && path[ path.length-1 ]._artifact
    let art = path && path.length && path[path.length-1]._artifact;
    if(art && !internalArtifactKinds.includes(art.kind))
    {
      if(env.callback)
      {
        // an array of callbacks applied to the node
        if(Array.isArray(env.callback))
          env.callback.forEach(cb => cb(node, env));
        else
          env.callback(node, env);
      }

      /*
        NOTE: As long as association path steps are not allowed in filters,
        it is not required to walk over filter expressions.
        Simple filter paths are rewritten inin createJoinTree (first filter)
        and createJoinQA (subsequent one that belong to the ON condition).

        If the filter becomes JOIN relevant, default FILTERS (part of the 
        association definition) MUST be CLONED to each assoc path step
        BEFORE resolution.

      let filterEnv = Object.assign({walkover: {} }, env);
      filterEnv.location = 'filter';
      if(filterEnv.walkover[filterEnv.location])
      {
        // Walk over all filter expressions (not JOIN relevant,
        // cannot be detected in generic walk. Store path step
        // to which this filter was attached to in filterEnt.pathStep
        path.filter(pathStep=>pathStep.where).forEach(pathStep => {
          filterEnv.pathStep = pathStep;
          walk(pathStep.where, filterEnv) });
      }
      */
      // TODO: Parameter expressions!
    }
    return path;
  }

  function pathAsStr(p, delim='')
  {
    return p.map(p => delim + p.id + delim).join(pathDelimiter);
  }

  // for debugging only
  // eslint-disable-next-line no-unused-vars
  function printPath(pathDict, env)
  {
    let alias = (pathDict.name && pathDict.name.id) || '<undefined>'
    let path = pathDict.path;
    let s = pathAsStr(path, '"');
    let me = env.lead && (env.lead.name.id || env.lead.op);
    // eslint-disable-next-line no-console
    console.log(me + ': ' + env.location + ": " + s + " alias: " + alias);
  }

  function isEntityOrView(node)
  {
    if (!node) {
      return false;
    }
    switch (node.kind) {
      case 'entity':
      case 'view':
        return true;
      case 'context':
      case 'service':
      case 'namespace':
      case 'type':
      case 'annotation':
      case 'action':
      case 'function':
      case 'const':
      case 'role':
      case 'aspect':
      case 'accesspolicy':
      case 'element':
      case 'query':
      case 'param':
      case 'enum':
        return false;
      default:
        throw new Error('Unknown artifact kind: ' + node.kind);
    }
  }

  function clone(obj) {
    let newObj;
    if (typeof obj !== 'object' || obj === null) // return primitive type, note that typeof null === 'object'
      return obj;
    if (Array.isArray(obj))
      newObj = [];
    else if (obj.constructor) // important for classes, else prototype chain for inheritance will not be correct
      newObj = new obj.constructor()
    else if (!Object.getPrototypeOf(obj))
      newObj = Object.create(null);  // dictionary
    else
      newObj = {};

    let props =  Object.getOwnPropertyNames(obj);  // clone own properties only, not inherited ones
    for (let p of props) {
      let pd = Object.getOwnPropertyDescriptor(obj, p);
      if (pd && pd.enumerable === false)
      {
        pd.value = obj[p]; // don't copy references
        Object.defineProperty(newObj, p, pd);
      }
      else
        newObj[p] = clone(obj[p]);
    }
    return newObj;
  }
}


module.exports = { translateAssocsToJoins };
