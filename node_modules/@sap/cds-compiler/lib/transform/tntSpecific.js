'use strict';

const { cloneWithTransformations, setProp } = require('../base/model');
const deepCopy = require('../base/deepCopy');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { mergeOptions } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// Returns the default 'skip' options for operating with TNT flavor
function getDefaultTntFlavorOptions() {
  // Please keep this in sync with what TNT actually uses
  return {
    skipGeneratedFKsWithout_: false,  // if true: Generate foreign key names with a '_' as separator
    skipValueListMagic: false,        // if true: Do not listen for @Common.ValueList.entity and generate NavProp
                                      //          and sap:value-list="fixed-values" @ Property/Parameter
    skipUsingFromIgnoring: false,                    // if true: Do not ignore the FROM of USING declarations, error for IDs after USING
    skipSloppyAnnoAssignments: false,                // if true: Do not allow sloppy annotation assignments syntax for context definitions - use @(...)
    skipServiceIncludes: false,                      // if true: Do not include contexts into services via "@extends" annotation
    skipPropagatingIncludes: false,                  // if true: Do not propagate the list of included artifacts
    skipNotPropagatingIndexableAnno: false,          // if true: Do not make an exception for the propagation of the '@Indexable' annotation

    // ----- annotation preprocessing -----
    skipAnnosTextArrangementReordering: false,       // if true: Do not automatically produce correct form for TextArrangementAnnotation
    skipAnnosTextAndValueListForAssocs: false,       // if true: Do not artificially generate '@Common.Text' and '@Common.ValueList' for associations
    skipAnnosRemoveManagedAssociationAnnos: false,   // if true: Do not remove annotations from managed associations
    skipAnnosSubstitutingFKeysForAssocs: false,      // if true: Do not replace paths to assocations by paths to their (single) foreign key in
                                                     //          selected annotations (currently '@UI.LineItem', '@UI.Identification',
                                                     //          '@UI.FieldGroup', '@UI.SelectionFields')
  };
}

// Perform TNT-specific extensions for augmented 'inputModel'. Each service S that has an '@extends: XXX'
// annotation gets a copy of all artifacts from context/service 'com.sap.gtt.core.CoreServices.XXX'.
// All associations and compositions in service S (whether copied into S or originally part of S) that
// pointed into 'XXX' are then re-targeted to S.
// Return an (augmented) copy of 'inputModel' with the transformation applied. Do not change the original inputModel.
// Throws a CompilationError on errors. Warnings are stored in the result model.
function transformTntExtensions(inputModel, options) {
  const { error, signal } = alerts(inputModel);
  // Deep-copy the original model
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;
  model.options = mergeOptions(model.options, options);
  // Do nothing except deep-copy if no TNT-flavor
  if (!model.options.tntFlavor) {
    return model;
  }
  // Find services that have an '@extends' annotation or an 'include'
  for (let name in model.definitions) {
    let artifact = model.definitions[name];
    let includedContextName;
    if (artifact.kind == 'service' && (artifact['@extends'] || artifact.includes)) {
      let serviceName = name;
      // FIXME: Old approach, only if not skipped: TNT-specific '@extends' annotation
      if (!model.options.tntFlavor.skipServiceIncludes && artifact['@extends']) {
        let annotationValue = artifact['@extends'].path.map(step => step.id).join('.');
        // FIXME: The '@extends' annotation should at least contain the fully qualified name
        // of the context to be included - we assume here that it starts with 'com.sap.gtt.core.CoreServices.'
        includedContextName = 'com.sap.gtt.core.CoreServices.' + annotationValue;
        // console.log('Extending service ' + name + ' with ' + includedContextName);
        // Find the context to be included
        let includedContext = model.definitions[includedContextName];
        if (includedContext == undefined) {
          signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": not found`, artifact['@extends'].location);
          continue;
        }
        // Must be a context or a service
        if (includedContext.kind != 'context' && includedContext.kind != 'service') {
          signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": "${includedContext.kind}" is neither context nor service`, artifact['@extends'].location);
          continue;
        }
      }
      // FIXME: New approach, independent of skip options: colon-notation (like entity includes)
      // (Should be done by the compiler later)
      else {
        // For now, only support what was originally supported
        if (artifact.includes.length != 1) {
          signal(error`Cannot extend service "${serviceName}" with more than one included service`, artifact.location);
          continue;
        }
        includedContextName = artifact.includes[0]._artifact.name.absolute;
        // For now, only allow inclusion of (typically abstract) services
        if (model.definitions[includedContextName].kind != 'service') {
          signal(error`Can only extend service "${serviceName}" with another service`, artifact.includes[0].location);
          continue;
        }
      }
      // Copy all artifacts contained within the included context/service (by means of their name prefix only!)
      for (let name in model.definitions) {
        if (name.startsWith(includedContextName + '.')) {
          let sourceName = name;
          let targetName = sourceName.replace(includedContextName, serviceName);
          // console.log('Copying artifact ' + sourceName + ' to ' + targetName);
          if (model.definitions[targetName]) {
            signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": "${targetName}" already exists`, artifact['@extends'].location);
          }
          // We can only import one level of artifacts here (i.e. no containers)
          let localName = sourceName.substring(includedContextName.length + 1);
          if (localName.indexOf('.') != -1) {
            signal(error`Cannot extend service "${serviceName}" with artifact "${sourceName}": only entities/types are allowed, not contexts/services`, artifact['@extends'].location);
          }
          // Deep-copy the source artifact
          let sourceArtifact = model.definitions[sourceName];
          let targetArtifact = cloneWithTransformations(sourceArtifact, {}, true);
          // FIXME: In order not to have to manually adapt all internal links for actions and their parameters,
          // we refrain from deep-copying them here and simply take them as they are - niemand hat die Absicht, sie zu veraendern anyway ...
          if (sourceArtifact.actions) {
            targetArtifact.actions = sourceArtifact.actions;
          }
          if (targetArtifact.elements != undefined) {
            for (let elementName in targetArtifact.elements) {
              let sourceElement = sourceArtifact.elements[elementName];
              let targetElement = targetArtifact.elements[elementName];
              setProp(targetElement, '_main', targetArtifact);
              // FIXME: Not entirely complete for nested stuff, but good enough for now...
              setProp(targetElement, '_parent', targetArtifact);
              if (sourceElement._finalType) {
                setProp(targetElement, '_finalType', sourceElement._finalType);
              }
            }
          }
          // Adapt the target artifact's name (artificial, i.e. no path)
          targetArtifact.name = {
            absolute: targetName,
            id: sourceArtifact.name.id,
          }
          model.definitions[targetName] = targetArtifact;
          // Adapt target artifact's parent/child relation
          artifact.artifacts[localName] = targetArtifact;
          setProp(targetArtifact, '_parent', artifact);
          setProp(targetArtifact, '_service', artifact);
          if (sourceArtifact.source != targetArtifact.source) {
            targetArtifact.source = sourceArtifact.source;
          }
        }
      }
      // Adapt all association targets within the service that has included the context (by means of their name prefix only!)
      for (let name in model.definitions) {
        if (name.startsWith(serviceName + '.')) {
          let artifact = model.definitions[name];
          // If the artifact has association elements, adapt their targets and foreign keys
          for (let elementName in artifact.elements || {}) {
            let element = artifact.elements[elementName];
            if (element.target != undefined && element.target._artifact) {
              let elementTargetAbsolute = element.target._artifact.name.absolute.replace(includedContextName, serviceName);
              setProp(element.target, '_artifact', model.definitions[elementTargetAbsolute]);
              if (element.target.path) {
                setProp(element.target.path[element.target.path.length - 1], '_artifact', model.definitions[elementTargetAbsolute]);
              }
              if (element.foreignKeys != undefined) {
                for (let foreignKeyName in element.foreignKeys) {
                  let foreignKey = element.foreignKeys[foreignKeyName];
                  foreignKey.name.absolute = element.name.absolute;
                  setProp(foreignKey.targetElement, '_artifact', element.target._artifact.elements[foreignKey.name.id]);
                }
              }
            }
          }
        }
      }
    }
  }
  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return model;
}

// Within compact CSN 'csn', propagate the 'include' property along included entities and query sources,
// as the old implementation of propagation in the compiler did (ending up with the value of the
// 'includes' property from the lowest artifact in the chain that has one being copied to all above,
// which doesn't actually make much sense - but that's what TNT apparently got used to).
// Modify the model in place.
function propagateIncludesForTnt(csn) {
  for (let name in csn.definitions) {
    let artifact = csn.definitions[name];
    propagateIncludesFrom(artifact);
  }

  function propagateIncludesFrom(artifact) {
    if (artifact.includes) {
      // Perform propagation for all of our own includes (if any)
      for (let includeName of artifact.includes) {
        propagateIncludesFrom(csn.definitions[includeName]);
      }
      // Take over the first include's includes (if any)
      if (csn.definitions[artifact.includes[0]].includes) {
        artifact.includes = csn.definitions[artifact.includes[0]].includes;
      }
    } else if (artifact.source) {
      // Perform propagation for our projection source (if any)
      propagateIncludesFrom(csn.definitions[artifact.source]);
      // Take over our projectiuon source's includes (if any)
      if (csn.definitions[artifact.source].includes) {
        artifact.includes = csn.definitions[artifact.source].includes;
      }
    }
  }
}

module.exports = {
  getDefaultTntFlavorOptions,
  transformTntExtensions,
  propagateIncludesForTnt,
}
