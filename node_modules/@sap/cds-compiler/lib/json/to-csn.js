// Transform augmented CSN into compact "official" CSN

'use strict';

const { queryOps } = require('../base/model');
const { locationString } = require('../base/messages');

var csn_gensrc = true;          // good enough here...
var mode_strict = false;        // whether to dump with unknown properties (in standard)

// IMPORTANT: the order of these properties determine the order of properties
// in the resulting CSN !!!
const transformers = {
  // early and modifiers (without null / not null) -------------------------------------
  kind,
  name: ignore,                 // as is provided extra
  id: n => n,                   // in path item
  '@': value,
  abstract: value,
  dbType: value,                // TODO: currently with --hana-flavor only
  virtual: value,
  key: value,
  masked: value,
  params: insertOrderDict,
  // early expression / query properties -------------------------------------
  op: o => (o.val !== 'query') ? o.val : undefined,
  from: fromOld,                // before elements! XSN TODO just one (cross if necessary)
  // join done in from()
  // func   // in expression()
  quantifier: ( q, csn ) => { csn[ q.val ] = true; },
  all: ignore,                  // XSN TODO use quantifier
  // type properties (without 'elements') ------------------------------------
  localized: value,
  type: artifactRef,
  length: value,
  precision: value,
  scale: value,
  cardinality: standard,            // also for pathItem: after 'id', before 'where'
  target: artifactRef,
  foreignKeys: renameTo( 'keys', dictAsArray ), // XSN: rename?
  on: (cond) => (typeof cond === 'string' ? undefined : condition( cond )), // also for join
  onCond : renameTo( 'on', condition ), // XSN TODO: onCond -> on
  enum: insertOrderDict,
  items: standard,
  includes: arrayOf( artifactRef ), // also entities
  // late expressions / query properties -------------------------------------
  mixin: insertOrderDict,       // only in queries with special handling
  columns,
  exclude: renameTo( 'excluding', Object.keys ), // XSN TODO: exclude->excluding
  groupBy: arrayOf( expression ),
  where: condition,             // also pathItem after 'cardinality' before 'args'
  having: condition,
  limit,                       // TODO XSN: include offset
  offset: ignore,              // TODO XSN: move into `limit` - see limit
  orderBy: arrayOf( orderBy ), // TODO XSN: make `sort` and `nulls` sibling properties
  args,                        // also pathItem after 'where'
  namedArgs: renameTo( 'args', args ), // XSN TODO - use args
  // definitions, extensions, members ----------------------------------------
  returns: standard,            // storing the return type of actions
  notNull: value,
  default: expression,
  // targetElement: ignore,     // special display of foreign key, renameTo: select
  value: enumValue,             // do not list for select items as elements
  query,
  elements,
  sequenceOptions: ignore,     // TODO: currently not in the JSON by HANA
  actions: nonEmptyDict,
  technicalConfig,             // TODO: spec, re-check
  // special: top-level, cardinality -----------------------------------------
  definitions: sortedDict,
  extensions: standard,  // is array - TODO: sort
  messages: ignore,      // consider compactQuery / compactExpr
  sourceMax: renameTo( 'src', value ), // TODO XSN: rename?
  targetMin: renameTo( 'min', value ),
  targetMax: renameTo( 'max', value ),
  // late protected ----------------------------------------------------------
  viaTransform: standard,       // FIXME: not a standard prop, start with $
  generatedFieldName: renameTo( '$generatedFieldName', n => n ), // TODO: XSN name
  $syntax: s => s,
  _containerEntity: n => n,     // FIXME: prop starting with _ is link and non-enumerable
  _ignore: a => a,              // not yet obsolete - still required by toHana (FIXME: maybe rename to $ignore, or use an annotation instead?)
  _ignoreMasked: standard,      // FIXME: prop starting with _ is link and non-enumerable
  _isToContainer: standard,     // FIXME: prop starting with _ is link and non-enumerable
  $extra: (e, csn) => { Object.assign( csn, e ); },
  // IGNORED -----------------------------------------------------------------
  artifacts: ignore,             // well-introduced, hence not $artifacts
  location: ignore,              // TODO: think about $location with flat struct (w/o offset)
  annotationAssignments: ignore, // FIXME: make it $annotations
  blocks: ignore,                // FIXME: make it $blocks
  queries: ignore,               // FIXME: make it $queries (flat)
  typeArguments: ignore,         // FIXME: make it $typeArgs
  calculated: ignore,            // TODO remove ($inferred: 'as')
  implicitForeignKeys: ignore,   // later in assoc: $inferred: { foreignKeys: 'fk' } or $inferred on each fk
  indexNo: ignore,             // TODO XSN: remove
  origin: ignore,              // TODO remove (introduce non-enum _origin link)
  projection: ignore,          // TODO remove
  redirected: ignore,          // TODO remove: no need for this
  source: ignore,              // TODO remove
  viaAll: ignore,              // TODO remove, later in elem: $inferred: '*'
  '$': ignore,
  //'_' not here, as non-enumerable properties are not transformed anyway
  _typeIsExplicit: ignore,
}

const propertyOrder = (function () {
  let r = {};
  let i = 0;
  for (let n in transformers)
    r[n] = ++i;
  return r;
})();

const typeProperties = [        // just for `cast` in select items
  'type', 'length', 'precision', 'scale', 'items', 'target', 'elements', 'enum'
];

const operators = {
  // standard is: binary infix (and corresponding n-ary), unary prefix
  isNot: [ 'is', 'not' ],       // TODO XSN: 'is not'
  isNull: postfix( ['is', 'null'] ),
  isNotNull: postfix( [ 'is', 'not', 'null' ] ),
  notIn: [ 'not', 'in' ],
  between: ternary( ['between'], ['and'] ),
  notBetween: ternary( ['not', 'between'], ['and'] ),
  like: ternary( ['like'], ['escape'] ),
  notLike: ternary( ['not', 'like'], ['escape'] ),
  when: (args) => ['when', ...args[0], 'then', ...args[1]],
  case: (args) => ['case'].concat( ...args, ['end'] ),
  // xpr: (args) => [].concat( ...args ), see below - handled extra
}

function compactModel( model, options = model.options || {} ) {
  csn_gensrc = options.toCsn && options.toCsn.gensrc;
  mode_strict = options.testMode;
  let csn = {};
  set( 'definitions', csn, model );
  if (!csn_gensrc)
    set( 'extensions', csn, model );
  else
    extensions( csn, model );
  if (model.version)
    csn.version = model.version; // TODO remove
  if(!options.testMode) {
    setMetaProperty(csn, model);
    setCsnVersion(csn);
  }
  // Use $extra properties of first source as resulting $extra properties
  for (let f in model.sources) {
    set( '$extra', csn, model.sources[f] );
    break;
  }
  return csn;
}

function renameTo( csnProp, func ) {
  return function( val, csn, node, prop ) {
    let sub = func( val, csn, node, prop );
    if (sub !== undefined)
      csn[csnProp] = sub;
  }
}

function arrayOf( func ) {
  return ( val, ...args ) => val.map( v => func( v, ...args ) );
}

function extensions( csn, model ) {
  let extensions = (model.extensions) ? standard( model.extensions ) : [];
  for (let name in model.definitions) {
    let art = model.definitions[name];
    // in definitions (without redef) with potential inferred elements:
    if (!(art instanceof Array) && art.elements &&
        (art.query || art.includes || art.$inferred)) {
      let annos = art.$inferred && annotations( art, true );
      let elements = inferred( art.elements, art.$inferred );
      let annotate = Object.assign( { annotate: name }, annos );
      if (Object.keys( elements ).length)
        annotate.elements = elements;
      if (Object.keys( annotate ).length > 1)
        extensions.push( annotate );
    }
  }
  if (extensions.length)
    csn.extensions = extensions;
}

function inferred( elements, inferredParent ) {
  let ext = Object.create(null);
  for (let name in elements) {
    let elem = elements[name];
    if (elem instanceof Array || !inferredParent && !elem.$inferred)
      continue;
    let csn = annotations( elem, true );
    if (Object.keys(csn).length)
      ext[name] = csn;
  }
  return ext;
}

function standard( node ) {
  if (node instanceof Array)
    return node.map( standard );
  let csn = {};
  // To avoid another object copy, we sort according to the prop names in the
  // XSN input node, not the CSN result node.  Not really an issue...
  let keys = Object.keys( node ).sort( compareProperties );
  for (let prop of keys) {
    let transformer = transformers[prop] || transformers[prop.charAt(0)];
    if (mode_strict && !transformer) {
      let loc = node[prop] && node[prop].location || node.location;
      throw new Error( `Unexpected property ${prop} in ${ locationString(loc) }`);
    }
    let sub = (transformer || standard)( node[prop], csn, node, prop );
    if (sub !== undefined)
      csn[prop] = sub;
  }
  return csn;
}

function set( prop, csn, node ) {
  let val = node[prop];
  if (val === undefined)
    return;
  let sub = transformers[prop]( node[prop], csn, node, prop );
  if (sub !== undefined)
    csn[prop] = sub;
}

function elements( dict, csn, node ) {
  if (csn.from)                 // with SELECT
    return undefined;
  if (!csn_gensrc || !node.query && !node.type)
    return insertOrderDict( dict );
  else
    return undefined;
}

// for csn_gensrc: return annotations from definition (annotated==false)
// or annotations (annotated==true)
function annotations( node, annotated ) {
  let csn = {};
  let transformer = transformers['@'];
  let keys = Object.keys( node ).filter( a => a.charAt(0) === '@' ).sort();
  for (let prop of keys) {
    let val = node[prop];
    if ((val.priority && val.priority !== 'define') == annotated) {
      // transformer (= value) takes care to exclude $inferred annotation assignments
      let sub = transformer( val, csn, node, prop );
      if (sub !== undefined)
        csn[prop] = sub;
    }
  }
  return csn;
}

function ignore() {}

function insertOrderDict( dict ) {
  let keys = Object.keys( dict );
  return dictionary( dict, keys );
}

function sortedDict( dict ) {
  let keys = Object.keys( dict );
  keys.sort();
  return dictionary( dict, keys );
}

function nonEmptyDict( dict ) {
  let keys = Object.keys( dict );
  return (keys.length)
    ? dictionary( dict, keys )
    : undefined;
}

function dictionary( dict, keys ) {
  let csn = Object.create(null);
  for (let name of keys) {
    let def = definition( dict[name] );
    if (def !== undefined)
      csn[name] = def;
  }
  return csn;
}

function dictAsArray( dict ) {
  let csn = [];
  for (let n in dict) {
    let d = definition( dict[n] );
    if (d !== undefined)
      csn.push( d );
  }
  return (csn.length) ? csn : undefined;
}

function definition( art ) {
  if (!art || typeof art !== 'object')
    return undefined;           // TODO: complain with strict
 // Do not include namespace definitions or inferred construct (in gensrc):
  if (art.kind === 'namespace' || art.$inferred && csn_gensrc)
    return undefined;
  if (art.kind === 'key') {      // foreignkey
    let key = addExplicitAs( expression( art.targetElement ),
                             art.name, neqPath( art.targetElement ) );
    set( 'generatedFieldName', key, art );
    return extra( key, art );
  }
  else
    return standard( art );
}

function kind( k, csn, node ) {
  if (!node._main && ['annotate', 'extend'].includes( k )) {
    // We just use `name.absolute` because it is very likely a "constructed"
    // extensions.  The CSN parser must produce name.path like for other refs.
    csn[k] = node.name.absolute || artifactRef( node.name, true );
    return undefined;
  }
  if (k === 'view')          // XSN TODO: kind: 'entity'
    return 'entity';
  if (['element', 'key', 'enum', 'annotate', 'query', '$tableAlias'].includes(k))
    return undefined;
  return k;
}

function artifactRef( node, terse ) {
  if (node.$inferred && csn_gensrc)
    return undefined;
  // Works also on XSN directly coming from parser
  let path = node.path;
  if (!path)                // does not work with current augmentor
    return undefined;           // TODO: complain with strict
  let length = path.length;
  let index  = 0;
  for (; index < length; ++index) {
    let art = path[index]._artifact;
    if (!art || art._main)      // stop if at element or not found/compiled
      break;
  }
  let id;
  if (index) {
    id = path[ index-1 ]._artifact.name.absolute;
  }
  else if (node.resolveSemantics === 'typeOf' && path[0]._artifact) {
    let name = path[0]._artifact.name;
    return { ref: [ name.absolute, ...name.element.split('.'), ...path.slice(1).map( pathItem ) ] };
  }
  else if (typeof node.scope === 'number') {
    // TODO: just use the first with CSN input - CDL should provide scope:0
    index = node.scope || length;
    id = (node.scope ? path.slice(0,index) : path).map( id => id.id ).join('.');
  }
  else {                        // JSON or i18n input (without compiler links)
    index = 1;
    id = path[0].id;
  }
  let main = Object.assign( {}, path[ index-1 ], { id } );
  let ref = [main, ...path.slice(index)].map( pathItem );
  return (!terse || ref.length != 1 || typeof ref[0] !== 'string')
         ? { ref }
         : ref[0];
}

function pathItem( item ) {
  if (!item.args && !item.namedArgs && !item.where && !item.cardinality && !item.$extra)
    return item.id;
  else
    return standard( item );
}

function args( node ) {
  if (node instanceof Array)
    return node.map( expression );
  let dict = Object.create(null);
  for (let param in node)
    dict[param] = expression( node[param] );
  return dict;
}

// "Short" value form, e.g. for annotation assignments
function value( node ) {
  if (!node)
    return true;                // `@aBool` short for `@aBool: true`
  if (node.$inferred && csn_gensrc)
    return undefined;
  if (node.path)
    return extra( { '=': node.path.map( id => id.id ).join('.') }, node );
  if (node.literal == 'enum')
    return extra( { "#" : node.symbol.id }, node );
  if (node.literal == 'array')
    return node.val.map( value );
  if (node.literal != 'struct')
    // no val (undefined) as true only for annotation values (and struct elem values)
    return node.name && !('val' in node) || node.val;
  let r = Object.create( null );
  for (let prop in node.struct)
    r[prop] = value( node.struct[prop] );
  return r;
}

function enumValue( v, csn, node )  {
  if (node.kind === 'enum')
    Object.assign( csn, expression(v) );
}

function condition( node ) {
  let expr = expression( node );
  return expr.xpr || [expr];
}

const magicFunctions =          // TODO: calculate from compiler/builtins.js (more with HANA?):
      ['CURRENT_DATE','CURRENT_TIME','CURRENT_TIMESTAMP','CURRENT_USER','SESSION_USER'];
// TODO: quoted magic names like $now should be complained about in the compiler

function expression( node, withExtra ) {
  let en = withExtra != null && node;
  if (typeof node === 'string')
    return node;
  if (!node)                    // make to-csn robst
    return {};
  if (node instanceof Array) {
    let args = node.map( condition );
    let rest = args.slice(1).map( a => [',', ...a] );
    return { xpr: ['('].concat( args[0], ...rest, [')'] ) };
  }
  if (node.scope === 'param') {
    if (node.path)
      return extra( { ref: node.path.map( pathItem ), param: true }, en );
    else
      return extra( { ref: [ node.param.val ], param: true }, en );
  }
  if (node.path) {
    // TODO: global
    if (node.path.length !== 1)
      return extra( { ref: node.path.map( pathItem ) }, en );
    let item = pathItem( node.path[0] );
    if (typeof item === 'string' && !node.path[0].quoted &&
        // TODO: use _artifact if available
        magicFunctions.includes( item.toUpperCase() )) {
      return extra( { func: item }, en );
    }
    return extra( { ref: [item] }, en );
  }
  if (node.literal) {
    if (typeof node.val === node.literal || node.val === null)
      return extra( { val: node.val }, en );
    else if (node.literal === 'enum')
      return extra( { "#" : node.symbol.id }, en );
    else                        // TODO XSN: literal 'hex'->'x'
      return extra( { val: node.val, literal: (node.literal==='hex') ? 'x' : node.literal },
                    en );
  }
  if (node.func) {              // TODO XSN: remove op: 'call', func is no path
    let call = { func: node.func.path[0].id };
    if (node.args || node.namedArgs) // no args from CSN input for CURRENT_DATE etc
      call.args = args( node.args || node.namedArgs );
    return extra( call, en );
  }
  if (queryOps[ node.op.val ])
    return query( node );
  else if (node.op.val === 'xpr')
    // do not use xpr() for xpr, as it would flatten inner xpr's (semantically ok)
    return extra( { xpr: node.args.map( expression ) }, node );
  else                          // other ops have no $extra
    return { xpr: xpr( node ) };
}

function xpr( node ) {
  // if (!node.op) console.log(node)
  let op = operators[ node.op.val ] || node.op.val.split(' ');
  let args = node.args.map( condition );
  if (op instanceof Function)
    return op( args );
  if (node.quantifier)
    op.push( node.quantifier.val );
  if (args.length < 2)
    return [ ...op, ...args[0] || [] ];
  return args[0].concat( ...args.slice(1).map( a => [...op, ...a] ) );
}

function ternary( op1, op2 ) {
  return function( args ) {
    return (args[2])
      ? [ ...args[0], ...op1, ...args[1], ...op2, ...args[2] ]
      : [ ...args[0], ...op1, ...args[1] ];
  };
}

function postfix( op ) {
  return function( args ) {
    return [ ...args[0], ...op ];
  }
}

function query( node ) {
  while (node instanceof Array) // in parentheses -> remove
    node = node[0];
  if (node.op.val === 'query')
    return { SELECT: standard( node ) };
  let csn = {};
  // for UNION, ... ----------------------------------------------------------
  if (node.op.val !== 'subquery') {
    if (node.op.val !== 'unionAll') // XSN TODO: quantifier: 'all'|'distinct'
      csn.op = node.op.val;
    else
      csn.op = 'union', csn.all = true;
  }
  if (node.args) {
    let args = node.args;
    // binary -> n-ary - the while loop should be done in parser (toCdl is
    // currently not prepared)
    while (args[0] && args[0].op && args[0].op.val === node.op.val &&
           !args[0].all === !node.all && args[0].args)
      args = [ ...args[0].args, ...args.slice(1) ]
    if (node.op.val === 'unionAll') // TODO grammar: set DISTINCT - quantifier: 'all'|'distinct'
      csn.all = true;
    csn.args = args.map( query );
  }
  set( 'orderBy', csn, node );
  set( 'limit', csn, node );    // TODO XSN: also offset
  set( '$extra', csn, node );
  return { SET: csn };
}

function columns( xsnColumns, csn, xsn ) {
  let csnColumns = [];
  if (xsnColumns) {
    for (let col of xsnColumns) {
      if (col.val === '*')
        csnColumns.push( '*' );
      else
        addElementAsColumn( col, csnColumns );
    }
  }
  else {                        // null = use elements
    for (let name in xsn.elements)
      addElementAsColumn( xsn.elements[name], csnColumns );
  }
  return csnColumns;
}

function fromOld( node ) {
  // TODO: currently an array in XSN:
  if (node.length > 1)
    return from( { join: 'cross', args: node } );
  else
    return from( node[0] );
}

// XSN TODO: remove '…Outer'
const joinTrans = { leftOuter: 'left', rightOuter: 'right', fullOuter: 'full' };

function from( node ) {
  while (node instanceof Array) // in parentheses
    node = node[0];
  // TODO: CSN: FROM ((SELECT...)) as -> also add 'subquery' op? - Together
  // with []-elimination in FROM... -> normal standard()
  if (node.join) {         // XSN TODO: remove '…Outer'
    // binary (without additions) -> n-ary - the while loop should be done in
    // parser (toCdl is currently not prepared)
    let args = node.args;
    while (node.join === 'cross' && args[0] && args[0].join === node.join && args[0].args)
      args = [ ...args[0].args, ...args.slice(1) ]
    let join = { join: joinTrans[node.join] || node.join, args: node.args.map( from ) };
    set( 'on', join, node );
    return extra( join, node );
  }
  else if (!node.path) {
    return addExplicitAs( query( node ), node.name ); // $extra inside SELECT/SET
  }
  else if (!node._artifact || node._artifact.main) {
    return extra( addExplicitAs( artifactRef( node, null ), node.name ), node );
  }
  else
    return extra( addExplicitAs( artifactRef( node, null ), node.name, function(id) {
      let name = node._artifact.name.absolute;
      let dot  = name.lastIndexOf('.');
      return name.substring( dot+1 ) !== id;
    }), node );
}

function addElementAsColumn( elem, columns ) {
  if (elem.viaAll)              // TODO: elem.$inferred (value '*')
    return;
  // TODO: 'priority' -> '$priority'
  // only list annotations here which a provided directly with definition
  let col = (csn_gensrc) ? annotations( elem, false ) : {};
  // with `client` flavor, assignments are available at the element
  let saved_gensrc = csn_gensrc;
  try {
    csn_gensrc = true;
    set( 'key', col, elem );
    addExplicitAs( Object.assign( col, expression(elem.value) ),
                   elem.name, neqPath( elem.value ) );
    if (elem._typeIsExplicit || elem.redirected) { // TODO XSN: introduce $inferred
      col.cast = {};                               // TODO: what about $extra in cast?
      for (let prop of typeProperties)
        set( prop, col.cast, elem );
    }
  }
  finally {
    csn_gensrc = saved_gensrc;
  }
  // FIXME: Currently toHana requires that an  '_ignore' property on the elem is also visible on the column
  if (elem._ignore) {
    col._ignore = true;
  }
  columns.push( extra( col, elem ) );
}

function orderBy( node ) {      // TODO XSN: flatten (no extra 'value'), part of expression
  let expr = expression( node.value );
  if (node.sort)
    expr.sort = node.sort.val;
  if (node.nulls)
    expr.nulls = node.nulls.val;
  return extra( expr, node );
}

function limit( limit, csn, node ) { // XSN TODO: use same structure, $extra
  let rows = expression( limit );
  return (node.offset)
    ? { rows, offset: expression( node.offset ) }
    : { rows };
}

function $extra( obj, csn ) {
  for (let prop of Object.keys( obj ).sort())
    csn[prop] = obj[prop];
}

function extra( csn, node ) {
  if (node && node.$extra)
    $extra( node.$extra, csn );
  return csn;
}

function addExplicitAs( node, name, implicit ) {
  if (name && (!name.calculated && !name.$inferred || implicit && implicit(name.id) ))
    node.as = name.id;
  return node;
}

function neqPath( ref ) {
  let path = ref && ref.path;
  return path && function( id ) {
    let last = path[ path.length-1 ];
    return (last && last.id) !== id;
  };
}

function compareProperties( a, b ) {
  if (a === b)
    return 0;
  let oa = propertyOrder[a] || propertyOrder[a.charAt()];
  let ob = propertyOrder[b] || propertyOrder[b.charAt()];
  return oa - ob || (a < b ? -1 : 1);
}

function compactQuery( q ) {    // TODO: options
  csn_gensrc = true;
  mode_strict = false;
  return q && query( q );
}

function compactExpr( e ) {     // TODO: options
  csn_gensrc = true;
  mode_strict = false;
  return e && expression( e );
}

function technicalConfig( tc/*, parentCsn, parentArtifact, prop */) {
  let csn = { [tc.backend.val]: { } };
  let be = csn[tc.backend.val];
  if(tc.backend.calculated)
    be.calculated = true;
  if(tc.migration) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: ['migration', value(tc.migration)] });
  }
  if(tc.storeType) {
    be.storeType = value(tc.storeType);
  }
  if(tc.extendedStorage) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: ['using', 'extended', 'storage'] });
  }
  if(tc.group) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    let group = { xpr: [] };
    if(tc.group.name) {
      group.xpr.push('group', 'name', { ref: [tc.group.name.id] });
    }
    if(tc.group.type) {
      group.xpr.push('group', 'type', { ref: [tc.group.type.id] });
    }
    if(tc.group.subType) {
      group.xpr.push('group', 'subtype', { ref: [tc.group.subType.id] });
    }
    be.tableSuffix.push(group);
  }
  if(tc.unloadPrio) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: ['unload', 'priority', expression(tc.unloadPrio)] });
  }
  if(tc.autoMerge) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    let autoMerge = { xpr: [] }
    if(!tc.autoMerge.val)
      autoMerge.xpr.push('no');
    autoMerge.xpr.push('auto', 'merge');
    be.tableSuffix.push(autoMerge);
  }
  if(tc.partition) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: [partition(tc.partition)] });
  }

  if(tc.fzindexes) {
    if(!be.fzindexes)
      be.fzindexes = {};
    tc.fzindexes.forEach(i => {
      i.columns.filter(c => !c._ignore).forEach(c => {
        let stream = [];
        stream.push('fuzzy', 'search', 'index', 'on');
        if(i.fuzzy) {
          stream.push('fuzzy', 'search', 'mode');
          if(i.fuzzy.mode) {
            stream.push(expression(i.fuzzy.mode));
          }
        }
        let name = c.path.map(p=>p.id).join('.');
        if(be.fzindexes[name]) {
          be.fzindexes[name].push(stream);
        }
        else {
          be.fzindexes[name] = [ stream ];
        }
      });
    });
  }

  if(tc.indexes) {
    be.indexes = {};
    for(let idxName in tc.indexes) {
      let idx = tc.indexes[idxName];
      be.indexes[idxName] = (Array.isArray(idx)) ? idx.map(index) : index(idx);
    }
  }
  return csn;

  function index(idx) {
    let stream = [];
    if(idx.kind === 'index') {
      if(idx.unique) {
        stream.push('unique');
      }
      stream.push('index', { ref: [idx.name.id] }, 'on', '(');
      columns(idx.columns, stream);
      stream.push(')');
      if(idx.sort)
        stream.push(value(idx.sort));
    } else if(idx.kind === 'fulltextindex') {
      stream.push('fulltext', 'index', { ref: [idx.name.id] }, 'on', '(');
      columns(idx.columns, stream);
      stream.push(')');
      if(idx.language) {
        if(idx.language.column) {
          stream.push('language', 'column');
          stream.push(expression(idx.language.column));
        }
        if(idx.language.detection) {
          stream.push('language', 'detection', '(');
          let i = 0;
          idx.language.detection.forEach(v => {
            if(i > 0)
              stream.push(',');
            stream.push(expression(v));
            i++;
          });
          stream.push(')');
        }
      }
      if(idx.mimeTypeColumn) {
        stream.push('mime', 'type', 'column', expression(idx.mimeTypeColumn));
      }
      if(idx.fuzzySearchIndex) {
        stream.push('fuzzy', 'search', 'index', value(idx.fuzzySearchIndex));
      }
      if(idx.phraseIndexRatio) {
        stream.push('phrase', 'index', 'ratio', expression(idx.phraseIndexRatio));
      }
      if(idx.configuration) {
        stream.push('configuration', expression(idx.configuration));
      }
      if(idx.textAnalysis) {
        stream.push('text', 'analysis', value(idx.textAnalysis));
      }
      if(idx.searchOnly) {
        stream.push('search', 'only', value(idx.searchOnly));
      }
      if(idx.fastPreprocess) {
        stream.push('fast', 'preprocess', value(idx.fastPreprocess));
      }
      if(idx.mimeType) {
        stream.push('mime', 'type', expression(idx.mimeType));
      }
      if(idx.tokenSeparators) {
        stream.push('token', 'separators', expression(idx.tokenSeparators));
      }
      if(idx.textMining) {
        if(idx.textMining.state) {
          stream.push('text', 'mining', value(idx.textMining.state));
        }
        if(idx.textMining.config) {
          stream.push('text', 'mining', 'configuration', expression(idx.textMining.config));
        }
        if(idx.textMining.overlay) {
          stream.push('text', 'mining', 'configuration', 'overlay', expression(idx.textMining.overlay));
        }
      }
      if(idx.changeTracking) {
        let ct = idx.changeTracking;
        stream.push(value(ct.mode));
        if(ct.asyncSpec) {
          let asp = ct.asyncSpec;
          stream.push('flush');
          if(asp.queue) {
            stream.push(value(asp.queue));
          }
          if(asp.minutes) {
            stream.push('every', expression(asp.minutes), 'minutes');
            if(asp.documents) {
              stream.push('or');
            }
          }
          if(asp.documents) {
            stream.push('after', expression(asp.documents), 'documents');
          }
        }
      }
    }
    return stream;
  }

  function partition(p) {
    let stream = [];
    let i = 0;
    p.specs.forEach(s => {
      if(i == 0)
        stream.push('partition', 'by', ...s.scheme.val.split(' '));
      else
        stream.push(',', ...s.scheme.val.split(' '));
      spec(s);
      i++;
    });
    if(p.wpoac) {
      stream.push('with', 'partitioning', 'on', 'any', 'columns', value(p.wpoac));
    }
    return stream;

    function spec(s) {
      if(s.columns) {
        stream.push('(');
        columns(s.columns, stream);
        stream.push(')');
      }
      if(s.partitions) {
        stream.push('partitions', value(s.partitions));
      }
      if(s.ranges) {
        stream.push('(');
        let oppStore = (s.ranges[0].store === 'default' ? 'extended' : 'default');
        let delimiter = false;
        s.ranges.forEach(r => {
          if(r.store != oppStore) {
            if(s.withStorageSpec) {
              if(delimiter) {
                stream.push(')');
              }
              stream.push('using', r.store, 'storage', '(');
            }
            delimiter = false;
            oppStore = r.store;
          }
          if(delimiter) {
            stream.push(',');
          }
          stream.push('partition');
          if(r.others) {
            stream.push('others');
          }

          if(r.min && !r.max) {
            stream.push('value', '=');
          }
          if(r.min) {
            stream.push(expression(r.min));
          }

          if(r.isCurrent) {
            stream.push('is', 'current');
          }
          if(r.min && r.max) {
            stream.push('<=', 'values', '<', expression(r.max));
          }
          delimiter = true;
        });
        if(s.withStorageSpec) {
          stream.push(')');
        }
        stream.push(')');
      }
    }
  }

  function columns(arr, stream) {
    let i = 0;
    arr.filter(c=>!c._ignore).forEach(c => {
      if(i > 0)
        stream.push(',');
      if(c.unit)
        stream.push({func: value(c.unit), args: [expression(c)]});
      else
        stream.push(expression(c));
      if(c.sort)
        stream.push(value(c.sort));
      i++;
    });
  }
}

function getCompilerVersion() {
  return require('../../package.json').version;
}

function setMetaProperty( csn, model ) {
  csn.meta = model.meta || {};
  csn.meta.creator = 'CDS Compiler v' + getCompilerVersion();
}

// 0.2 - pre-release version
function setCsnVersion( csn ) {
  csn.$version = "0.2"
}

module.exports = { compactModel, compactQuery, compactExpr };
