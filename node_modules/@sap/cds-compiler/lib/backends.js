'use strict';

// API functions for backends (i.e. functions that take a compiled
// augmented CSN and generate something from it)

const csnToSwagger = require('./render/toSwagger');
const { transformForHana } = require('./transform/forHana');
const { compact, compactSorted } = require('./json/compactor')
const { compactModel } = require('./json/to-csn')
const { toCdsSource } = require('./render/toCdl');
const { toSqlDdl } = require('./render/toSql');
const { toRenameDdl } = require('./render/toRename');
const { transform4odata, getServiceNames } = require('./transform/forOdata');
const csn2edm = require('./edm/csn2edm');
const { mergeOptions }  = require('./model/modelUtils');
const { transformTntExtensions } = require('./transform/tntSpecific');
const alerts = require('./base/alerts');
const { setProp } = require('./base/model');
var { CompilationError, sortMessages } = require('./base/messages');
const { createOptionProcessor } = require('./base/optionProcessor');

// This option processor is used both by the command line parser (to translate cmd line options
// into an options object) and by the API functions (to verify options)
let optionProcessor = createOptionProcessor();

// General options
// FIXME: Since they mainly affect the compiler, they could also live near main.compile
optionProcessor
  .option('-h, --help')
  .option('-v, --version')
  .option('-w, --warning <level>', ['0', '1', '2'])
  .option('    --show-message-id')
  .option('-o, --out <dir>')
  .option('-l, --lint-mode')
  .option('    --fuzzy-csn-error')
  .option('    --trace-parser')
  .option('    --trace-parser-amb')
  .option('    --trace-fs')
  .option('-R, --raw-output')
  .option('    --beta-mode')
  .option('    --new-csn')
  .option('    --new-redirect-impl')
  .option('    --assoc-on-rewrite')
  .option('    --hana-flavor')
  .option('    --parse-only')
  .option('    --test-mode')
  .option('    --tnt-flavor')
  .help(`
  Usage: cdsc <command> [options] <file...>

  Compile a CDS model given from input <file...>s and generate results according to <command>.
  Input files may be CDS source files (.cds), CSN model files (.json) or pre-processed ODATA
  annotation XML files (.xml). Output depends on <command>, see below. If no command is given,
  "toCsn" is used by default.

  Use "cdsc <command> --help" to get more detailed help for each command.

  General options
   -h, --help               Show this help text
   -v, --version            Display version number and exit
   -w, --warning <level>    Show warnings up to <level>
                              0: Error
                              1: Warnings
                              2: (default) Info
       --show-message-id    Show message ID in error, warning and info messages
   -o, --out <dir>          Place generated files in directory <dir>, default is "-" for <stdout>
   -l, --lint-mode          Generate nothing, just produce single-file error messages if any (for
                            use by editors)
       --fuzzy-csn-error    Report free-style CSN properties as errors
       --                   Indicate the end of options (helpful if source names start with "-")

  Diagnostic options
       --trace-parser       Trace parser
       --trace-parser-amb   Trace parser ambiguities
       --trace-fs           Trace file system access caused by "using from"

  Internal options (for testing only, may be changed/removed at any time)
   -R, --raw-output         Write raw augmented CSN and error output to <stdout>
       --beta-mode          Enable unsupported, incomplete (beta) features
       --new-csn            Produce new-style CSN (preview of planned future CSN format)
       --new-redirect-impl  (internal) Use new implementation of implicit redirection
       --assoc-on-rewrite   (internal) Rewrite ON conditions and keys specification for
                            associations and compositions, requires --new-redirect-impl
       --hana-flavor        Compile with backward compatibility for HANA CDS (incomplete)
       --parse-only         Stop compilation after parsing and write result to <stdout>
       --test-mode          Produce extra-stable output for automated tests (normalize filenames
                            in errors, sort properties in CSN, omit version in CSN)

  Backward compatibility options (deprecated, do not use)
       --tnt-flavor         Compile with backward compatibility for the "TNT" project

  Commands
    H, toHana [options] <file...>     Generate HANA CDS source files
    O, toOdata [options] <file...>    Generate ODATA metadata and annotations
    C, toCdl <file...>                Generate CDS source files
    S, toSwagger [options] <file...>  Generate Swagger (OpenAPI) JSON
    Q, toSql [options] <file...>      Generate SQL DDL statements
       toCsn [options] <file...>      (default) Generate original model as CSN
       toTntSpecificOutput <file...>  (internal) Generate TNT-specific post-processed CSN
       toRename [options] <file...>   (internal) Generate SQL DDL rename statements
`);

// ----------- toHana -----------
optionProcessor.command('H, toHana')
  .option('-h, --help')
  .option('-n, --names <style>', ['plain', 'quoted', 'hdbcds'])
  .option('-a, --associations <proc>', ['assocs', 'joins'])
  .option('-s, --src')
  .option('-c, --csn')
  .help(`
  Usage: cdsc toHana [options] <file...>

  Generate HANA CDS source files, or CSN.

  Options
   -h, --help                 Show this help text
   -n, --names <style>        Naming style for generated entity and element names:
                                plain  : (default) Produce HANA entity and element names in
                                         uppercase and flattened with underscores. Do not generate
                                         structured types.
                                quoted : Produce HANA entity and element names in original case as
                                         in CDL. Keep nested contexts (resulting in entity names
                                         with dots), but flatten element names with underscores.
                                         Generate structured types, too.
                                hdbcds : Produce HANA entity end element names as HANA CDS would
                                         generate them from the same CDS source (like "quoted", but
                                         using element names with dots).
   -a, --associations <proc>  Processing of associations:
                                assocs : (default) Keep associations in HANA CDS as far as possible
                                joins  : Transform associations to joins
   -s, --src                  (default) Generate HANA CDS source files "<artifact>.hdbcds"
   -c, --csn                  Generate "hana_csn.json" with HANA-preprocessed model
`);

// Transform an augmented CSN 'model' into HANA-compatible CDS source.
// The following options control what is actually generated (see help above):
//   options : {
//     toHana.names
//     toHana.associations
//     toHana.src
//     toHana.csn
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toHana.names' is not provided, 'quoted' is used.
// If 'toHana.associations' is not provided, 'assocs' is used.
// If neither 'toHana.src' nor 'toHana.csn' are provided, the default is to generate only HANA CDS
// source files.
// If all provided options are part of 'toHana', the 'toHana' wrapper can be omitted.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model
//     _augmentedCsn     : (subject to change): the augmented CSN model
//     hdbcds            : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : the HANA CDS source string of the artifact 'X'. Please note that the
//                         name of 'X' may contain characters that are not legal for filenames on
//                         all operating systems (e.g. ':', '\' or '/').
//                         X reflects the naming policy set by toHana.names
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toHana(model, options) {
  // Optional wrapper?
  if (options && !options.toHana) {
    options = { toHana : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toHana : getDefaultBackendOptions().toHana }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toHana.src && !options.toHana.csn) {
    options.toHana.src = true;
  }

  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  const { warning, signal } = alerts(model);
  if (options.toHana.names == 'flat') {
    signal(warning`Option "{ toHana.names: 'flat' }" is deprecated, use "{ toHana.names: 'plain' }" instead`);
    options.toHana.names = 'plain';
  }
  else if (options.toHana.names == 'deep') {
    signal(warning`Option "{ toHana.names: 'deep' }" is deprecated, use "{ toHana.names: 'quoted' }" instead`);
    options.toHana.names = 'quoted';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toHana').map(complaint => signal(warning`${complaint}`));

  // Special case: For naming variant 'hdbcds' in combination with 'toHana' (and only there!), 'forHana'
  // must leave namespaces, structs and associations alone.
  if (options.toHana.names == 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true, keepStructsAssocs: true } });
  }

  // Prepare model for HANA (transferring the options to forHana, and setting 'dialect' to 'hana', because 'toHana' is only used for that)
  let forHanaAugmented = transformForHana(model, mergeOptions(options, { forHana: { dialect: 'hana' } }, { forHana : options.toHana } ));

  // Assemble result
  let result = {};
  if (options.toHana.src) {
    result.hdbcds = toCdsSource(forHanaAugmented);
  }
  if (options.toHana.csn) {
    result._augmentedCsn = forHanaAugmented;
    result.csn = options.newCsn ? compactModel(forHanaAugmented) : compactSorted(forHanaAugmented);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaAugmented.messages && forHanaAugmented.messages.length > 0) {
    result.messages = forHanaAugmented.messages;
  }
  return result;
}

// ----------- toOdata -----------

optionProcessor.command('O, toOdata')
  .option('-h, --help')
  .option('-v, --version <version>', ['v2', 'v4'])
  .option('-x, --xml')
  .option('-j, --json')
  .option('    --separate')
  .option('    --combined')
  .option('-c, --csn')
  .option('-n, --names <style>', ['plain', 'quoted', 'hdbcds'])
  .help(`
  Usage: cdsc toOdata [options] <file...>

  Generate ODATA metadata and annotations, or CSN.

  Options
   -h, --help               Show this help text
   -v, --version <version>  ODATA version
                              v2: (default) ODATA V2
                              v4: ODATA V4
   -x, --xml                (default) Generate XML output (separate or combined)
   -j, --json               Generate JSON output as "<svc>.json" (not available for v2)
       --separate           Generate "<svc>_metadata.xml" and "<svc>_annotations.xml"
       --combined           (default) Generate "<svc>.xml"
   -c, --csn                Generate "odata_csn.json" with ODATA-preprocessed model
   -n, --names <style>      Annotate artifacts and elements with "@cds.persistence.name", which is
                            the corresponding database name (see "--names" for "toHana or "toSql")
                              plain   : (default) Names in uppercase and flattened with underscores
                              quoted  : Names in original case as in CDL. Entity names with dots,
                                        but element names flattened with underscores
                              hdbcds  : Names as HANA CDS would generate them from the same CDS
                                        source (like "quoted", but using element names with dots)
`);

// Generate ODATA for augmented CSN `model` using `options`.
// Before anything is generated, the following transformations are applied to 'model':
// FIXME: Verify that this is still correct
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked.
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// The following options control what is actually generated (see help above):
//   options : {
//     toOdata.version
//     toOdata.xml
//     toOdata.json
//     toOdata.separate
//     toOdata.combined
//     toOdata.csn
//     toOdata.names
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toOdata.version' is not provided, 'v4' is used.
// If neither 'toOdata.xml' nor 'toOdata.json' nor 'toOdata.csn' are provided, the default is
// to generate only XML output. If neither 'toOdata.separate' nor 'toOdata.combined' are provided,
// the default is to generate only combined XML output.
// If all provided options are part of 'toOdata', the 'toOdata' wrapper can be omitted.
//
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model including all services
//     _augmentedCsn     : (subject to change): the augmented CSN model including all services
//     services          : a dictionary of service names, containing for each name:
//       <servicename> : {
//         annotations   : an XML string with EDMX annotations for service 'svc'
//         metadata      : an XML string with EDMX metadata for service 'svc'
//         combined      : an XML string with both EDMX metadata and annotations for service 'svc'
//         metadata_json : a JSON object (not a string!) with EDM metadata for service 'svc'
//       }
//     messages          : an array of strings with warnings (if any)
//   }
// If 'model' does not contain any services, 'csn' will still contain the transformed model, but
// 'services' will be an empty dictionary.
//
// Throws a CompilationError on errors.
function toOdata(model, options) {
  const { error, warning, signal } = alerts(model);
  // Optional wrapper?
  if (options && !options.toOdata) {
    options = { toOdata : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toOdata : getDefaultBackendOptions().toOdata }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toOdata.xml && !options.toOdata.json && !options.toOdata.csn) {
    options.toOdata.xml = true;
  }
  if (!options.toOdata.separate && !options.toOdata.combined) {
    options.toOdata.combined = true;
  }

  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  if (options.toOdata.names == 'flat') {
    signal(warning`Option "{ toOdata.names: 'flat' }" is deprecated, use "{ toOdata.names: 'plain' }" instead`);
    options.toOdata.names = 'plain';
  }
  else if (options.toOdata.names == 'deep') {
    signal(warning`Option "{ toOdata.names: 'deep' }" is deprecated, use "{ toOdata.names: 'quoted' }" instead`);
    options.toOdata.names = 'deep';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toOdata').map(complaint => signal(warning`${complaint}`));

  // Perform extra-magic for TNT if requested
  if (model.options.tntFlavor) {
    model = transformTntExtensions(model);
  }

  // Prepare model for ODATA processing
  let forOdataAugmented = transform4odata(model, options);

  // Assemble result object
  let result = {
    services: Object.create(null),
    messages: model.messages,
  }
  if (options.toOdata.csn) {
    // TODO: make compactSortedJson the default
    result.csn = options.newCsn ? compactModel(forOdataAugmented)
                                : (options.testMode ? compactSorted(forOdataAugmented) : compact(forOdataAugmented));
    result._augmentedCsn = forOdataAugmented;
  }

  // Create annotations and metadata once per service
  if (options.toOdata.xml || options.toOdata.json) {
    // Compact the model
    let compactedModel = compactModel(forOdataAugmented);
    setProp(compactedModel, 'messages', forOdataAugmented.messages);
    for (let serviceName of getServiceNames(model))
    {
      // FIXME: Unify handling of version and tntFlavor (use original options)
      let l_edm = csn2edm(compactedModel, serviceName, options);

      result.services[serviceName] = {};
      if (options.toOdata.xml) {
        if (options.toOdata.separate) {
          result.services[serviceName].annotations = l_edm.toXML('annotations');
          result.services[serviceName].metadata = l_edm.toXML('metadata');
        }
        if (options.toOdata.combined) {
          result.services[serviceName].combined = l_edm.toXML('all');
        }
      }
      if (options.toOdata.json) {
        // JSON output is not available for ODATA V2
        if (options.toOdata.version == 'v2') {
          signal(error`ODATA JSON output is not available for ODATA V2`);
        }
        // FIXME: Why only metadata_json - isn't this rather a 'combined_json' ? If so, rename it!
        result.services[serviceName].metadata_json = l_edm.toJSON();
      }
    }
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forOdataAugmented.messages && forOdataAugmented.messages.length > 0) {
    result.messages = forOdataAugmented.messages;
  }
  return result;
}

// Generate edmx for given 'service' based on 'csn' (new-style compact, already prepared for OData)
// using 'options'
function preparedCsnToEdmx(csn, service, options) {
  // Merge options with those from model
  options = mergeOptions(csn.options, options);
  let edmx = csn2edm(csn, service, options).toXML('all');
  return edmx;
}

// Generate edm-json for given 'service' based on 'csn' (new-style compact, already prepared for OData)
// using 'options'
function preparedCsnToEdm(csn, service, options) {
  // Merge options with those from model, override OData version as edm json is always v4
  options = mergeOptions(csn.options, options, { toOdata : { version : 'v4' }});
  let edmj = csn2edm(csn, service, options).toJSON();
  return edmj;
}

// ----------- toCdl -----------

optionProcessor.command('C, toCdl')
  .option('-h, --help')
  .help(`
  Usage: cdsc toCdl [options] <file...>

  Generate CDS source files "<artifact>.cds".

  Options
   -h, --help      Show this help text
`);

// Generate CDS source text for augmented CSN model 'model'.
// The following options control what is actually generated:
//   options : {
//     FIXME: This option should be removed and something like 'toCdl.dialect: 'hana' be
//            used instead.
//     toHana : if true, HANA-specific source dialect is generated (affects e.g. the
//              translation of '$self.foo' in paths and ::-ish namespace declarations)
//   }
// One source is created per top-level artifact.
// Return a dictionary of top-level artifacts
// by their names, like this:
// { "foo" : "using XY; context foo {...};",
//   "bar::wiz" : "namespace bar::; entity wiz {...};"
// }
// Throws a CompilationError on errors.
function toCdl(model, options) {
  const { warning, signal } = alerts(model);
  // Merge options with those from model
  options = mergeOptions({ toCdl : true }, model.options, options);
  // Verify options
  optionProcessor.verifyOptions(options, 'toCdl').map(complaint => signal(warning`${complaint}`));
  return toCdsSource(model, options);
}

// ----------- toSwagger -----------

optionProcessor.command('S, toSwagger')
  .option('-h, --help')
  .option('-j, --json')
  .option('-c, --csn')
  .help(`
  Usage: cdsc toSwagger [options] <file...>

  Generate Swagger (OpenAPI) JSON, or CSN

  Options
   -h, --help  Show this help text
   -j, --json  (default) Generate OpenAPI JSON output for each service as "<svc>_swagger.json
   -c, --csn   Generate "swagger_csn.json" with Swagger-preprocessed model
`);

// Generate OpenAPI JSON version 3 for the augmented CSN 'model'.
// The following options control what is actually generated:
//   options : {
//     toSwagger.json      : if true, generate OpenAPI JSON output
//     toSwagger.csn       : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If neither 'toSwagger.json' nor 'toSwagger.csn' are provided, the default is to generate
// only OpenAPI JSON.
// If all provided options are part of 'toSwagger', the 'toSwagger' wrapper can be omitted.
// One OpenAPI JSON object is created per service.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result: {
//     csn               : the (compact) transformed CSN model including all services
//     _augmentedCsn     : (subject to change): the augmented CSN model including all services
//     services: {
//       <servicename>: {
//         openapi: '3.0.0',
//         info: { ... },
//         paths: { ...},
//         components: {
//           schemas: { ... }
//         }
//       }
//     }
//   }
//
// Throws a CompilationError on errors.
function toSwagger(model, options) {
  const { warning, signal } = alerts(model);
  // Optional wrapper?
  if (options && !options.toSwagger) {
    options = { toSwagger : options };
  }
  // Merge options with those from model
  options = mergeOptions(model.options, options);
  // If neither 'json' nor 'csn' is specified as output option, produce 'json'
  if (!options.toSwagger || (!options.toSwagger.json && !options.toSwagger.csn)) {
    options = mergeOptions({ toSwagger: { json: true } }, options);
  }
  // Verify options
  optionProcessor.verifyOptions(options, 'toSwagger').map(complaint => signal(warning`${complaint}`));
  // Actual implementation
  return csnToSwagger(model, options);
}

// ----------- toSql -----------

optionProcessor.command('Q, toSql')
  .option('-h, --help')
  .option('-n, --names <style>', ['plain', 'quoted', 'hdbcds'])
  .option('-a, --associations <proc>', ['assocs', 'joins'])
  .option('-d, --dialect <dialect>', ['hana', 'sqlite'])
  .option('-u, --user <user>')
  .option('-l, --locale <locale>')
  .option('-s, --src')
  .option('-c, --csn')
.help(`
  Usage: cdsc toSql [options] <file...>

  Generate SQL DDL statements to create tables and views, or CSN

  Options
   -h, --help                 Show this help text
   -n, --names <style>        Naming style for generated entity and element names:
                                plain  : (default) Produce SQL table and view names in uppercase
                                         and flattened with underscores (no quotes required)
                                quoted : Produce SQL table and view names in original case as in
                                         CDL (with dots), but flatten element names with
                                         underscores (requires quotes). Can only be used in
                                         combination with "hana" dialect.
                                hdbcds : Produce SQL table, view and column names as HANA CDS would
                                         generate them from the same CDS source (like "quoted", but
                                         using element names with dots). Can only be used in
                                         combination with "hana" dialect.
   -a, --associations <proc>  Processing of associations:
                                assocs : Keep associations as far as possible. Note that some
                                         associations (e.g. those defined in a mixin and used in
                                         the same view) must always be replaced by joins because of
                                         SQL limitations, and that "assocs" should only be used
                                         with "hana" dialect.
                                joins  : (default) Transform associations to joins
   -d, --dialect <dialect>    SQL dialect to be generated:
                                hana   : SQL with HANA specific language features
                                sqlite : (default) Common SQL for sqlite
   -u, --user <user>          Value for the "$user" variable in "sqlite" dialect
   -l, --locale <locale>      Value for the "$user.locale" variable in "sqlite" dialect
   -s, --src                  (default) Generate SQL source files as "<artifact>.sql"
   -c, --csn                  Generate "sql_csn.json" with SQL-preprocessed model
`);

// Generate SQL DDL statements for augmented CSN 'model'.
// The following options control what is actually generated (see help above):
//   options : {
//     toSql.names
//     toSql.associations
//     toSql.dialect
//     toSql.user.id
//     toSql.user.locale
//     toSql.src
//     toSql.csn
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If neither 'toSql.src' nor 'toSql.csn' are provided, the default is to generate only SQL DDL
// source files.
// If all provided options are part of 'toSql', the 'toSql' wrapper can be omitted.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model
//     _augmentedCsn     : (subject to change): the augmented CSN model
//     sql               : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : a string with SQL DDL statements for artifact 'X', terminated with ';'.
//                         Please note that the name of 'X' may contain characters that are not
//                         legal for filenames on all operating systems (e.g. ':', '\' or '/').
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toSql(model, options) {
  const { warning, error, signal } = alerts(model);

  // when toSql is invoked via the CLI - toSql options are under model.options
  // ensure the desired format of the user option
  if (model.options && model.options.toSql &&(model.options.toSql.user || model.options.toSql.locale)) {
    transforUserOption(model.options.toSql);
  }

  // Optional wrapper?
  if (options && !options.toSql) {
    options = { toSql : options };
  }

  // when the API funtion is used directly - toSql options are in options
  // ensure the desired format of the user option
  if (options && (options.toSql.user || options.toSql.locale)){
    transforUserOption(options.toSql);
  }

  // Provide defaults and merge options with those from model
  options = mergeOptions({ toSql : getDefaultBackendOptions().toSql }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toSql.src && !options.toSql.csn) {
    options.toSql.src = true;
  }

  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  if (options.toSql.names == 'flat') {
    signal(warning`Option "{ toSql.names: 'flat' }" is deprecated, use "{ toSql.names: 'plain' }" instead`);
    options.toSql.names = 'plain';
  }
  else if (options.toSql.names == 'deep') {
    signal(warning`Option "{ toSql.names: 'deep' }" is deprecated, use "{ toSql.names: 'quoted' }" instead`);
    options.toSql.names = 'quoted';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toSql').map(complaint => signal(warning`${complaint}`));

  // FIXME: Currently, '--to-sql' implies transformation for HANA (transferring the options to forHana)
  let forHanaOptions = options.toSql;

  // Special case: For naming variant 'hdbcds' in combination with 'toSql', 'forHana' must leave
  // namespaces alone (but must still flatten structs because we need the leaf element names).
  if (options.toSql.names == 'hdbcds') {
    forHanaOptions.keepNamespaces = true;
  }

  // It doesn't make much sense to use 'sqlite' dialect with associations
  if (options.toSql.dialect == 'sqlite' && options.toSql.associations != 'joins') {
    signal(warning`Option "{ toSql.dialect: 'sqlite' }" should always be combined with "{ toSql.assocs: 'joins' }"`);
  }

  // CDXCORE-465, 'quoted' and 'hdbcds' are to be used in combination with dialect 'hana' only
  if(options.toSql.dialect != 'hana' && ['quoted', 'hdbcds'].includes(options.toSql.names)) {
    signal(error`Option "{ toSql.dialect: '${options.toSql.dialect}' }" cannot be combined with "{ toSql.names: '${options.toSql.names}' }"`);
  }

  // Because (even HANA) SQL cannot deal with associations in mixins that are published in the same view,
  // the association processing must at least be 'mixin', even if callers specified 'assocs'
  if (forHanaOptions.associations == 'assocs') {
    forHanaOptions.associations = 'mixin';
  }

  // FIXME: Should not be necessary
  forHanaOptions.alwaysResolveDerivedTypes = true;

  let forSqlAugmented = transformForHana(model, mergeOptions(options, { forHana : forHanaOptions } ));

  // Assemble result
  let result = {};
  if (options.toSql.src) {
    result = toSqlDdl(forSqlAugmented);
  }
  if (options.toSql.csn) {
    result._augmentedCsn = forSqlAugmented;
    result.csn = options.newCsn ? compactModel(forSqlAugmented) : compactSorted(forSqlAugmented);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forSqlAugmented.messages && forSqlAugmented.messages.length > 0) {
    result.messages = forSqlAugmented.messages;
  }
  return result;

  // If among the options user, user.id or user.locale are specified via the CLI or
  // via the API, then ensure that at the end there is a user option, which is an object and has(have)
  // "id" and/or "locale" prop(s)
  function transforUserOption(options) {
    // move the user option value under user.id if specified as a string
    if (options.user && typeof options.user === 'string' || options.user instanceof String) {
      options.user = { id: options.user };
    }

    // move the locale option(if provided) under user.locale
    if (options.locale) {
      options.user
        ? Object.assign(options.user, { locale: options.locale })
        : options.user = { locale: options.locale };
      delete options.locale;
    }

  }
}

// ----------- toRename -----------

optionProcessor.command('toRename')
  .option('-h, --help')
  .option('-n, --names <style>', ['quoted', 'hdbcds'])
  .help(`
  Usage: cdsc toRename [options] <file...>

  (internal, subject to change): Generate SQL DDL statements to "rename_<artifact>.sql" that
  rename existing tables and their columns so that they match the result of "toHana" or "toSql"
  with the "--names plain" option.

  Options
   -h, --help           Display this help text
   -n, --names <style>  Assume existing tables were generated with "--names <style>":
                          quoted   : Assume existing SQL tables and views were named in original
                                     case as in CDL (with dots), but column names were flattened
                                     with underscores (e.g. resulting from "toHana --names quoted")
                          hdbcds   : (default) Assume existing SQL tables, views and columns were
                                     generated by HANA CDS from the same CDS source (or resulting
                                     from "toHana --names hdbcds")
`);

// FIXME: Not yet supported, only in beta mode
// Generate SQL DDL rename statements for a migration, renaming existing tables and their
// columns so that they match the result of "toHana" or "toSql" with the "{ names: 'plain' }
// option.
// Expects the naming convention of the existing tables to be either 'quoted' or 'hdbcds' (default).
// The following options control what is actually generated (see help above):
//   options : {
//     toRename.names
//   }
// Return a dictionary of top-level artifacts by their names, like this:
// { "foo" : "RENAME TABLE \"foo\" ...",
//   "bar::wiz" : "RENAME VIEW \"bar::wiz\" ..."
// }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If all provided options are part of 'toRename', the 'toRename' wrapper can be omitted.
// The result object contains the generation results as follows:
//   result : {
//     rename            : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : a string with SQL DDL statements for artifact 'X', terminated with ';'.
//                         Please note that the name of 'X' may contain characters that are not
//                         legal for filenames on all operating systems (e.g. ':', '\' or '/').
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toRename(model, options) {
  const { error, warning, signal } = alerts(model);

  // Optional wrapper?
  if (options && !options.toRename) {
    options = { toRename : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toRename : getDefaultBackendOptions().toRename }, model.options, options);

  // Backward compatibility for old naming modes
  // FIXME: Remove after a few releases
  if (options.toRename.names == 'flat') {
    signal(warning`Option "{ toRename.names: 'flat' }" is deprecated, use "{ toRename.names: 'plain' }" instead`);
    options.toRename.names = 'plain';
  }
  else if (options.toRename.names == 'deep') {
    signal(warning`Option "{ toRename.names: 'deep' }" is deprecated, use "{ toRename.names: 'quoted' }" instead`);
    options.toRename.names = 'quoted';
  }

  // Verify options
  optionProcessor.verifyOptions(options, 'toRename').map(complaint => signal(warning`${complaint}`));

  // Requires beta mode
  if (!options.betaMode) {
    signal(error`Generation of SQL rename statements is not supported yet (only in beta mode)`);
  }

  // Special case: For naming variant 'hdbcds' in combination with 'toRename', 'forHana' must leave
  // namespaces alone (but must still flatten structs because we need the leaf element names).
  if (options.toRename.names == 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true } });
  }

  // FIXME: Currently, '--to-rename' implies transformation for HANA (transferring the options to forHana)
  let forHanaAugmented = transformForHana(model, mergeOptions(options, { forHana : options.toRename } ));

  // Assemble result
  let result = {
    rename : toRenameDdl(forHanaAugmented),
  };

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaAugmented.messages && forHanaAugmented.messages.length > 0) {
    result.messages = forHanaAugmented.messages;
  }
  return result;
}

// ----------- toCsn -----------

optionProcessor.command('toCsn')
  .option('-h, --help')
  .option('-f, --flavor <flavor>', ['client', 'gensrc'])
  .help(`
  Usage: cdsc toCsn [options] <file...>

  Generate original model as CSN to "csn.json"

  Options
   -h, --help             Show this help text
   -f, --flavor <flavor>  Generate CSN in one of two flavors:
                            client  : (default) Standard CSN consumable by clients and backends
                            gensrc  : CSN specifically for use as a source, e.g. for
                                      combination with additional "extend" or "annotate"
                                      statements, but not suitable for consumption by clients or
                                      backends
`);

// Generate compact CSN for augmented CSN 'model'
// The following options control what is actually generated:
//   options : {
//     testMode     : if true, the result is extra-stable for automated tests (sorted, no 'version')
//     newCsn       : if true, CSN is returned in the (well-defined) new format '0.1.99' planned for future versions
//                    (default is the old format '0.1.0')
//     toCsn.gensrc : if true, the result CSN is only suitable for use as a source, e.g. for combination with
//                    additional extend/annotate statements, but not for consumption by clients or backends
//                    (default is to produce 'client' CSN with all properties propagated and inferred as required
//                    by consumers and backends)
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// Throws a CompilationError on errors.
function toCsn(model, options) {
  const { error, warning, signal } = alerts(model);
  // Can't have an optional wrapper here because 'testMode' and 'newCsn' are global options
  
  // Merge options with those from model
  options = mergeOptions({ toCsn : true }, model.options, options);

  // Verify options
  optionProcessor.verifyOptions(options, 'toCsn').map(complaint => signal(warning`${complaint}`));

  if (options.toCsn.gensrc && !options.newCsn) {
    signal(error`CSN in "gensrc" flavor can only be generated as new-style CSN (option "newCsn" required)`);
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return options.newCsn ? compactModel(model)
                        : (options.testMode ? compactSorted(model) : compact(model));
}

// Return a set of options containing the defaults that would be applied by the backends.
// Note that this only contains simple mergeable default values, not conditional defaults
// that depend in any way on other options (e.g. toSql provides 'src' if neither 'src' nor
// 'csn' is given: this is a conditional default).   
function getDefaultBackendOptions() {
  return {
    toHana: {
      names : 'plain',
      associations: 'assocs',
    },
    toOdata: {
      version : 'v4',
    },
    toRename: {
      names: 'hdbcds',
    },
    toSql: {
      names : 'plain',
      associations: 'joins',
      dialect: 'sqlite',
    },
  };
} 

module.exports = {
  optionProcessor,
  toHana,
  toOdata,
  preparedCsnToEdmx,
  preparedCsnToEdm,
  toCdl,
  toSwagger,
  toSql,
  toCsn,
  getDefaultBackendOptions,
  toRename,
}
