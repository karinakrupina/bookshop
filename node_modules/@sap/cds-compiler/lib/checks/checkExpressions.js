'use strict';

const alerts = require('../base/alerts');
const transformUtils = require('../transform/transformUtils');

// Check an expression (or condition) for semantic validity 
function checkExpression(xpr, model) {
  const { error, signal } = alerts(model);
  const { isAssociationOperand, isDollarSelfOperand } = transformUtils.getTransformers(model);

  // We don't do checks on token-stream expressions, only on tree-like ones
  if (xpr.op && xpr.op.val == 'xpr') {
    return;
  }

  // No further checks regarding associations and $self required if this is a backlink-like expression
  // (a comparison of $self with an assoc)
  if (isBinaryDollarSelfComparisonWithAssoc(xpr)) {
    return;
  }

  // Check for illegal argument usage within the expression
  for (let arg of xpr.args || []) {
    // Arg must not be an association and not $self
    if (isAssociationOperand(arg)) {
      signal(error`An association cannot be used as a value in an expression`, arg.location);
    }
    if (isDollarSelfOperand(arg)) {
      signal(error`"$self" can only be used as a value in a comparison to an association`, arg.location);
    }

    // Recurse into argument expression
    checkExpression(arg, model);
  }

  // Return true if 'xpr' is backlink-like expression (a comparison of "$self" with an assoc)
  function isBinaryDollarSelfComparisonWithAssoc(xpr) {
    // Must be an expression with arguments
    if (!xpr.op || !xpr.args) {
      return false;
    }

    // One argument must be "$self" and the other an assoc
    if (xpr.op.val == '=' && xpr.args.length == 2) {
      // Tree-ish expression from the compiler (not augmented)
      return (isAssociationOperand(xpr.args[0]) && isDollarSelfOperand(xpr.args[1])
           || isAssociationOperand(xpr.args[1]) && isDollarSelfOperand(xpr.args[0]));
    }

    // Nothing else qualifies
    return false;
  }
}

module.exports = {
  checkExpression,
}
