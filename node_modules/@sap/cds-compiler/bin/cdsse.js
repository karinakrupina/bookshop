#!/usr/bin/env node

// Very simple command-line interface to LSP-like features for CDS.  We neither
// intend to support all capabilities of a LSP server, nor do we adhere to the
// LSP protocol.  This is just a little playground to optimize the CDS Compiler
// support for the CDS LSP server and to detect potential issues with
// corrupted, incomplete or errorneous CDL sources.
//
// The output could be used directly by some editors, e.g. Emacs.  The
// capabilities supported at the moments is: complete - work in progress.
// Planned are: gotoDefinition, highlight (for syntax highighting).

/* eslint no-console:off */

const commands = {
  complete
}

const fs = require('fs');
const path = require('path');
const compiler = require('../lib/main');

let argv = process.argv;
let cmd = commands[ argv[2] ];
var line = Number.parseInt( argv[3] );
let column = Number.parseInt( argv[4] );
let file = argv[5];
let frel = path.relative( '', file||'' );

if (argv.length > 5 && cmd && line > 0 && column > 0)
  fs.readFile( argv[6] === '-' ? '/dev/stdin' : file, 'utf8', cmd );
else
  usage();

function usage( err ) {
  if (err)
    console.error( 'ERROR:', err.toString() );
  console.error( 'Usage: cdsse complete <line> <col> <file> [-]' );
  process.exitCode = 2;
  return false;
}

function complete( err, buf ) {
  if (err)
    return usage( err );
  let off = offset( buf );
  if (!off)                     // outside buffer range
    return usage();
  if (off.prefix !== off.cursor) { // with keyword/name prefix
    // tokensAt( buf, off.cursor, false ); // list symbolAtCursor
    off.hasId = tokensAt( buf, off.prefix, false );
  }
  else {
    let charBefore = buf[ off.prefix-1 ];
    if ([':', '<', '.', '>', '!', '|', '='].includes( charBefore ))
      // If first of multi-char symbols from 'literalNames' in
      // gen/languageParser, calculate "symbol continuation"
      tokensAt( buf, off.prefix-1, charBefore );
    off.hasId = tokensAt( buf, off.prefix, true );
  }
  if (off.hasId) {
    let src = buf.substring( 0, off.prefix ) + '__NO_SUCH_ID__' + buf.substring( off.cursor );
    let fname = path.resolve( '', file );
    compiler.compile( [file], '', { attachValidNames: true, betaMode: true } , { [fname]: src } )
      .then( ident, ident );
  }
  return true;

  function ident( xsnOrErr ) {
    if (!xsnOrErr.messages && !xsnOrErr.errors)
      return usage( xsnOrErr );
    let vn = messageAt( xsnOrErr, 'validNames', off.prefix ) || Object.create(null);
    // TODO: if there is no such message, use console.log( 'arbitrary identifier' )
    // if we want to avoid that the editor switches to fuzzy completion match
    // against the prefix (not yet done anyway)
    for (let n in vn)
      console.log( n, vn[n].kind );
    return true;
  }
}

function tokensAt( buf, offset, symbol ) {
  let src = buf.substring( 0, offset ) + 'â‰ ' + buf.substring( offset );
  let et = messageAt( compiler.parse( src, frel ), 'expectedTokens', offset ) || [];
  for (let n of et) {
    if (typeof symbol === 'string') {
      if (n.length > 3 && n.charAt() === "'" && n.charAt(1) === symbol)
        console.log( n.slice( 2, -1 ), 'symbolCont' );
    }
    else if (n.charAt() === "'") {
      if (symbol)
        console.log( n.slice( 1, -1 ), 'symbol' );
    }
    else if (/^[A-Z]+$/.test( n )) {
      console.log( n.toLowerCase(), 'keyword' );
    }
  }
  return et.includes( 'Identifier' );
}

function messageAt( model, prop, offset ) {
  let msg = (model.messages||model.errors).find(
    m => m[prop] && m.location.start.offset === offset && m.location.filename === frel );
  return msg && msg[prop];
}

function offset( buf ) {             // for line and column
  // Returns offsets of current position and start of prefix
  let pos = 0;
  for (let l = line-1; l; --l) {
    pos = buf.indexOf( '\n', pos ) + 1;
    if (!pos)
      return false;
  }
  let cursor = pos + column - 1;
  let endsId = /[a-z_0-9$]*$/i.exec( buf.substring( pos, cursor ) );
  return { cursor, prefix: endsId.index + pos };
}
