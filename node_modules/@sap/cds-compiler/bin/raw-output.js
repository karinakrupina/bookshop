// Make internal properties of the augmented CSN visible

const msg = require('../lib/base/messages');

function locationString( loc ) {
  return (typeof loc === 'object' && loc && loc.start)
    ? msg.locationString(loc)
    : (loc === null ? 'null' : typeof loc) + ':' + msg.locationString(loc);
}

function revealInternalProperties( model ) {
  var unique_id = 0;

  var transformers = {
    location: locationString,
    artifacts: artifactDictionary,
    definitions: artifactDictionary,
    elements: (e,n) => (n.self ? artifactDictionary(e) : dictionary(e)),
    columns,
    actions: dictionary,
    params: dictionary,
    enum: dictionary,
    foreignKeys: dictionary,
    exclude: dictionary,
    struct: dictionary,
    queries: n => n.map( revealQuery ),
    $tableAliases: dictionary,
    $navigation: dictionary,
    $combined: artifactDictionary,
    $dictOrderBy: artifactDictionary,
    $layerNumber: n => n,
    $extra: e => e,
    _layerRepresentative: s => s.realname,
    _layerExtends: layerExtends,
    _parent: artifactIdentifier,
    _outer: artifactIdentifier,
    _main: artifactIdentifier,
    _block: artifactIdentifier,
    _artifact: artifactIdentifier,
    _navigation: artifactIdentifier,
    _origTarget: artifactIdentifier,
    _tableAlias: artifactIdentifier,
    _projections: artifactIdentifier, // array
    _redirected: artifactIdentifier, // array
    _entities: artifactIdentifier, // array
    _ancestors: artifactIdentifier, // array
    _descendants: artifactDictionary, // dict of array
    _$queryNode: n => (n.location && { location: locationString( n.location ) }),
    _$next: artifactIdentifier,
    _finalType: artifactIdentifier,
    _leadingQuery: artifactIdentifier,
    _source: artifactIdentifier,
    _extend: (a) => reveal( a, null ),
    _annotate: (a) => reveal( a, null ),
    _deps: dependencyInfo,
    _incomplete: primOrString,
    _shadowed: (a) => reveal( a, null ),
    _status: primOrString,       // is a string anyway
    _service: artifactIdentifier,
    _firstAliasInFrom: artifactIdentifier,
  }
  return reveal( model );

  function artifactIdentifier( node, parent ) {
    if (node instanceof Array)
      return node.map( artifactIdentifier );
    if (!(node instanceof Object))
      return primOrString( node );
    let outer = '';
    if (node._outer) {
      outer = (node._outer.items === node) ? '/items'
            : (node._outer.returns === node) ? '/returns' : '/returns/items';
      node = node._outer;
    }
    if (node === parent)
      return 'this';
    if (node.kind === 'source')
      return 'source:' + quoted( node.filename );
    if (node.kind === '$magicVariables')
      return '$magicVariables';
    if (!node.name)
      return JSON.stringify(node);
    switch (node.kind) {
      case undefined:             // TODO: remove this `returns` property for actions
        return (node._artifact && node._artifact.kind)
          ? artifactIdentifier( node._artifact )
          : JSON.stringify(node.name);
      case 'builtin':
        return '$magicVariables/' + msg.artName(node);
      case 'source':
      case 'using':
        return 'source:' + quoted( node.location && node.location.filename ) +
               '/using:' + quoted( node.name.id )
      default: {
        let kind = (node._main)
            ? node._main.kind
            : (node.kind === 'block')
            ? node._parent && node._parent.kind
            : node.kind;
        return (kind || '<kind>') + ':' + msg.artName( node ) + outer +
               // todo: get rid of $renamed / do the oData renaming late on the CSN
               (node.name.$renamed ? '-original:' + quoted( node.name.$renamed ) : '');
      }
    }
  }

  function quoted( name, undef = '<undefined>' ) {
    return (typeof name === 'number')
      ? name
      : name ? '"' + name.replace( /"/g, '""' ) + '"' : undef;
  }

  function artifactDictionary( node ) {
    if (node == null || typeof node !== 'object' || Object.getPrototypeOf(node)
        || !model.definitions || node === model.definitions )
      return dictionary( node );    // no dictionary or no definitions section
    let dict = Object.create(null);
    for (let name in node) {
      dict[name] = artifactIdentifier( node[name] );
    }
    return dict;
  }

  function dependencyInfo( deps ) {
    if (!(deps instanceof Array))
      return primOrString( deps );
    return deps
      .filter( d => d.location )
      .map( d => artifactIdentifier( d.art ) );
  }

  function layerExtends( dict ) {
    let r = Object.create(null);
    // let proto = Object.getPrototypeOf(dict);
    // if (proto)
    //   r.__proto__ = proto.realname || proto;
    for (let name in dict)
      r[name] = true;
    return r;
  }

  function primOrString( node ) {
    if (node == null || typeof node !== 'object')
      // node instanceof Object would be false for dict
      return node
    if (node instanceof Array)
      return node.map( primOrString );
    if (node instanceof Object)
      return '' + node;
    else
      return '<dict>';
  }

  function columns( nodes ) {
    return nodes.map( c => (c._parent) ? artifactIdentifier( c ) : reveal( c ) );
  }

  function dictionary( node ) {
    return reveal( node, '__proto__' ); 
  }

  function revealQuery( node ) {
    return reveal( node, undefined, undefined, true );
  }

  function reveal( node, protoProp, _array, identifierKind = 'query' ) {
    // warning: 'protoProp' bound via map()
    if (node == null || typeof node !== 'object' )
      // node instanceof Object would be false for dict
      return node
    if (node instanceof Array)
      return node.map( reveal );

    let proto = Object.getPrototypeOf(node);
    if (proto !== null && proto !== Object.prototype)
      return node;
    if (proto && node.kind === identifierKind)
      return artifactIdentifier( node );

    let r = Object.create( proto );
    // property to recognize === objects
    if (proto && node.kind && node.__unique_id__ == null)
      Object.defineProperty( node, '__unique_id__', { value: ++unique_id } );

    for (let prop of Object.getOwnPropertyNames( node )) { // also non-enumerable
      let item = node[prop];
      let func =
          (proto === null || protoProp === null ? reveal : transformers[prop]) ||
          (node.propertyIsEnumerable( prop ) ? reveal : primOrString);
      r[prop] = func( item, node );
    }
    if (proto && protoProp === '__proto__')
      Object.defineProperty( r, protoProp, { enumerable: true, value: '' + proto } );
    return r;
  }
}

module.exports = revealInternalProperties;
