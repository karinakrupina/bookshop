#!/usr/bin/env node

// command line interface to the cds api resp. cds compiler
// Usage: cdsc [options] <file> ...
// Call cdsc --help for a detailed description
// Exit codes are:
//   0   for success
//   1   compilation error
//   2   command line usage error

'use strict';

/* eslint no-console:off */

const compiler = require('../lib/main');
var util = require('util');
var fs = require('fs');
var path = require('path');
var reveal = require('./raw-output');
const { optionProcessor } = require('../lib/backends');

// Note: Instead of throwing ProcessExitError, we would rather just call process.exit(exitCode),
// but that might truncate the output of stdout and stderr, both of which are async (or rather,
// may possibly be async, depending on OS and whether I/O goes to TTY, socket, file, ... sigh)
class ProcessExitError extends Error {
  constructor(exitCode,...args) {
    super(...args);
    this.exitCode = exitCode;
  }
}

// Parse the command line and translate it into options
try {
  let cmdLine = optionProcessor.processCmdLine(process.argv);
  // Deal with '--version' explicitly
  if (cmdLine.options.version) {
    process.stdout.write(compiler.version() + '\n');
    throw new ProcessExitError(0);
  }
  // Deal with '--help' explicitly
  if (cmdLine.command) {
    // Command specific help
    if (cmdLine.options.help || cmdLine.options[cmdLine.command] && cmdLine.options[cmdLine.command].help) {
      displayUsage(null, optionProcessor.commands[cmdLine.command].helpText, 0);
    }
  } else if (cmdLine.options.help) {
    // General help
    displayUsage(null, optionProcessor.helpText, 0);
  }
  // Report complaints if any
  if (cmdLine.cmdErrors.length > 0) {
    // Command specific errors
    displayUsage(cmdLine.cmdErrors, optionProcessor.commands[cmdLine.command].helpText, 2);
  } else if (cmdLine.errors.length > 0) {
    // General errors
    displayUsage(cmdLine.errors, optionProcessor.helpText, 2);
  }

  // Default warning level is 2 (info)
  // FIXME: Is that not set anywhere in the API?
  if (!cmdLine.options.warning) {
    cmdLine.options.warning = 2;
  }
  // Default output goes to stdout
  if (!cmdLine.options.out) {
    cmdLine.options.out = '-';
  }

  // Do the work for the selected command (default 'toCsn'
  executeCommandLine(cmdLine.command || 'toCsn', cmdLine.options, cmdLine.args);
} catch (err) {
  // This whole try/catch is only here because process.exit does not work in combination with
  // stdout/err - see comment at ProcessExitError
  if (err instanceof ProcessExitError) {
    process.exitCode = err.exitCode;
  } else {
    throw err;
  }
}

// Display help text 'helpText' and 'error' (if any), then exit with exit code <code>
function displayUsage(error, helpText, code) {
  // Display non-error output (like help) to stdout
  let out = (code == 0 && !error) ? process.stdout : process.stderr;
  // Display help text first, error at the end (more readable, no scrolling)
  out.write(`${helpText}\n`);
  if (error) {
    if (error instanceof Array) {
      out.write(error.map(error => `cdsc: ERROR: ${error}`).join('\n') + '\n');
    } else {
      out.write(`cdsc: ERROR: ${error}\n`);
    }
  }
  throw new ProcessExitError(code);
}

// Executes a command line that has been translated to 'command' (what to do), 'options' (how) and 'args' (which files)
function executeCommandLine(command, options, args) {
  const normalizeFilename = options.testMode && process.platform === 'win32';
  const messageLevels = { Error: 0, Warning: 1, Info: 2, None: 3 };
  // All messages are put into the message array, even those which should not
  // been displayed (severity 'None')

  // Create output directory if necessary
  if (options.out && options.out != '-' && !fs.existsSync(options.out)) {
    fs.mkdirSync(options.out);
  }

  // Add implementation functions corresponding to commands here
  const commands = {
    toCdl,
    toCsn,
    toHana,
    toOdata,
    toRename,
    toSql,
    toSwagger,
    toTntSpecificOutput,
  }

  if (!commands[command]) {
    throw new Error(`Missing implementation for command ${command}`);
  }
  compiler.compile( args, undefined, options )
          .then( commands[command] )
          .then( displayMessages, displayErrors )
          .catch( catchErrors );

  // Execute the command line option '--to-cdl' and display the results.
  // Return the original model (for chaining)
  function toCdl( model ) {
    let cdlResult = compiler.toCdl(model);
    for (let name in cdlResult) {
      writeToFileOrDisplay(options.out, name + '.cds', cdlResult[name]);
    }
    return model;
  }

  // Execute the command line option '--to-csn' and display the results.
  // Return the original model (for chaining)
  function toCsn( model ) {
    // Result already provided by caller
    displayNamedCsn(model, 'csn', options);
    return model;
  }

  // Execute the command line option '--to-hana' and display the results.
  // Return the original model (for chaining)
  function toHana( model ) {
    let hanaResult = compiler.toHana(model);
    for (let name in hanaResult.hdbcds) {
      writeToFileOrDisplay(options.out, name + '.hdbcds', hanaResult.hdbcds[name]);
    }
    if (hanaResult.csn) {
      displayNamedCsn(hanaResult._augmentedCsn, 'hana_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-odata' and display the results.
  // Return the original model (for chaining)
  function toOdata( model ) {
    let odataResult = compiler.toOdata(model);
    for (let serviceName in odataResult.services) {
      // <service>_metadata.xml (metadata)
      if (odataResult.services[serviceName].metadata) {
        writeToFileOrDisplay(options.out, serviceName + '_metadata.xml', odataResult.services[serviceName].metadata);
      }
      // <service>_annotations.xml (annotations)
      if (odataResult.services[serviceName].annotations) {
        writeToFileOrDisplay(options.out, serviceName + '_annotations.xml', odataResult.services[serviceName].annotations);
      }
      // <service>.xml (combined)
      if (odataResult.services[serviceName].combined) {
        writeToFileOrDisplay(options.out, serviceName + '.xml', odataResult.services[serviceName].combined);
      }
      // <service>.json (metadata_json)
      if (odataResult.services[serviceName].metadata_json) {
        writeToFileOrDisplay(options.out, serviceName + '.json', odataResult.services[serviceName].metadata_json);
      }
    }
    // odata_csn.json resp. odata_csn_raw.txt
    if (odataResult._augmentedCsn) {
      displayNamedCsn(odataResult._augmentedCsn, 'odata_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-rename' and display the results.
  // Return the original model (for chaining)
  function toRename( model ) {
    let renameResult = compiler.toRename(model);
    for (let name in renameResult.rename) {
      writeToFileOrDisplay(options.out, 'rename_' + name + '.sql', renameResult.rename[name] + '\n', true);
    }
    return model;
  }

  // Execute the command line option '--to-sql' and display the results.
  // Return the original model (for chaining)
  function toSql( model ) {
    let sqlResult = compiler.toSql(model);
    for (let name in sqlResult.sql) {
      writeToFileOrDisplay(options.out, name + '.sql', sqlResult.sql[name] + '\n', true);
    }
    if (sqlResult.csn) {
      displayNamedCsn(sqlResult._augmentedCsn, 'sql_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-swagger' and display the results.
  // Return the original model (for chaining)
  function toSwagger( model ) {
    let swaggerResult = compiler.toSwagger(model);
    for (let serviceName in swaggerResult.services || {}) {
      writeToFileOrDisplay(options.out, `${serviceName}_swagger.json`, swaggerResult.services[serviceName], false);
    }
    if (swaggerResult.csn) {
      displayNamedCsn(swaggerResult._augmentedCsn, 'swagger_csn', options);
    }
    return model;
  }

  // Execute the (old) command line option '--tnt-output' and display the results.
  // FIXME: This is the only one that cannot yet be composed from others
  // Return the original model (for chaining)
  function toTntSpecificOutput( model ) {
    // TODO: use async file-system API
    // Perform TNT-specific post-processing
    let result = compiler.toTntSpecificOutput(model, model.options);
    // Write result to files in target directory
    // FIXME: Check in options which parts actually need to be generated
    // Write annotations.xml and metadata.xml only if there is exactly one service
    // FIXME: For backward compatibility only, should be removed soon
    if (result.annotations && result.metadata) {
      writeToFileOrDisplay(model.options.out, 'annotations.xml', result.annotations);
      writeToFileOrDisplay(model.options.out, 'metadata.xml', result.metadata);
    }
    writeToFileOrDisplay(model.options.out, 'csn.json', result.csn);
    for (let serviceName in result.services) {
      writeToFileOrDisplay(model.options.out, serviceName + '_annotations.xml', result.services[serviceName].annotations);
      writeToFileOrDisplay(model.options.out, serviceName + '_metadata.xml', result.services[serviceName].metadata);
    }
    return model;
  }

  // Display error messages in `err` resulting from a compilation.  Also set
  // process.exitCode - process.exit() will force the process to exit as quickly
  // as possible = is problematic, since console.error() might be asynchronous
  function displayErrors (err) {
    if (err instanceof compiler.CompilationError) {
      if (options.rawOutput)
        console.error( util.inspect( reveal( err.model ), false, null ));
      else
        displayMessages( err.model, err.errors );
      process.exitCode = 1;
    }
    else if (err instanceof compiler.InvocationError) {
      console.error( '' );
      for (let sub of err.errors)
        console.error( sub.message );
      console.error( '' );
      process.exitCode = 2;
    }
    else
      throw err;

    err.hasBeenReported = true;
    throw err;
  }

  function displayMessages( model, messages = model.messages ) {
    if (messages instanceof Array)
    {
      for (let msg of messages) {
        if (messageLevels[ msg.severity ] <= options.warning)
          console.error( compiler.messageString( msg, normalizeFilename, !options.showMessageId, !options.testMode ) );
      }
    }
    return model;
  }

  // Write the model 'model' to file '<name>.{json|raw.txt}' in directory 'options.out',
  // or display it to stdout if 'options.out' is '-'.
  // Depending on 'options.rawOutput', the model is either compacted to 'name.json' or
  // written in raw form to '<name>_raw.txt'.
  function displayNamedCsn(model, name, options) {
    if (options.rawOutput) {
      writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(model), false, null), true);
    }
    else {
      writeToFileOrDisplay(options.out, name + '.json', compiler.toCsn(model), true);
    }
  }

  // Write the result 'content' to a file 'filename' in directory 'dir', except if 'dir' is '-'.
  // In that case, display 'content' to stdout.
  // If 'content' is not a string, JSON-stringify it
  // If displaying to stdout, prepend a headline containing 'filename', unless 'omitHeadline' is set.
  // For filenames, illegal characters (slash, backslash, colon) are replaced by '_'.
  function writeToFileOrDisplay(dir, filename, content, omitHeadline = false) {
    filename = filename.replace(/[:/\\]/g, '_');
    if (!(content instanceof String || typeof content == 'string')) {
      content = JSON.stringify(content, null, 2);
    }
    if (dir == '-') {
      if (!omitHeadline) {
        process.stdout.write(`// ------------------- ${filename} -------------------\n`);
      }
      process.stdout.write(`${content}\n`);
      if (!omitHeadline) {
        process.stdout.write(`\n`);
      }
    } else {
      // TODO: We might consider using async file-system API ...
      fs.writeFileSync(path.join(dir, filename), content);
    }
  }

  function catchErrors (err) {
    if (err instanceof Error && err.hasBeenReported)
      return;
    console.error( '' );
    console.error( 'INTERNAL ERROR: %s', err );
    console.error( util.inspect(err, false, null) );
    console.error( '' );
    process.exitCode = 70;
  }
}
