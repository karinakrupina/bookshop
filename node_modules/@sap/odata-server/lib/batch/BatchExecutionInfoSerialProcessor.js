'use strict';

/**
 * The BatchExecutionInfoSerialProcessor executes a chain of batch commands and handles possible errors.
 * The error handling respects the $batch error specifications.
 *
 * 11.7.2 Batch Request Body
 * The body of a batch request is made up of a series of individual requests and change sets, each represented as a
 * distinct MIME part (i.e. separated by the boundary defined in the Content-Type header).
 * The service MUST process the requests within a batch request sequentially. Processing stops on the first
 * error unless the odata.continue-on-error preference is specified.
 */
class BatchExecutionInfoSerialProcessor {
    /**
     * Creates an instance of BatchExecutionInfoSerialProcessor
     * @param {BatchContext} batchContext the batch context
     */
    constructor(batchContext) {
        /**
         * Batch context
         * @type {BatchContext}
         * @private
         */
        this._batchContext = batchContext;

        /**
         * List of commands to be executed
         * @type {Command[]}
         * @private
         */
        this._executionCommands = batchContext.getExecutionInfo();
    }

    /**
     * Process the commands contained in the batch request.
     * @param {Command~Next} next the next callback
     */
    process(next) {
        this._execute(0, next);
    }

    /**
     * Executes the command referenced by its index recursively. The execution is asynchronous.
     * @param {number} index The current command index to execute
     * @param {Function} callback called when chain ends or an error occurs
     * @private
     */
    _execute(index, callback) {
        const currentCommand = this._executionCommands[index];

        if (!currentCommand) {
            // Finished
            callback();
        } else {

            const next = (err) => {
                if (err) {
                    // Error occurred in batch processing itself but NOT while executing a batched request
                    callback(err);

                } else if (this._batchContext.getFailedRequestsOfBatchRequest().length > 0
                    || this._batchContext.getFailedAtomicityGroups().size > 0) {
                    if (this._batchContext.isContinueOnError()) {
                        // Continue execution -> Preference continue-on-error was applied
                        this._batchContext.getResponse().getPreferencesApplied()
                            .setOdataContinueOnErrorApplied(true);
                        process.nextTick(() => this._execute(index + 1, callback));
                    } else {
                        // Just stop execution.
                        callback();
                    }
                } else {
                    process.nextTick(() => this._execute(index + 1, callback));
                }
            };

            try {
                currentCommand.execute(next);
            } catch (innerError) {
                // Error occurred in batch processing itself  but NOT while executing a batched request
                callback(innerError);
            }
        }
    }
}

module.exports = BatchExecutionInfoSerialProcessor;
