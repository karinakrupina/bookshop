'use strict';

const commons = require('@sap/odata-commons');
const HeaderNames = commons.http.HttpHeader.HeaderNames;
const HttpStatusCode = commons.http.HttpStatusCode;
const HttpStatusCodes = HttpStatusCode.StatusCodes;
const HttpStatusCodesText = HttpStatusCode.Texts;
const BatchContext = require('./BatchContext');
const BatchErrorInfo = require('./BatchErrorInfo');
const OdataResponseInBatch = require('../core/OdataResponseInBatch');
const PlainHttpResponse = require('../core/PlainHttpResponse');

const reg = /\$\w*/g;

/**
 * Start the execution of a Request contained within request to $batch.
 */
class BatchedRequestExecutor {

    /**
     * Constructor
     * @param {BatchContext} batchContext Batch context
     * @param {OdataRequestInBatch} request Batched request
     */
    constructor(batchContext, request) {

        /**
         * Batch context
         * @type {BatchContext}
         * @private
         */
        this._batchContext = batchContext;

        /**
         * Request to be executed
         * @type {OdataRequestInBatch}
         * @private
         */
        this._request = request;
    }

    /**
     * Returns true if all dependencies are fulfilled.
     * @returns {boolean} whether all dependencies are fulfilled
     */
    dependenciesExecuted() {
        const dependencies = this._request.getDependsOnList();
        for (let value of dependencies) {
            if (!this._batchContext.isIdExecuted(value)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Executes a batched request with forwarding the requests http data to the process method of the service
     * @param {Command~Next} next Callback
     */
    execute(next) {
        const oDataRequestID = this._request.getOdataRequestId();
        const service = this._batchContext.getService();

        const plainHttpRequest = this._request.getIncomingRequest();
        const plainHttpResponse = new PlainHttpResponse();
        const odataResponseInBatch = new OdataResponseInBatch(plainHttpResponse, null, oDataRequestID);

        const atomicityGroupId = this._request.getAtomicityGroupId();

        // transfer information to nested ODataRequest via PlaintHttpRequest
        plainHttpRequest.setOdataRequestId(oDataRequestID);
        plainHttpRequest.setBatchInfo({ context: this._batchContext });

        if (atomicityGroupId) {
            plainHttpRequest.setAtomicityGroupId(atomicityGroupId);
            odataResponseInBatch.setAtomicityGroupId(atomicityGroupId);
        }
        this._batchContext.addResponseInBatch(odataResponseInBatch);

        // all dependencies must be full filled
        if (this._batchContext.getSemantic() === BatchContext.SEMANTIC.JSON && !this.dependenciesExecuted()) {
            plainHttpResponse.statusCode = HttpStatusCodes.FAILED_DEPENDENCY;
            plainHttpResponse.statusMessage = HttpStatusCodesText[HttpStatusCodes.FAILED_DEPENDENCY];
            next();
        } else {

            this.insertContentIdsIntoRequestUrl();

            service.process(plainHttpRequest, plainHttpResponse)
                .then((/* ignore result, read status code */) => {
                    const statusCode = plainHttpResponse.statusCode;
                    if (statusCode >= 400 && statusCode < 600) {
                        const errorInfo = new BatchErrorInfo(oDataRequestID, this._request, odataResponseInBatch);
                        this._batchContext.markRequestAsFailed(errorInfo);
                    } else {

                        // store location header
                        const locationHeader = plainHttpResponse.getHeader(HeaderNames.LOCATION);
                        if (locationHeader) {
                            this._batchContext.addLocation(atomicityGroupId, oDataRequestID, locationHeader);
                        }

                        this._batchContext.markIdAsExecuted(oDataRequestID);
                    }
                    next();
                })
                .catch(next);
        }
    }

    /**
     * Apply content Id referencing
     */
    insertContentIdsIntoRequestUrl() {
        let url = this._request.getIncomingRequest().url;
        if (!url.includes('$')) return;

        const atomicityGroup = this._request.getAtomicityGroupId();

        let ids = this._extractIds(url);
        for (const id of ids) {
            const replacement = this._batchContext.getLocation(atomicityGroup, id.substring(1));
            if (replacement) {
                url = url.replace(id, replacement);
            }
        }

        this._request.rewriteUrl(url);
    }

    /**
     * Extract ids with the reqex pattern $(w*) from the input.
     * @param {string} input the input
     * @returns {string[]} Array of extracted id names
     */
    _extractIds(input) {
        let ids = [];

        let myArray;
        myArray = reg.exec(input);
        while (myArray !== null) {
            ids.push(myArray[0]);
            myArray = reg.exec(input); // search next
        }

        return ids;
    }
}

module.exports = BatchedRequestExecutor;
