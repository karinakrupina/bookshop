'use strict';

const AtomicityGroupStartCommand = require('../invocation/batch/AtomicityGroupStartCommand');
const AtomicityGroupEndCommand = require('../invocation/batch/AtomicityGroupEndCommand');

/**
 * The AtomicityGroupExecutor executes a chain of batch commands and handles possible errors.
 * The error handling respects the $batch error specifications. It ensures that the AtomicityGroupEndHandler is
 * called in any case to allow the application to do a proper cleanup.
 *
 * 11.7.2 Batch Request Body
 * The body of a batch request is made up of a series of individual requests and change sets, each represented as a
 * distinct MIME part (i.e. separated by the boundary defined in the Content-Type header).
 * The service MUST process the requests within a batch request sequentially. Processing stops on the first
 * error unless the odata.continue-on-error preference is specified.
 */
class AtomicityGroupExecutor {

    /**
     * Creates an instance of AtomicityGroupExecutor
     * @param {BatchContext} batchContext the batch context
     * @param {BatchedRequestExecutionCommand[]} atomicityGroupCommands the commands in the atomicity group
     * @param {string} atomicityGroupId the ID of the atomicity group
     */
    constructor(batchContext, atomicityGroupCommands, atomicityGroupId) {
        /**
         * Batch context
         * @type {BatchContext}
         * @private
         */
        this._batchContext = batchContext;

        /**
         * Atomicity group id
         * @type {string}
         * @private
         */
        this._atomicityGroupId = atomicityGroupId;

        /**
         * Command list to be processed
         * @type {Command[]}
         * @private
         */
        this._executionCommands = [new AtomicityGroupStartCommand(batchContext, atomicityGroupId)]
            .concat(atomicityGroupCommands);
    }

    /**
     * Process the commands contained in the atomicity group.
     * @param {Command~Next} next the callback function
     */
    process(next) {
        this._execute(0, (err) => {
            // end command handler MUST always be called
            const atomGroupEndCommand = new AtomicityGroupEndCommand(this._batchContext, this._atomicityGroupId, err);
            // An error in the application's exit handler is considered as an internal batch processing error and
            // the batch processing MUST be stopped, hence forward the error.
            return atomGroupEndCommand.execute((error, repeat) => {
                if (repeat) {
                    // clean up
                    this._batchContext.getLogger().info('Re-executing atomicity group ' + this._atomicityGroupId);
                    this._batchContext.removeAtomicityGroup(this._atomicityGroupId);
                    return this.process(next);
                }

                return next(error);
            });
        });
    }

    /**
     * Executes the command referenced by its index recursively. The execution is asynchronous.
     *
     * @param {number} index The current command index to execute
     * @param {Function} callback called when chain ends or an error occurs
     * @private
     */
    _execute(index, callback) {
        const currentCommand = this._executionCommands[index];

        if (!currentCommand) {
            // Finished
            callback();
        } else {
            try {
                currentCommand.execute(err => {
                    // in case of frameworks errors forward that error
                    if (err) {
                        // Stop execution of commands with error.
                        callback(err);

                        // In case a batched request could not be executed the command chain is STOPPED
                        // except there is odata.continue-on-error set as prefer header.
                    } else if (!this._batchContext.isAtomicityGroupExecuted(this._atomicityGroupId)
                        && !this._batchContext.isContinueOnError()) {
                        // Just stop execution.
                        callback();
                    } else {
                        // Execute the next command.
                        process.nextTick(() => this._execute(index + 1, callback));
                    }
                });
            } catch (internalError) {
                // Error occurred in batch processing itself but NOT while executing a batched request.
                callback(internalError);
            }
        }
    }
}

module.exports = AtomicityGroupExecutor;
