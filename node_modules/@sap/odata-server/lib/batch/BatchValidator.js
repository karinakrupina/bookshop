'use strict';

const DeserializationError = require('../errors/DeserializationError');

/**
 * List of header not allowed in batched requests
 */
const forbiddenHeaders = [
    'authorization',
    'proxy-authorization',
    'expect',
    'from',
    'max-forwards',
    'range',
    'TE'
];

/**
 * Checks request for invalid headers and throws exception if one is found.
 * @param {OdataRequest|PlainHttpRequest} request request
 * @param {number} index index for error information
 * @private
 */
function checkHeaders(request, index) {
    for (const header of forbiddenHeaders) {
        if (request.getHeader(header)) {
            throw new DeserializationError(
                `Request in batch at position ${index} contains invalid header '` + header + "'");
        }
    }
}

/**
 * Class containing method to validate batch requests
 */
class BatchValidator {

    /**
     * Validates a batch request for correct request IDs, header, dependencies, ...
     * @param {BatchContext} batchContext batch context
     */
    static validate(batchContext) {
        /**
         * @type {OdataRequestInBatch[]}
         * @private
         */
        const requestsInBatch = batchContext.getRequestList();

        /**
         * @type {Map.<OdataRequestInBatch>}
         * @private
         */
        let usedIds = new Map();

        /**
         * @type {Set<number>}
         * @private
         */
        let usedAtomicGroups = new Map();

        /**
         * @type {string}
         * @private
         */
        let lastUsedAtomicityGroupId = null;

        let index = 0;

        for (const req of requestsInBatch) {
            const requestID = req.getOdataRequestId();
            const atomicityGroupId = req.getAtomicityGroupId();
            const dependsOn = req.getDependsOnList();

            // CHECK - Forbidden headers
            checkHeaders(req, index);


            // CHECK - Request ID must be filled
            if (!requestID) {
                throw new DeserializationError(
                    `Request in batch at position ${index} must have a request ID`);
            }

            // CHECK - Request IDs must be unique
            BatchValidator.assertUnique(usedIds, requestID, 'Request ID', index);
            usedIds.set(requestID, req);

            // CHECK - Request IDs must not collide with atomicity group
            BatchValidator.assertUnique(usedAtomicGroups, requestID, 'Request ID', index);

            // CHECK - Atomicity groups must continuous and unique
            if (atomicityGroupId !== lastUsedAtomicityGroupId) {
                if (atomicityGroupId) {
                    BatchValidator.assertUnique(usedAtomicGroups, atomicityGroupId, 'Atomicity group', index);
                    usedAtomicGroups.set(atomicityGroupId, null);
                }
                // CHECK - Request IDs must not collide with request IDs
                BatchValidator.assertUnique(usedIds, atomicityGroupId, 'Atomicity group', index);
            }

            for (const id of dependsOn) {
                // CHECK - no self referencing
                if (id === requestID) {
                    throw new DeserializationError(
                        `Request in batch at position ${index} depends own ID '${id}'`);
                }

                // CHECK - IDs in depends on list must already collected as atomicity group or as request
                if (!usedIds.has(id) && !usedAtomicGroups.has(id)) {
                    throw new DeserializationError(`Request in batch at position ${index} depends on unknown `
                        + `request/atomitcity group with ID '${id}'`);
                }

                if (usedIds.has(id)) {
                    const requiredAtomicityGroup = usedIds.get(id).getAtomicityGroupId();

                    // CHECK - if request ID in dependOn references an request then the requests atomicity group must also referenced
                    if (requiredAtomicityGroup
                        && (requiredAtomicityGroup !== atomicityGroupId)
                        && !dependsOn.includes(requiredAtomicityGroup)) {
                        throw new DeserializationError(
                            `Request in batch at position ${index} depends on request with ID '${id}'`
                            + ` whose atomicity group ${requiredAtomicityGroup} must also referenced`);
                    }
                }
            }

            lastUsedAtomicityGroupId = atomicityGroupId;
            index++;
        }
    }

    /**
     * Assess that a key is not inside a map.
     * @param {Map.<string, *>} map Map to be searched
     * @param {string} key Key which is search
     * @param {string} itemName item name
     * @param {number} index position
     */
    static assertUnique(map, key, itemName, index) {
        if (map.has(key)) {
            throw new DeserializationError(
                `${itemName} '${key}' of request in batch at position ${index} already in use`);
        }
    }
}

module.exports = BatchValidator;
