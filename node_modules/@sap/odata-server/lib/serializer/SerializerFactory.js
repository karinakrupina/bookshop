'use strict';

const commons = require('@sap/odata-commons');
const EdmTypeKind = commons.edm.EdmType.TypeKind;
const EdmPrimitiveTypeKind = commons.edm.EdmPrimitiveTypeKind;
const JsonContentTypeInfo = commons.format.JsonContentTypeInfo;
const ContentTypes = JsonContentTypeInfo.ContentTypes;
const MetaProperties = commons.format.JsonFormat.MetaProperties;
const ValueValidator = commons.validator.ValueValidator;
const QueryOptions = commons.uri.UriInfo.QueryOptions;
const HeaderNames = commons.http.HttpHeader.HeaderNames;
const ValueTextSerializer = commons.serializer.ValueTextSerializer;
const ResourceJsonSerializer = require('./ResourceJsonSerializer');
const SerializationError = require('../errors/SerializationError');
const ExpandHelper = require('../utils/ExpandHelper');

/**
 * Function interface for serializer functions
 *
 * @callback SerializerFunction
 * @param {Context} odata context
 * @param {Object} data
 * @param {Object} options
 * @param {Function} next
 */

class SerializerFactory {

    /**
     * Check JSON format parameters.
     * @param {Array.<{ name: string, value: string }>} parameters the format parameters
     * @returns {boolean} whether the parameters are supported
     */
    static checkJsonParameters(parameters) {
        for (const parameter of parameters) {
            const name = parameter.name.toLowerCase();
            const value = parameter.value.toLowerCase();
            switch (name) {
                case JsonContentTypeInfo.FormatParameter.ODATA_METADATA:
                    if (value !== JsonContentTypeInfo.FormatParameterMetadataValues.MINIMAL) return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.STREAMING:
                    if (value !== 'false') return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.IEEE754.toLowerCase():
                    if (value !== 'false' && value !== 'true') return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.EXPONENTIAL_DECIMALS.toLowerCase():
                    if (value !== 'false' && value !== 'true') return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.CHARSET.toLowerCase():
                    if (!value) return false;
                    break;
                default:
                    return false;
            }
        }
        return true;
    }

    /**
     * Serializes entity-collection resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceEntityCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceEntityCollection()...');

        const request = context.getRequest();
        const uriInfo = request.getUriInfo();
        const entitySet = uriInfo.getLastSegment().getEntitySet() || uriInfo.getLastSegment().getTarget();
        const entityType = uriInfo.getFinalEdmType();
        // A transient type (recognized through its method getOptionalProperty) has no entity set.
        const entityTypeOrSet = entityType.getOptionalProperty ? entityType : entitySet || entityType;

        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));

        const content = serializer.serializeEntityCollection(entityTypeOrSet, data,
            uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
            !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction());

        next(null, content);
    }

    /**
     * Serializes entity resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceEntity(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceEntity()...');

        let content;
        if (data.value) {
            const request = context.getRequest();
            const uriInfo = request.getUriInfo();
            const entitySet = uriInfo.getLastSegment().getEntitySet() || uriInfo.getLastSegment().getTarget();
            const entityType = uriInfo.getFinalEdmType();
            // A transient type (recognized through its method getOptionalProperty) has no entity set.
            const entityTypeOrSet = entityType.getOptionalProperty ? entityType : entitySet || entityType;

            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializeEntity(entityTypeOrSet, data,
                uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
                !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction());
        }
        next(null, content);
    }

    /**
     * Serializes primitive resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourcePrimitive(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourcePrimitive()...');

        let content;
        if (data.value !== undefined) {
            const request = context.getRequest();
            const lastSegment = request.getUriInfo().getLastSegment();
            const propertyOrReturnType = lastSegment.getProperty()
                || (lastSegment.getFunction() || lastSegment.getAction()).getReturnType();
            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializePrimitive(propertyOrReturnType, data,
                !!request.getConcurrentResource() && !lastSegment.getAction());
        }
        next(null, content);
    }

    /**
     * Serializes primitive-collection resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourcePrimitiveCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourcePrimitiveCollection()...');

        const request = context.getRequest();
        const lastSegment = request.getUriInfo().getLastSegment();
        const propertyOrReturnType = lastSegment.getProperty()
            || (lastSegment.getFunction() || lastSegment.getAction()).getReturnType();
        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
        next(null, serializer.serializePrimitiveCollection(propertyOrReturnType, data,
            !!request.getConcurrentResource() && !lastSegment.getAction()));
    }

    /**
     * Serializes complex resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceComplex(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceComplex()...');

        let content;
        if (data.value !== null && data.value !== undefined) {
            const request = context.getRequest();
            const uriInfo = request.getUriInfo();
            const lastSegment = uriInfo.getLastSegment();
            const propertyOrReturnType = lastSegment.getProperty()
                || (lastSegment.getFunction() || lastSegment.getAction()).getReturnType();
            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializeComplex(propertyOrReturnType, data,
                uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
                !!request.getConcurrentResource() && !lastSegment.getAction());
        }
        next(null, content);
    }

    /**
     * Serializes complex-collection resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceComplexCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceComplexCollection()...');

        const request = context.getRequest();
        const uriInfo = request.getUriInfo();
        const lastSegment = uriInfo.getLastSegment();
        const propertyOrReturnType = lastSegment.getProperty()
            || (lastSegment.getFunction() || lastSegment.getAction()).getReturnType();
        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
        next(null, serializer.serializeComplexCollection(propertyOrReturnType, data,
            uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
            !!request.getConcurrentResource() && !lastSegment.getAction()));
    }

    /**
     * Serializes reference-collection resources.
     * @param {Context} context odata context
     * @param {Object[]} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceReferenceCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceReferenceCollection()...');

        const pathSegments = context.getRequest().getUriInfo().getPathSegments();
        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
        next(null, serializer.serializeReferenceCollection(pathSegments, data));
    }

    /**
     * Serializes reference resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceReference(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceReference()...');

        let content;
        if (data && data.value) {
            const pathSegments = context.getRequest().getUriInfo().getPathSegments();
            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializeReference(pathSegments, data);
        }
        next(null, content);
    }

    /**
     * Serializes primitive-property raw values.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static value(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.value()...');

        const response = context.getResponse();
        const uriInfo = context.getRequest().getUriInfo();
        let type = uriInfo.getFinalEdmType();
        if (type.getKind() === EdmTypeKind.DEFINITION) type = type.getUnderlyingType();
        const segment = uriInfo.getLastSegment(type === EdmPrimitiveTypeKind.Stream ? 0 : -1);
        const propertyOrReturnType = segment.getProperty()
            || (segment.getFunction() || segment.getAction()).getReturnType();
        let value = data.value;

        if (value === null || value === undefined) {
            if (!propertyOrReturnType.isNullable()) throw new SerializationError('Not nullable value must not be null');
        } else if (type === EdmPrimitiveTypeKind.Binary) {
            new ValueValidator().validateBinary(value, propertyOrReturnType.getMaxLength());
            response.setHeader(HeaderNames.CONTENT_TYPE,
                data[MetaProperties.MEDIA_CONTENT_TYPE] || ContentTypes.BINARY);
        } else if (type === EdmPrimitiveTypeKind.Stream) {
            if (!value.pipe || typeof value.pipe !== 'function') {
                throw new SerializationError(
                    'Invalid value: ' + value + '. A stream must be specified for a value of Edm.Stream type.');
            }
            response.setHeader(HeaderNames.CONTENT_TYPE,
                data[MetaProperties.MEDIA_CONTENT_TYPE] || ContentTypes.BINARY);
        } else {
            value = new ValueTextSerializer().serialize(propertyOrReturnType, data);
            response.setHeader(HeaderNames.CONTENT_TYPE, ContentTypes.TEXT_PLAIN);
        }

        next(null, value);
    }
}

module.exports = SerializerFactory;
