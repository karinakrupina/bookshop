'use strict';

const BatchExitHandler = require('../../batch/BatchExitHandler');
const Command = require('../Command');

/**
 * Invokes the listener registered to be called if a atomicity group has been processed
 * @extends Command
 */
class AtomicityGroupEndCommand extends Command {
    /**
     * Constructor
     * @param {BatchContext} batchContext Batch context
     * @param {string} atomicityGroupId Atomicity group ID
     * @param {Error} internalError Internal Error given to the registered handler
     *
     */
    constructor(batchContext, atomicityGroupId, internalError) {
        super();

        /**
         * Batch context
         * @type {BatchContext}
         * @private
         */
        this._batchContext = batchContext;

        /**
         * Atomicity group id
         * @type {string}
         * @private
         */
        this._atomicityGroupId = atomicityGroupId;

        /**
         * Internal error given to the registered handler
         * @type {Error}
         * @private
         */
        this._internalError = internalError;


        /**
         * The registered listener function of the application
         * @type {Function}
         * @private
         */
        this._listener = batchContext.getService().getComponentManager()
            .getComponent(BatchExitHandler.ATOMICITY_GROUP_END);

        /**
         * Requests within the atomicity group
         * @type {Array.<OdataRequestInBatch>}
         * @private
         */
        this._requests = [];

        /**
         * Responses within the atomicity group
         * @type {Array.<OdataResponseInBatch>}
         * @private
         */
        this._responses = [];
    }


    /**
     * Add a request to the request list of the atomicity group
     * @param {OdataRequestInBatch} request the request
     * @returns {AtomicityGroupEndCommand} this instance
     */
    addRequest(request) {
        this._requests.push(request);
        return this;
    }

    /**
     * Add a response to the request list of the atomicity group
     * @param {OdataResponseInBatch} response the response
     * @returns {AtomicityGroupEndCommand} this instance
     */
    addResponse(response) {
        this._responses.push(response);
        return this;
    }

    /**
     * Executes the listener. The listener must execute the provided next function.
     * @param {Command~Next} next the next function
     */
    execute(next) {
        if (!this._listener) {
            if (this._batchContext.getFailedRequestsOfAtomicityGroup(this._atomicityGroupId).length === 0) {
                this._batchContext.markIdAsExecuted(this._atomicityGroupId);
            }
            next();
        } else {

            const context = {
                applicationData: this._batchContext.getRequest().getApplicationData(),
                failedRequests: this._batchContext.getFailedRequestsOfAtomicityGroup(this._atomicityGroupId),
                id: this._atomicityGroupId
            };

            try {
                this._listener(this._internalError, context, (applicationError, options) => {
                    if (options && options.repeat) {
                        next(null, true);
                    } else {

                        const error = applicationError || this._internalError;
                        if (error) {
                            this._batchContext.markAtomicityGroupAsFailed(this._atomicityGroupId, error);
                        } else if (context.failedRequests.length === 0) {
                            this._batchContext.markIdAsExecuted(this._atomicityGroupId);
                        }

                        next(error);
                    }
                });
            } catch (unplannedException) {
                this._batchContext.markAtomicityGroupAsFailed(this._atomicityGroupId, unplannedException);
                next(unplannedException);
            }
        }
    }
}

module.exports = AtomicityGroupEndCommand;
