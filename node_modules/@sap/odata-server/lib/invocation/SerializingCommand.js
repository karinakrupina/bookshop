'use strict';

const commons = require('@sap/odata-commons');
const HttpMethods = commons.http.HttpMethod.Methods;
const RepresentationKinds = commons.format.RepresentationKind.Kinds;
const MetaProperties = commons.format.JsonFormat.MetaProperties;
const Command = require('./Command');
const ExpandHelper = require('../utils/ExpandHelper');
const InternalServerError = require('../errors/InternalServerError');

/**
 * The `next` callback to be called upon finish execution.
 * @callback Next
 * @param {?Error} error An error if there is one or null if not
 */

/**
 * Executes the serialization of the provided data.
 * @extends Command
 */
class SerializingCommand extends Command {
    /**
     * Creates an instance of the SerializingCommand.
     * @param {Context} context The current odata context instance
     * @param {ContextUrlFactory} contextUrlFactory The context url factory to create the odata context url
     * @param {NextLinkSerializer} nextLinkSerializer The nextLink serializer to create a nextLink
     */
    constructor(context, contextUrlFactory, nextLinkSerializer) {
        super(context);
        this._contextUrlFactory = contextUrlFactory;
        this._nextLinkSerializer = nextLinkSerializer;
    }

    /**
     * Executes the registered serializing function bound with the contract created from the content negotiation.
     * @param {Next} next The next callback to be called on finish
     * @returns {undefined}
     */
    execute(next) {
        const context = this.getContext();
        const logger = context.getLogger();
        logger.path('Entering SerializingCommand.execute()...');

        const request = context.getRequest();
        const response = context.getResponse();

        if (response.isHeadersSent()) {
            logger.warning('Headers already sent');
            return next();
        }

        if (request.getMethod() === HttpMethods.HEAD) {
            // A body in the response is not needed in a HEAD request
            response.setBody('');
            logger.info('Omitting response payload serializing for HEAD request');
            return next();
        }

        const responseContract = response.getContract();
        const representationKind = responseContract.getRepresentationKind();
        const responseBody = response.getBody();

        if (representationKind === RepresentationKinds.METADATA && responseBody && responseBody.value) {
            // In case of locale-specific $metadata requests the application sets the metadata document
            // in the metadata handler. Thus serializing will be skipped in this case.
            response.setBody(responseBody.value);
            logger.info('Omitting response payload serializing for $metadata request');
            return next();
        }

        if (representationKind
            && representationKind !== RepresentationKinds.NO_CONTENT
            && representationKind !== RepresentationKinds.PRIMITIVE_VALUE
            && representationKind !== RepresentationKinds.BINARY
            && representationKind !== RepresentationKinds.COUNT
            && representationKind !== RepresentationKinds.BATCH) {

            logger.info('Preparing OData annotations...');
            let options = response.getOdataOptions();
            if (!options) {
                options = {};
                response.setOdataOptions(options);
            }

            const uriInfo = request.getUriInfo();

            if (responseBody && typeof responseBody === 'object' && !responseBody[MetaProperties.CONTEXT]) {
                this._addRootMetaProperty(representationKind, responseBody, MetaProperties.CONTEXT,
                    this._contextUrlFactory.createContextURL(
                        uriInfo, ExpandHelper.getFinalExpand(request), representationKind, options.keys,
                        context.getService().getEdm()));
            }

            const metadataEtag = context.getService().getMetadataEtag();
            if (responseBody && typeof responseBody === 'object' && metadataEtag) {
                this._addRootMetaProperty(representationKind, responseBody, MetaProperties.METADATA_ETAG, metadataEtag);
            }

            if (responseBody && typeof responseBody === 'object' && responseBody[MetaProperties.NEXT_LINK]) {
                // Skiptoken currently only allowed for Entity- and Reference-Collections
                if (representationKind !== RepresentationKinds.ENTITY_COLLECTION
                    && representationKind !== RepresentationKinds.REFERENCE_COLLECTION) {
                    return next(
                        new InternalServerError('Skiptoken is only allowed for entity- and reference-collections'));
                }

                // Check, whether a maxPageSize is configured for the returned Entity- or Reference-Collection
                const segment = uriInfo.getLastSegment(
                    representationKind === RepresentationKinds.REFERENCE_COLLECTION ? -1 : 0);
                if ((representationKind === RepresentationKinds.ENTITY_COLLECTION
                    || representationKind === RepresentationKinds.REFERENCE_COLLECTION)
                    && (segment.getEntitySet() && !segment.getEntitySet().getMaxPageSize()
                        || segment.getTarget() && !segment.getTarget().getMaxPageSize())) {
                    return next(new InternalServerError('Skiptoken is only allowed for entity- '
                        + 'and reference-collections where a maximum page size is configured'));
                }

                const odataPath = request.getOdataPath();
                const queryOptionsString = request.getUrlObject().search;
                responseBody[MetaProperties.NEXT_LINK] = this._nextLinkSerializer
                    .serializeNextLink(odataPath, queryOptionsString, responseBody[MetaProperties.NEXT_LINK]);
            }
        }

        logger.info('Start response payload serializing...');

        const options = response.getOdataOptions();
        let serialize = responseContract.getSerializerFunction();
        serialize(context, responseBody, options, (error, serializedBody) => {
            response.setBody(serializedBody);
            next(error);
        });

        return undefined;
    }

    /**
     * Add an annotation to a target object.
     * @param {RepresentationKind.Kinds} representationKind representation kind of the target
     * @param {Object} targetParam the target object
     * @param {string} annotation the name of the annotation
     * @param {string} value the value of the annotation
     * @private
     */
    _addRootMetaProperty(representationKind, targetParam, annotation, value) {
        let target = targetParam;
        if (target.value
            && (representationKind === RepresentationKinds.ENTITY
                || representationKind === RepresentationKinds.COMPLEX
                || representationKind === RepresentationKinds.REFERENCE)) {
            target.value[annotation] = value;
        } else {
            target[annotation] = value;
        }
    }
}

module.exports = SerializingCommand;
