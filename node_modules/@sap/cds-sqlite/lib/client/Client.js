const { Database } = require('sqlite3')
const SqliteStatement = require('../statement/SqliteStatement')
const {
  BaseClient,
  errors: { IllegalFunctionArgumentError, InconsistentClientError },
  builder: { sqlFactory },
  expand: { createJoinCQNFromExpanded, hasExpand, rawToExpanded },
  composition: {
    hasCompositionDelete,
    createCascadeDeleteCQNs,
    hasDeepInsert,
    createDeepInsertCQNs,
    hasDeepUpdate,
    selectDeepUpdateData,
    createDeepUpdateCQNs
  },
  contains: { replaceContainsWithLike, hasContains },
  postProcessing: { getPostProcessMapper, postProcess }
} = require('@sap/cds-sql')

const { convertToBoolean, convertInt64ToString, convertToISOTime, convertToISONoMillis } = require('./util')

class Client extends BaseClient {
  /**
   * Create an SqliteClient object.
   *
   * @param {Object} credentials - Connection details.
   * @param {string} credentials.database - Filename to the database or :memory; for in memory
   */
  constructor (credentials) {
    super([
      ['cds.Boolean', convertToBoolean],
      ['cds.Integer64', convertInt64ToString],
      ['cds.DateTime', convertToISONoMillis],
      ['cds.Timestamp', convertToISOTime]
    ])

    this._credentials = Object.assign({}, credentials)
    this._user = 'anonymous' // default user
    this._transCount = 0
  }

  /**
   * Open database connection.
   *
   * Opening connection occurs while opening Sqlite database.
   *
   * @returns {Promise} Promise, that resolves with SqliteClient if _credentials is successful or rejects with error if not.
   */
  connect () {
    return new Promise((resolve, reject) => {
      // .options() will ensure that credentials.database is set
      if (!this._credentials) {
        return reject(new IllegalFunctionArgumentError('options.credentials'))
      }

      this._dbc = new Database(this._credentials.database, err => {
        if (err) {
          return reject(err)
        }

        resolve(this)
      })
    })
  }

  /**
   * Close database connection.
   *
   * Closing connection occurs while closing Sqlite database.
   *
   * @returns {Promise} Promise, that resolves if end is successful or rejects with error if not.
   */
  end () {
    return new Promise((resolve, reject) => {
      this._dbc.close(err => {
        if (err) {
          return reject(err)
        }

        resolve()
      })
    })
  }

  /**
   * Execute SQL statement.
   *
   * If execution of SQL statement requires additional values,
   * then the values to be provided as an array.
   * In order to provide multiple value sets with a single execute (example: batch insert)
   * values have to be provided as arrays of values composed in an outer array.
   *
   * Method returns a result object.
   * In case of SELECT the result object contains a result-set.
   * In other cases the result is an empty array - DIFFERENT TO HANA!
   *
   * The query can be provided as SQL string or as CQN object.
   *
   * @example <caption>Simple Select as SQL string<caption>
   * .execute("SELECT * FROM T")
   * @example <caption>Select with filter as SQL string<caption>
   * .execute("SELECT * FROM T WHERE X = ?", [1])
   * @example <caption>Single Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [1, 'a'])
   * @example <caption>Multiple Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [[1, 'a'], [2, 'b']])
   * @example <caption>Simple Select as CQN object<caption>
   * .execute(SELECT.from('T'))
   * @example <caption>Select with filter as CQN object<caption>
   * .execute(SELECT.from('T').where(['x', '=', 1])
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  execute (query, values = []) {
    if (this._toBeDestroyed) {
      return Promise.reject(new InconsistentClientError())
    }
    if (!Array.isArray(values)) {
      return Promise.reject(new IllegalFunctionArgumentError('values'))
    }

    if (typeof query === 'string') {
      return this._executeSQL(query, values)
    }

    if (typeof query === 'function') {
      return this._runBlock(query)
    }

    try {
      let newQuery = query
      if (query && hasContains(query)) {
        newQuery = replaceContainsWithLike(query)
      }

      if (hasExpand(newQuery)) {
        return this._processExpand(newQuery)
      }

      if (hasCompositionDelete(this._csn && this._csn.definitions, newQuery)) {
        return this._processCascadeDelete(newQuery)
      }

      if (hasDeepInsert(this._csn && this._csn.definitions, newQuery)) {
        return this._processDeepInsert(newQuery)
      }

      if (hasDeepUpdate(this._csn && this._csn.definitions, newQuery)) {
        return this._processDeepUpdate(newQuery)
      }

      return this._execute(newQuery, values)
      // The clients of this client are expecting a promise return in any case.
    } catch (err) {
      return Promise.reject(err)
    }
  }

  _execute (cqn, inValues = []) {
    const { sql, values = [] } = sqlFactory(
      cqn,
      {
        typeConversion: this._typeConversionMap,
        user: this._user,
        now: { sql: "strftime('%Y-%m-%dT%H:%M:%SZ','now')" } // '2012-12-03T07:16:23Z'
      },
      this._csn
    )
    const outValues = inValues.length > 0 ? inValues : values
    return this._executeSQL(sql, outValues, getPostProcessMapper(this._toService, this._csn, cqn))
  }

  /**
   * Checks which of the sqlite3 is most fitting for the sql values combination.
   * @param {string} sql - Raw SQL query string
   * @param {Array} values - Array of DML values, which are added as query parameters
   * @param {Map} [postMapper] - SELECT post processing type conversion config
   * @returns {*}
   * @private
   */
  _executeSQL (sql, values, postMapper) {
    if (this._isStatementType('select', sql)) {
      return this._executeSelect(sql, values, postMapper)
    }

    // Only bulk inserts will have arrays in arrays
    if (this._isStatementType('insert', sql) && Array.isArray(values[0]) && values.length > 1) {
      return this._bulkInsert(sql, values)
    }

    return this._runSingle(sql, Array.isArray(values[0]) ? values[0] : values)
  }

  _isStatementType (type, sql) {
    // Regex is faster than toLower + trim + startsWith
    return new RegExp(`^\\s*${type}`, 'i').test(sql)
  }

  _executeSelect (sql, values, postMapper) {
    return new Promise((resolve, reject) => {
      // All is faster than each for us, as the result needs to be returned as whole.
      this._dbc.all(sql, values, (err, result) => {
        if (err) {
          err.failedQuery = sql
          return reject(err)
        }

        resolve(postProcess(result, postMapper))
      })
    })
  }

  _runSingle (sql, values) {
    return new Promise((resolve, reject) => {
      this._dbc.run(sql, values, function (err) {
        if (err) {
          err.failedQuery = sql
          return reject(err)
        }

        resolve(this.changes)
      })
    })
  }

  _bulkInsert (sql, values) {
    return this.prepareStatement(sql)
      .then(stmt => stmt.execute(values))
      .then(() => values.length)
  }

  _processExpand (cqn) {
    const queries = []
    const expandQueries = createJoinCQNFromExpanded(cqn, this._csn)

    for (const cqn of expandQueries.queries) {
      cqn._conversionMapper = getPostProcessMapper(this._toService, this._csn, cqn)

      const { sql, values } = sqlFactory(cqn)
      queries.push(this._executeSelect(sql, values, false))
    }

    return rawToExpanded(expandQueries, queries)
  }

  _processCascadeDelete (cqn) {
    return this.processNestedCQNs(
      createCascadeDeleteCQNs(this._csn && this._csn.definitions, cqn),
      this._execute.bind(this)
    )
  }

  _processDeepInsert (cqn) {
    return this.processNestedCQNs(
      [createDeepInsertCQNs(this._csn && this._csn.definitions, cqn)],
      this._execute.bind(this)
    )
  }

  _processDeepUpdate (cqn) {
    /* istanbul ignore next */
    return selectDeepUpdateData(this._csn && this._csn.definitions, cqn, this._execute.bind(this)).then(selectData => {
      return this.processNestedCQNs(
        createDeepUpdateCQNs(this._csn && this._csn.definitions, cqn, selectData),
        this._execute.bind(this)
      )
    })
  }

  /**
   * Prepare SQL statement.
   *
   * @param {string} sql - SQL statement.
   * @returns {Promise} Promise, that resolves with SqliteStatement if successful and rejects if not.
   */
  prepareStatement (sql) {
    return new Promise((resolve, reject) => {
      this._dbc.serialize(() => {
        const stmt = this._dbc.prepare(sql, err => {
          if (err) {
            err.failedQuery = sql
            return reject(err)
          }

          resolve(new SqliteStatement(stmt, this._dbc))
        })
      })
    })
  }

  /**
   * Returns connection state.
   *
   * @returns {boolean} true for connected, false for not connected
   */
  isConnected () {
    return this._dbc.open === true
  }

  /**
   * Set database locale.
   *
   * Locale is currently not supported by the node.js Sqlite driver.
   * There is a possibility to set locale in Sqlite, for example, in Java:
   * https://stackoverflow.com/questions/13720092/why-and-where-to-call-setlocale
   */
  setLocale () {}

  /**
   * Set database user.
   *
   * Username/password is not supported by default in Sqlite.
   */
  setUser (user) {
    this._user = user || 'anonymous'
  }

  /**
   * Execute begin transaction.
   *
   * @returns {Promise} - Resolves if begin is successful, rejects if not.
   */
  begin () {
    this._transCount++
    if (this._transCount === 1) {
      return this.execute('BEGIN')
    }

    return Promise.resolve()
  }

  /**
   * Execute commit transaction.
   *
   * @returns {Promise} - Resolves if commit is successful, rejects if not.
   */
  commit () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }

    this._transCount--
    if (this._transCount === 0) {
      return this.execute('COMMIT')
    }

    return Promise.resolve()
  }

  /**
   * Execute rollback transaction.
   *
   * @returns {Promise} - Resolves if rollback is successful, rejects if not.
   */
  rollback () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }

    this._transCount--
    if (this._transCount === 0) {
      return this.execute('ROLLBACK')
    }

    return Promise.resolve()
  }

  /**
   * Forwards deploy to the base class providing client information.
   * @param {Object|Promise} csn - the unreflected CSN or promise that will resolve into csn.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    return super.deploy(csn, 'sqlite')
  }
}

module.exports = Client
